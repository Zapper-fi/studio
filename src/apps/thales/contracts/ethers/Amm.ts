/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export declare namespace SportAMMLiquidityPool {
  export type InitParamsStruct = {
    _owner: PromiseOrValue<string>;
    _sportsAmm: PromiseOrValue<string>;
    _sUSD: PromiseOrValue<string>;
    _roundLength: PromiseOrValue<BigNumberish>;
    _maxAllowedDeposit: PromiseOrValue<BigNumberish>;
    _minDepositAmount: PromiseOrValue<BigNumberish>;
    _maxAllowedUsers: PromiseOrValue<BigNumberish>;
  };

  export type InitParamsStructOutput = [string, string, string, BigNumber, BigNumber, BigNumber, BigNumber] & {
    _owner: string;
    _sportsAmm: string;
    _sUSD: string;
    _roundLength: BigNumber;
    _maxAllowedDeposit: BigNumber;
    _minDepositAmount: BigNumber;
    _maxAllowedUsers: BigNumber;
  };
}

export interface AmmInterface extends utils.Interface {
  functions: {
    'acceptOwnership()': FunctionFragment;
    'allocationPerRound(uint256)': FunctionFragment;
    'balancesPerRound(uint256,address)': FunctionFragment;
    'canCloseCurrentRound()': FunctionFragment;
    'closeRound()': FunctionFragment;
    'commitTrade(address,uint256)': FunctionFragment;
    'cumulativePnLBetweenRounds(uint256,uint256)': FunctionFragment;
    'cumulativeProfitAndLoss(uint256)': FunctionFragment;
    'defaultLiquidityProvider()': FunctionFragment;
    'deposit(uint256)': FunctionFragment;
    'exerciseMarketsReadyToExercised()': FunctionFragment;
    'firstRoundStartTime()': FunctionFragment;
    'getMarketPool(address)': FunctionFragment;
    'getMarketRound(address)': FunctionFragment;
    'getMaxAvailableDepositForUser(address)': FunctionFragment;
    'getNeededStakedThalesToWithdrawForUser(address)': FunctionFragment;
    'getOptionsForBuy(address,uint256,uint8)': FunctionFragment;
    'getOptionsForBuyByAddress(address,uint256,address)': FunctionFragment;
    'getOrCreateMarketPool(address)': FunctionFragment;
    'getRoundEndTime(uint256)': FunctionFragment;
    'getRoundStartTime(uint256)': FunctionFragment;
    'hasMarketsReadyToBeExercised()': FunctionFragment;
    'initNonReentrant()': FunctionFragment;
    'initialize((address,address,address,uint256,uint256,uint256,uint256))': FunctionFragment;
    'isTradingMarketInARound(uint256,address)': FunctionFragment;
    'isUserLPing(address)': FunctionFragment;
    'marketAlreadyExercisedInRound(uint256,address)': FunctionFragment;
    'maxAllowedDeposit()': FunctionFragment;
    'maxAllowedUsers()': FunctionFragment;
    'minDepositAmount()': FunctionFragment;
    'needsTransformingCollateral()': FunctionFragment;
    'nominateNewOwner(address)': FunctionFragment;
    'nominatedOwner()': FunctionFragment;
    'onlyWhitelistedStakersAllowed()': FunctionFragment;
    'owner()': FunctionFragment;
    'paused()': FunctionFragment;
    'poolRoundMastercopy()': FunctionFragment;
    'profitAndLossPerRound(uint256)': FunctionFragment;
    'round()': FunctionFragment;
    'roundLength()': FunctionFragment;
    'roundPools(uint256)': FunctionFragment;
    'sUSD()': FunctionFragment;
    'setDefaultLiquidityProvider(address)': FunctionFragment;
    'setMaxAllowedDeposit(uint256)': FunctionFragment;
    'setMaxAllowedUsers(uint256)': FunctionFragment;
    'setMinAllowedDeposit(uint256)': FunctionFragment;
    'setNeedsTransformingCollateral(bool)': FunctionFragment;
    'setOnlyWhitelistedStakersAllowed(bool)': FunctionFragment;
    'setOwner(address)': FunctionFragment;
    'setPaused(bool)': FunctionFragment;
    'setPoolRoundMastercopy(address)': FunctionFragment;
    'setRoundLength(uint256)': FunctionFragment;
    'setSportAmm(address)': FunctionFragment;
    'setStakedThalesMultiplier(uint256)': FunctionFragment;
    'setStakingThales(address)': FunctionFragment;
    'setWhitelistedAddresses(address[],bool)': FunctionFragment;
    'setWhitelistedStakerAddresses(address[],bool)': FunctionFragment;
    'sportsAMM()': FunctionFragment;
    'stakedThalesMultiplier()': FunctionFragment;
    'stakingThales()': FunctionFragment;
    'start()': FunctionFragment;
    'started()': FunctionFragment;
    'totalDeposited()': FunctionFragment;
    'tradingMarketsPerRound(uint256,uint256)': FunctionFragment;
    'transferOwnershipAtInit(address)': FunctionFragment;
    'transferTokens(address[],address,uint256,bool)': FunctionFragment;
    'transferTokensFromLiquidityPool(address[],address,uint256,bool,address)': FunctionFragment;
    'userInRound(uint256,address)': FunctionFragment;
    'usersCurrentlyInPool()': FunctionFragment;
    'usersPerRound(uint256,uint256)': FunctionFragment;
    'whitelistedDeposits(address)': FunctionFragment;
    'whitelistedStakers(address)': FunctionFragment;
    'withdrawalRequest()': FunctionFragment;
    'withdrawalRequested(address)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'acceptOwnership'
      | 'allocationPerRound'
      | 'balancesPerRound'
      | 'canCloseCurrentRound'
      | 'closeRound'
      | 'commitTrade'
      | 'cumulativePnLBetweenRounds'
      | 'cumulativeProfitAndLoss'
      | 'defaultLiquidityProvider'
      | 'deposit'
      | 'exerciseMarketsReadyToExercised'
      | 'firstRoundStartTime'
      | 'getMarketPool'
      | 'getMarketRound'
      | 'getMaxAvailableDepositForUser'
      | 'getNeededStakedThalesToWithdrawForUser'
      | 'getOptionsForBuy'
      | 'getOptionsForBuyByAddress'
      | 'getOrCreateMarketPool'
      | 'getRoundEndTime'
      | 'getRoundStartTime'
      | 'hasMarketsReadyToBeExercised'
      | 'initNonReentrant'
      | 'initialize'
      | 'isTradingMarketInARound'
      | 'isUserLPing'
      | 'marketAlreadyExercisedInRound'
      | 'maxAllowedDeposit'
      | 'maxAllowedUsers'
      | 'minDepositAmount'
      | 'needsTransformingCollateral'
      | 'nominateNewOwner'
      | 'nominatedOwner'
      | 'onlyWhitelistedStakersAllowed'
      | 'owner'
      | 'paused'
      | 'poolRoundMastercopy'
      | 'profitAndLossPerRound'
      | 'round'
      | 'roundLength'
      | 'roundPools'
      | 'sUSD'
      | 'setDefaultLiquidityProvider'
      | 'setMaxAllowedDeposit'
      | 'setMaxAllowedUsers'
      | 'setMinAllowedDeposit'
      | 'setNeedsTransformingCollateral'
      | 'setOnlyWhitelistedStakersAllowed'
      | 'setOwner'
      | 'setPaused'
      | 'setPoolRoundMastercopy'
      | 'setRoundLength'
      | 'setSportAmm'
      | 'setStakedThalesMultiplier'
      | 'setStakingThales'
      | 'setWhitelistedAddresses'
      | 'setWhitelistedStakerAddresses'
      | 'sportsAMM'
      | 'stakedThalesMultiplier'
      | 'stakingThales'
      | 'start'
      | 'started'
      | 'totalDeposited'
      | 'tradingMarketsPerRound'
      | 'transferOwnershipAtInit'
      | 'transferTokens'
      | 'transferTokensFromLiquidityPool'
      | 'userInRound'
      | 'usersCurrentlyInPool'
      | 'usersPerRound'
      | 'whitelistedDeposits'
      | 'whitelistedStakers'
      | 'withdrawalRequest'
      | 'withdrawalRequested',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'acceptOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'allocationPerRound', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'balancesPerRound',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'canCloseCurrentRound', values?: undefined): string;
  encodeFunctionData(functionFragment: 'closeRound', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'commitTrade',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'cumulativePnLBetweenRounds',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'cumulativeProfitAndLoss', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'defaultLiquidityProvider', values?: undefined): string;
  encodeFunctionData(functionFragment: 'deposit', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'exerciseMarketsReadyToExercised', values?: undefined): string;
  encodeFunctionData(functionFragment: 'firstRoundStartTime', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getMarketPool', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getMarketRound', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getMaxAvailableDepositForUser', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'getNeededStakedThalesToWithdrawForUser',
    values: [PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getOptionsForBuy',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getOptionsForBuyByAddress',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'getOrCreateMarketPool', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getRoundEndTime', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getRoundStartTime', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'hasMarketsReadyToBeExercised', values?: undefined): string;
  encodeFunctionData(functionFragment: 'initNonReentrant', values?: undefined): string;
  encodeFunctionData(functionFragment: 'initialize', values: [SportAMMLiquidityPool.InitParamsStruct]): string;
  encodeFunctionData(
    functionFragment: 'isTradingMarketInARound',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'isUserLPing', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'marketAlreadyExercisedInRound',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'maxAllowedDeposit', values?: undefined): string;
  encodeFunctionData(functionFragment: 'maxAllowedUsers', values?: undefined): string;
  encodeFunctionData(functionFragment: 'minDepositAmount', values?: undefined): string;
  encodeFunctionData(functionFragment: 'needsTransformingCollateral', values?: undefined): string;
  encodeFunctionData(functionFragment: 'nominateNewOwner', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'nominatedOwner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'onlyWhitelistedStakersAllowed', values?: undefined): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'paused', values?: undefined): string;
  encodeFunctionData(functionFragment: 'poolRoundMastercopy', values?: undefined): string;
  encodeFunctionData(functionFragment: 'profitAndLossPerRound', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'round', values?: undefined): string;
  encodeFunctionData(functionFragment: 'roundLength', values?: undefined): string;
  encodeFunctionData(functionFragment: 'roundPools', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'sUSD', values?: undefined): string;
  encodeFunctionData(functionFragment: 'setDefaultLiquidityProvider', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setMaxAllowedDeposit', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setMaxAllowedUsers', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setMinAllowedDeposit', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setNeedsTransformingCollateral', values: [PromiseOrValue<boolean>]): string;
  encodeFunctionData(functionFragment: 'setOnlyWhitelistedStakersAllowed', values: [PromiseOrValue<boolean>]): string;
  encodeFunctionData(functionFragment: 'setOwner', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setPaused', values: [PromiseOrValue<boolean>]): string;
  encodeFunctionData(functionFragment: 'setPoolRoundMastercopy', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setRoundLength', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setSportAmm', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setStakedThalesMultiplier', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setStakingThales', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'setWhitelistedAddresses',
    values: [PromiseOrValue<string>[], PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setWhitelistedStakerAddresses',
    values: [PromiseOrValue<string>[], PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'sportsAMM', values?: undefined): string;
  encodeFunctionData(functionFragment: 'stakedThalesMultiplier', values?: undefined): string;
  encodeFunctionData(functionFragment: 'stakingThales', values?: undefined): string;
  encodeFunctionData(functionFragment: 'start', values?: undefined): string;
  encodeFunctionData(functionFragment: 'started', values?: undefined): string;
  encodeFunctionData(functionFragment: 'totalDeposited', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'tradingMarketsPerRound',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'transferOwnershipAtInit', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'transferTokens',
    values: [PromiseOrValue<string>[], PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'transferTokensFromLiquidityPool',
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<string>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'userInRound',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'usersCurrentlyInPool', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'usersPerRound',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'whitelistedDeposits', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'whitelistedStakers', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'withdrawalRequest', values?: undefined): string;
  encodeFunctionData(functionFragment: 'withdrawalRequested', values: [PromiseOrValue<string>]): string;

  decodeFunctionResult(functionFragment: 'acceptOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allocationPerRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balancesPerRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'canCloseCurrentRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'closeRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'commitTrade', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cumulativePnLBetweenRounds', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cumulativeProfitAndLoss', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'defaultLiquidityProvider', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exerciseMarketsReadyToExercised', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'firstRoundStartTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getMarketPool', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getMarketRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getMaxAvailableDepositForUser', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getNeededStakedThalesToWithdrawForUser', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getOptionsForBuy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getOptionsForBuyByAddress', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getOrCreateMarketPool', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getRoundEndTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getRoundStartTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'hasMarketsReadyToBeExercised', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initNonReentrant', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isTradingMarketInARound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isUserLPing', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'marketAlreadyExercisedInRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'maxAllowedDeposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'maxAllowedUsers', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'minDepositAmount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'needsTransformingCollateral', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nominateNewOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nominatedOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'onlyWhitelistedStakersAllowed', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'paused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'poolRoundMastercopy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'profitAndLossPerRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'round', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'roundLength', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'roundPools', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'sUSD', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setDefaultLiquidityProvider', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMaxAllowedDeposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMaxAllowedUsers', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMinAllowedDeposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setNeedsTransformingCollateral', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setOnlyWhitelistedStakersAllowed', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setPaused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setPoolRoundMastercopy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setRoundLength', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setSportAmm', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setStakedThalesMultiplier', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setStakingThales', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setWhitelistedAddresses', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setWhitelistedStakerAddresses', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'sportsAMM', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stakedThalesMultiplier', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stakingThales', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'start', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'started', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalDeposited', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tradingMarketsPerRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnershipAtInit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferTokensFromLiquidityPool', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userInRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'usersCurrentlyInPool', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'usersPerRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'whitelistedDeposits', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'whitelistedStakers', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawalRequest', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawalRequested', data: BytesLike): Result;

  events: {
    'AddedIntoWhitelist(address,bool)': EventFragment;
    'AddedIntoWhitelistStaker(address,bool)': EventFragment;
    'Claimed(address,uint256)': EventFragment;
    'DefaultLiquidityProviderChanged(address)': EventFragment;
    'Deposited(address,uint256,uint256)': EventFragment;
    'MaxAllowedDepositChanged(uint256)': EventFragment;
    'MaxAllowedUsersChanged(uint256)': EventFragment;
    'MinAllowedDepositChanged(uint256)': EventFragment;
    'OwnerChanged(address,address)': EventFragment;
    'OwnerNominated(address)': EventFragment;
    'Paused(address)': EventFragment;
    'PoolRoundMastercopyChanged(address)': EventFragment;
    'PoolStarted()': EventFragment;
    'RoundClosed(uint256,uint256)': EventFragment;
    'RoundLengthChanged(uint256)': EventFragment;
    'RoundPoolCreated(uint256,address)': EventFragment;
    'SportAMMChanged(address)': EventFragment;
    'StakedThalesMultiplierChanged(uint256)': EventFragment;
    'StakingThalesChanged(address)': EventFragment;
    'Unpaused(address)': EventFragment;
    'WithdrawalRequested(address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'AddedIntoWhitelist'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'AddedIntoWhitelistStaker'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Claimed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'DefaultLiquidityProviderChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Deposited'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'MaxAllowedDepositChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'MaxAllowedUsersChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'MinAllowedDepositChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnerChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnerNominated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Paused'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'PoolRoundMastercopyChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'PoolStarted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoundClosed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoundLengthChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoundPoolCreated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SportAMMChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'StakedThalesMultiplierChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'StakingThalesChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Unpaused'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'WithdrawalRequested'): EventFragment;
}

export interface AddedIntoWhitelistEventObject {
  _whitelistAddress: string;
  _flag: boolean;
}
export type AddedIntoWhitelistEvent = TypedEvent<[string, boolean], AddedIntoWhitelistEventObject>;

export type AddedIntoWhitelistEventFilter = TypedEventFilter<AddedIntoWhitelistEvent>;

export interface AddedIntoWhitelistStakerEventObject {
  _whitelistAddress: string;
  _flag: boolean;
}
export type AddedIntoWhitelistStakerEvent = TypedEvent<[string, boolean], AddedIntoWhitelistStakerEventObject>;

export type AddedIntoWhitelistStakerEventFilter = TypedEventFilter<AddedIntoWhitelistStakerEvent>;

export interface ClaimedEventObject {
  user: string;
  amount: BigNumber;
}
export type ClaimedEvent = TypedEvent<[string, BigNumber], ClaimedEventObject>;

export type ClaimedEventFilter = TypedEventFilter<ClaimedEvent>;

export interface DefaultLiquidityProviderChangedEventObject {
  newProvider: string;
}
export type DefaultLiquidityProviderChangedEvent = TypedEvent<[string], DefaultLiquidityProviderChangedEventObject>;

export type DefaultLiquidityProviderChangedEventFilter = TypedEventFilter<DefaultLiquidityProviderChangedEvent>;

export interface DepositedEventObject {
  user: string;
  amount: BigNumber;
  round: BigNumber;
}
export type DepositedEvent = TypedEvent<[string, BigNumber, BigNumber], DepositedEventObject>;

export type DepositedEventFilter = TypedEventFilter<DepositedEvent>;

export interface MaxAllowedDepositChangedEventObject {
  maxAllowedDeposit: BigNumber;
}
export type MaxAllowedDepositChangedEvent = TypedEvent<[BigNumber], MaxAllowedDepositChangedEventObject>;

export type MaxAllowedDepositChangedEventFilter = TypedEventFilter<MaxAllowedDepositChangedEvent>;

export interface MaxAllowedUsersChangedEventObject {
  MaxAllowedUsersChanged: BigNumber;
}
export type MaxAllowedUsersChangedEvent = TypedEvent<[BigNumber], MaxAllowedUsersChangedEventObject>;

export type MaxAllowedUsersChangedEventFilter = TypedEventFilter<MaxAllowedUsersChangedEvent>;

export interface MinAllowedDepositChangedEventObject {
  minAllowedDeposit: BigNumber;
}
export type MinAllowedDepositChangedEvent = TypedEvent<[BigNumber], MinAllowedDepositChangedEventObject>;

export type MinAllowedDepositChangedEventFilter = TypedEventFilter<MinAllowedDepositChangedEvent>;

export interface OwnerChangedEventObject {
  oldOwner: string;
  newOwner: string;
}
export type OwnerChangedEvent = TypedEvent<[string, string], OwnerChangedEventObject>;

export type OwnerChangedEventFilter = TypedEventFilter<OwnerChangedEvent>;

export interface OwnerNominatedEventObject {
  newOwner: string;
}
export type OwnerNominatedEvent = TypedEvent<[string], OwnerNominatedEventObject>;

export type OwnerNominatedEventFilter = TypedEventFilter<OwnerNominatedEvent>;

export interface PausedEventObject {
  account: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface PoolRoundMastercopyChangedEventObject {
  newMastercopy: string;
}
export type PoolRoundMastercopyChangedEvent = TypedEvent<[string], PoolRoundMastercopyChangedEventObject>;

export type PoolRoundMastercopyChangedEventFilter = TypedEventFilter<PoolRoundMastercopyChangedEvent>;

export interface PoolStartedEventObject {}
export type PoolStartedEvent = TypedEvent<[], PoolStartedEventObject>;

export type PoolStartedEventFilter = TypedEventFilter<PoolStartedEvent>;

export interface RoundClosedEventObject {
  round: BigNumber;
  roundPnL: BigNumber;
}
export type RoundClosedEvent = TypedEvent<[BigNumber, BigNumber], RoundClosedEventObject>;

export type RoundClosedEventFilter = TypedEventFilter<RoundClosedEvent>;

export interface RoundLengthChangedEventObject {
  roundLength: BigNumber;
}
export type RoundLengthChangedEvent = TypedEvent<[BigNumber], RoundLengthChangedEventObject>;

export type RoundLengthChangedEventFilter = TypedEventFilter<RoundLengthChangedEvent>;

export interface RoundPoolCreatedEventObject {
  _round: BigNumber;
  roundPool: string;
}
export type RoundPoolCreatedEvent = TypedEvent<[BigNumber, string], RoundPoolCreatedEventObject>;

export type RoundPoolCreatedEventFilter = TypedEventFilter<RoundPoolCreatedEvent>;

export interface SportAMMChangedEventObject {
  sportAMM: string;
}
export type SportAMMChangedEvent = TypedEvent<[string], SportAMMChangedEventObject>;

export type SportAMMChangedEventFilter = TypedEventFilter<SportAMMChangedEvent>;

export interface StakedThalesMultiplierChangedEventObject {
  _stakedThalesMultiplier: BigNumber;
}
export type StakedThalesMultiplierChangedEvent = TypedEvent<[BigNumber], StakedThalesMultiplierChangedEventObject>;

export type StakedThalesMultiplierChangedEventFilter = TypedEventFilter<StakedThalesMultiplierChangedEvent>;

export interface StakingThalesChangedEventObject {
  stakingThales: string;
}
export type StakingThalesChangedEvent = TypedEvent<[string], StakingThalesChangedEventObject>;

export type StakingThalesChangedEventFilter = TypedEventFilter<StakingThalesChangedEvent>;

export interface UnpausedEventObject {
  account: string;
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface WithdrawalRequestedEventObject {
  user: string;
}
export type WithdrawalRequestedEvent = TypedEvent<[string], WithdrawalRequestedEventObject>;

export type WithdrawalRequestedEventFilter = TypedEventFilter<WithdrawalRequestedEvent>;

export interface Amm extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: AmmInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    allocationPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    balancesPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    canCloseCurrentRound(overrides?: CallOverrides): Promise<[boolean]>;

    closeRound(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    commitTrade(
      market: PromiseOrValue<string>,
      amountToMint: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    cumulativePnLBetweenRounds(
      roundA: PromiseOrValue<BigNumberish>,
      roundB: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    cumulativeProfitAndLoss(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    defaultLiquidityProvider(overrides?: CallOverrides): Promise<[string]>;

    deposit(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    exerciseMarketsReadyToExercised(
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    firstRoundStartTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    getMarketPool(market: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string] & { roundPool: string }>;

    getMarketRound(
      market: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { _round: BigNumber }>;

    getMaxAvailableDepositForUser(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        maxDepositForUser: BigNumber;
        availableToDepositForUser: BigNumber;
        stakedThalesForUser: BigNumber;
      }
    >;

    getNeededStakedThalesToWithdrawForUser(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { neededStaked: BigNumber }>;

    getOptionsForBuy(
      market: PromiseOrValue<string>,
      optionsAmount: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    getOptionsForBuyByAddress(
      market: PromiseOrValue<string>,
      optionsAmount: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    getOrCreateMarketPool(
      market: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    getRoundEndTime(_round: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    getRoundStartTime(_round: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    hasMarketsReadyToBeExercised(overrides?: CallOverrides): Promise<[boolean]>;

    initNonReentrant(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    initialize(
      params: SportAMMLiquidityPool.InitParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    isTradingMarketInARound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    isUserLPing(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean] & { isUserInLP: boolean }>;

    marketAlreadyExercisedInRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    maxAllowedDeposit(overrides?: CallOverrides): Promise<[BigNumber]>;

    maxAllowedUsers(overrides?: CallOverrides): Promise<[BigNumber]>;

    minDepositAmount(overrides?: CallOverrides): Promise<[BigNumber]>;

    needsTransformingCollateral(overrides?: CallOverrides): Promise<[boolean]>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    nominatedOwner(overrides?: CallOverrides): Promise<[string]>;

    onlyWhitelistedStakersAllowed(overrides?: CallOverrides): Promise<[boolean]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    poolRoundMastercopy(overrides?: CallOverrides): Promise<[string]>;

    profitAndLossPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    round(overrides?: CallOverrides): Promise<[BigNumber]>;

    roundLength(overrides?: CallOverrides): Promise<[BigNumber]>;

    roundPools(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    sUSD(overrides?: CallOverrides): Promise<[string]>;

    setDefaultLiquidityProvider(
      _defaultLiquidityProvider: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setMaxAllowedDeposit(
      _maxAllowedDeposit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setMaxAllowedUsers(
      _maxAllowedUsers: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setMinAllowedDeposit(
      _minDepositAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setNeedsTransformingCollateral(
      _needsTransformingCollateral: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setOnlyWhitelistedStakersAllowed(
      flagToSet: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setPaused(
      _setPausing: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setPoolRoundMastercopy(
      _poolRoundMastercopy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setRoundLength(
      _roundLength: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setSportAmm(
      _sportAMM: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setStakedThalesMultiplier(
      _stakedThalesMultiplier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setStakingThales(
      _stakingThales: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setWhitelistedAddresses(
      _whitelistedAddresses: PromiseOrValue<string>[],
      _flag: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setWhitelistedStakerAddresses(
      _whitelistedAddresses: PromiseOrValue<string>[],
      _flag: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    sportsAMM(overrides?: CallOverrides): Promise<[string]>;

    stakedThalesMultiplier(overrides?: CallOverrides): Promise<[BigNumber]>;

    stakingThales(overrides?: CallOverrides): Promise<[string]>;

    start(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    started(overrides?: CallOverrides): Promise<[boolean]>;

    totalDeposited(overrides?: CallOverrides): Promise<[BigNumber]>;

    tradingMarketsPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string]>;

    transferOwnershipAtInit(
      proxyAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    transferTokens(
      tokens: PromiseOrValue<string>[],
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      all: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    transferTokensFromLiquidityPool(
      tokens: PromiseOrValue<string>[],
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      all: PromiseOrValue<boolean>,
      pool: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    userInRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    usersCurrentlyInPool(overrides?: CallOverrides): Promise<[BigNumber]>;

    usersPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string]>;

    whitelistedDeposits(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    whitelistedStakers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    withdrawalRequest(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    withdrawalRequested(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
  };

  acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  allocationPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  balancesPerRound(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  canCloseCurrentRound(overrides?: CallOverrides): Promise<boolean>;

  closeRound(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  commitTrade(
    market: PromiseOrValue<string>,
    amountToMint: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  cumulativePnLBetweenRounds(
    roundA: PromiseOrValue<BigNumberish>,
    roundB: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  cumulativeProfitAndLoss(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  defaultLiquidityProvider(overrides?: CallOverrides): Promise<string>;

  deposit(
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  exerciseMarketsReadyToExercised(
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  firstRoundStartTime(overrides?: CallOverrides): Promise<BigNumber>;

  getMarketPool(market: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  getMarketRound(market: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  getMaxAvailableDepositForUser(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      maxDepositForUser: BigNumber;
      availableToDepositForUser: BigNumber;
      stakedThalesForUser: BigNumber;
    }
  >;

  getNeededStakedThalesToWithdrawForUser(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  getOptionsForBuy(
    market: PromiseOrValue<string>,
    optionsAmount: PromiseOrValue<BigNumberish>,
    position: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  getOptionsForBuyByAddress(
    market: PromiseOrValue<string>,
    optionsAmount: PromiseOrValue<BigNumberish>,
    position: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  getOrCreateMarketPool(
    market: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  getRoundEndTime(_round: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  getRoundStartTime(_round: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  hasMarketsReadyToBeExercised(overrides?: CallOverrides): Promise<boolean>;

  initNonReentrant(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  initialize(
    params: SportAMMLiquidityPool.InitParamsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  isTradingMarketInARound(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  isUserLPing(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  marketAlreadyExercisedInRound(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  maxAllowedDeposit(overrides?: CallOverrides): Promise<BigNumber>;

  maxAllowedUsers(overrides?: CallOverrides): Promise<BigNumber>;

  minDepositAmount(overrides?: CallOverrides): Promise<BigNumber>;

  needsTransformingCollateral(overrides?: CallOverrides): Promise<boolean>;

  nominateNewOwner(
    _owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  nominatedOwner(overrides?: CallOverrides): Promise<string>;

  onlyWhitelistedStakersAllowed(overrides?: CallOverrides): Promise<boolean>;

  owner(overrides?: CallOverrides): Promise<string>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  poolRoundMastercopy(overrides?: CallOverrides): Promise<string>;

  profitAndLossPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  round(overrides?: CallOverrides): Promise<BigNumber>;

  roundLength(overrides?: CallOverrides): Promise<BigNumber>;

  roundPools(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  sUSD(overrides?: CallOverrides): Promise<string>;

  setDefaultLiquidityProvider(
    _defaultLiquidityProvider: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setMaxAllowedDeposit(
    _maxAllowedDeposit: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setMaxAllowedUsers(
    _maxAllowedUsers: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setMinAllowedDeposit(
    _minDepositAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setNeedsTransformingCollateral(
    _needsTransformingCollateral: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setOnlyWhitelistedStakersAllowed(
    flagToSet: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setOwner(
    _owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setPaused(
    _setPausing: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setPoolRoundMastercopy(
    _poolRoundMastercopy: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setRoundLength(
    _roundLength: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setSportAmm(
    _sportAMM: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setStakedThalesMultiplier(
    _stakedThalesMultiplier: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setStakingThales(
    _stakingThales: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setWhitelistedAddresses(
    _whitelistedAddresses: PromiseOrValue<string>[],
    _flag: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setWhitelistedStakerAddresses(
    _whitelistedAddresses: PromiseOrValue<string>[],
    _flag: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  sportsAMM(overrides?: CallOverrides): Promise<string>;

  stakedThalesMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

  stakingThales(overrides?: CallOverrides): Promise<string>;

  start(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  started(overrides?: CallOverrides): Promise<boolean>;

  totalDeposited(overrides?: CallOverrides): Promise<BigNumber>;

  tradingMarketsPerRound(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<string>;

  transferOwnershipAtInit(
    proxyAddress: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  transferTokens(
    tokens: PromiseOrValue<string>[],
    account: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    all: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  transferTokensFromLiquidityPool(
    tokens: PromiseOrValue<string>[],
    account: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    all: PromiseOrValue<boolean>,
    pool: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  userInRound(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  usersCurrentlyInPool(overrides?: CallOverrides): Promise<BigNumber>;

  usersPerRound(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<string>;

  whitelistedDeposits(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  whitelistedStakers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  withdrawalRequest(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  withdrawalRequested(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  callStatic: {
    acceptOwnership(overrides?: CallOverrides): Promise<void>;

    allocationPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    balancesPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    canCloseCurrentRound(overrides?: CallOverrides): Promise<boolean>;

    closeRound(overrides?: CallOverrides): Promise<void>;

    commitTrade(
      market: PromiseOrValue<string>,
      amountToMint: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    cumulativePnLBetweenRounds(
      roundA: PromiseOrValue<BigNumberish>,
      roundB: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    cumulativeProfitAndLoss(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    defaultLiquidityProvider(overrides?: CallOverrides): Promise<string>;

    deposit(amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    exerciseMarketsReadyToExercised(overrides?: CallOverrides): Promise<void>;

    firstRoundStartTime(overrides?: CallOverrides): Promise<BigNumber>;

    getMarketPool(market: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    getMarketRound(market: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getMaxAvailableDepositForUser(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        maxDepositForUser: BigNumber;
        availableToDepositForUser: BigNumber;
        stakedThalesForUser: BigNumber;
      }
    >;

    getNeededStakedThalesToWithdrawForUser(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getOptionsForBuy(
      market: PromiseOrValue<string>,
      optionsAmount: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    getOptionsForBuyByAddress(
      market: PromiseOrValue<string>,
      optionsAmount: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    getOrCreateMarketPool(market: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    getRoundEndTime(_round: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getRoundStartTime(_round: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    hasMarketsReadyToBeExercised(overrides?: CallOverrides): Promise<boolean>;

    initNonReentrant(overrides?: CallOverrides): Promise<void>;

    initialize(params: SportAMMLiquidityPool.InitParamsStruct, overrides?: CallOverrides): Promise<void>;

    isTradingMarketInARound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    isUserLPing(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    marketAlreadyExercisedInRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    maxAllowedDeposit(overrides?: CallOverrides): Promise<BigNumber>;

    maxAllowedUsers(overrides?: CallOverrides): Promise<BigNumber>;

    minDepositAmount(overrides?: CallOverrides): Promise<BigNumber>;

    needsTransformingCollateral(overrides?: CallOverrides): Promise<boolean>;

    nominateNewOwner(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    nominatedOwner(overrides?: CallOverrides): Promise<string>;

    onlyWhitelistedStakersAllowed(overrides?: CallOverrides): Promise<boolean>;

    owner(overrides?: CallOverrides): Promise<string>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    poolRoundMastercopy(overrides?: CallOverrides): Promise<string>;

    profitAndLossPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    round(overrides?: CallOverrides): Promise<BigNumber>;

    roundLength(overrides?: CallOverrides): Promise<BigNumber>;

    roundPools(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    sUSD(overrides?: CallOverrides): Promise<string>;

    setDefaultLiquidityProvider(
      _defaultLiquidityProvider: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setMaxAllowedDeposit(_maxAllowedDeposit: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setMaxAllowedUsers(_maxAllowedUsers: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setMinAllowedDeposit(_minDepositAmount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setNeedsTransformingCollateral(
      _needsTransformingCollateral: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setOnlyWhitelistedStakersAllowed(flagToSet: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;

    setOwner(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setPaused(_setPausing: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;

    setPoolRoundMastercopy(_poolRoundMastercopy: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setRoundLength(_roundLength: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setSportAmm(_sportAMM: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setStakedThalesMultiplier(
      _stakedThalesMultiplier: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setStakingThales(_stakingThales: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setWhitelistedAddresses(
      _whitelistedAddresses: PromiseOrValue<string>[],
      _flag: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setWhitelistedStakerAddresses(
      _whitelistedAddresses: PromiseOrValue<string>[],
      _flag: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    sportsAMM(overrides?: CallOverrides): Promise<string>;

    stakedThalesMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

    stakingThales(overrides?: CallOverrides): Promise<string>;

    start(overrides?: CallOverrides): Promise<void>;

    started(overrides?: CallOverrides): Promise<boolean>;

    totalDeposited(overrides?: CallOverrides): Promise<BigNumber>;

    tradingMarketsPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<string>;

    transferOwnershipAtInit(proxyAddress: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    transferTokens(
      tokens: PromiseOrValue<string>[],
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      all: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    transferTokensFromLiquidityPool(
      tokens: PromiseOrValue<string>[],
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      all: PromiseOrValue<boolean>,
      pool: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    userInRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    usersCurrentlyInPool(overrides?: CallOverrides): Promise<BigNumber>;

    usersPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<string>;

    whitelistedDeposits(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    whitelistedStakers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    withdrawalRequest(overrides?: CallOverrides): Promise<void>;

    withdrawalRequested(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
  };

  filters: {
    'AddedIntoWhitelist(address,bool)'(_whitelistAddress?: null, _flag?: null): AddedIntoWhitelistEventFilter;
    AddedIntoWhitelist(_whitelistAddress?: null, _flag?: null): AddedIntoWhitelistEventFilter;

    'AddedIntoWhitelistStaker(address,bool)'(
      _whitelistAddress?: null,
      _flag?: null,
    ): AddedIntoWhitelistStakerEventFilter;
    AddedIntoWhitelistStaker(_whitelistAddress?: null, _flag?: null): AddedIntoWhitelistStakerEventFilter;

    'Claimed(address,uint256)'(user?: null, amount?: null): ClaimedEventFilter;
    Claimed(user?: null, amount?: null): ClaimedEventFilter;

    'DefaultLiquidityProviderChanged(address)'(newProvider?: null): DefaultLiquidityProviderChangedEventFilter;
    DefaultLiquidityProviderChanged(newProvider?: null): DefaultLiquidityProviderChangedEventFilter;

    'Deposited(address,uint256,uint256)'(user?: null, amount?: null, round?: null): DepositedEventFilter;
    Deposited(user?: null, amount?: null, round?: null): DepositedEventFilter;

    'MaxAllowedDepositChanged(uint256)'(maxAllowedDeposit?: null): MaxAllowedDepositChangedEventFilter;
    MaxAllowedDepositChanged(maxAllowedDeposit?: null): MaxAllowedDepositChangedEventFilter;

    'MaxAllowedUsersChanged(uint256)'(MaxAllowedUsersChanged?: null): MaxAllowedUsersChangedEventFilter;
    MaxAllowedUsersChanged(MaxAllowedUsersChanged?: null): MaxAllowedUsersChangedEventFilter;

    'MinAllowedDepositChanged(uint256)'(minAllowedDeposit?: null): MinAllowedDepositChangedEventFilter;
    MinAllowedDepositChanged(minAllowedDeposit?: null): MinAllowedDepositChangedEventFilter;

    'OwnerChanged(address,address)'(oldOwner?: null, newOwner?: null): OwnerChangedEventFilter;
    OwnerChanged(oldOwner?: null, newOwner?: null): OwnerChangedEventFilter;

    'OwnerNominated(address)'(newOwner?: null): OwnerNominatedEventFilter;
    OwnerNominated(newOwner?: null): OwnerNominatedEventFilter;

    'Paused(address)'(account?: null): PausedEventFilter;
    Paused(account?: null): PausedEventFilter;

    'PoolRoundMastercopyChanged(address)'(newMastercopy?: null): PoolRoundMastercopyChangedEventFilter;
    PoolRoundMastercopyChanged(newMastercopy?: null): PoolRoundMastercopyChangedEventFilter;

    'PoolStarted()'(): PoolStartedEventFilter;
    PoolStarted(): PoolStartedEventFilter;

    'RoundClosed(uint256,uint256)'(round?: null, roundPnL?: null): RoundClosedEventFilter;
    RoundClosed(round?: null, roundPnL?: null): RoundClosedEventFilter;

    'RoundLengthChanged(uint256)'(roundLength?: null): RoundLengthChangedEventFilter;
    RoundLengthChanged(roundLength?: null): RoundLengthChangedEventFilter;

    'RoundPoolCreated(uint256,address)'(_round?: null, roundPool?: null): RoundPoolCreatedEventFilter;
    RoundPoolCreated(_round?: null, roundPool?: null): RoundPoolCreatedEventFilter;

    'SportAMMChanged(address)'(sportAMM?: null): SportAMMChangedEventFilter;
    SportAMMChanged(sportAMM?: null): SportAMMChangedEventFilter;

    'StakedThalesMultiplierChanged(uint256)'(_stakedThalesMultiplier?: null): StakedThalesMultiplierChangedEventFilter;
    StakedThalesMultiplierChanged(_stakedThalesMultiplier?: null): StakedThalesMultiplierChangedEventFilter;

    'StakingThalesChanged(address)'(stakingThales?: null): StakingThalesChangedEventFilter;
    StakingThalesChanged(stakingThales?: null): StakingThalesChangedEventFilter;

    'Unpaused(address)'(account?: null): UnpausedEventFilter;
    Unpaused(account?: null): UnpausedEventFilter;

    'WithdrawalRequested(address)'(user?: null): WithdrawalRequestedEventFilter;
    WithdrawalRequested(user?: null): WithdrawalRequestedEventFilter;
  };

  estimateGas: {
    acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    allocationPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    balancesPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    canCloseCurrentRound(overrides?: CallOverrides): Promise<BigNumber>;

    closeRound(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    commitTrade(
      market: PromiseOrValue<string>,
      amountToMint: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    cumulativePnLBetweenRounds(
      roundA: PromiseOrValue<BigNumberish>,
      roundB: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    cumulativeProfitAndLoss(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    defaultLiquidityProvider(overrides?: CallOverrides): Promise<BigNumber>;

    deposit(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    exerciseMarketsReadyToExercised(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    firstRoundStartTime(overrides?: CallOverrides): Promise<BigNumber>;

    getMarketPool(market: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getMarketRound(market: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getMaxAvailableDepositForUser(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getNeededStakedThalesToWithdrawForUser(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getOptionsForBuy(
      market: PromiseOrValue<string>,
      optionsAmount: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    getOptionsForBuyByAddress(
      market: PromiseOrValue<string>,
      optionsAmount: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    getOrCreateMarketPool(
      market: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    getRoundEndTime(_round: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getRoundStartTime(_round: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    hasMarketsReadyToBeExercised(overrides?: CallOverrides): Promise<BigNumber>;

    initNonReentrant(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    initialize(
      params: SportAMMLiquidityPool.InitParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    isTradingMarketInARound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    isUserLPing(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    marketAlreadyExercisedInRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    maxAllowedDeposit(overrides?: CallOverrides): Promise<BigNumber>;

    maxAllowedUsers(overrides?: CallOverrides): Promise<BigNumber>;

    minDepositAmount(overrides?: CallOverrides): Promise<BigNumber>;

    needsTransformingCollateral(overrides?: CallOverrides): Promise<BigNumber>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    nominatedOwner(overrides?: CallOverrides): Promise<BigNumber>;

    onlyWhitelistedStakersAllowed(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    poolRoundMastercopy(overrides?: CallOverrides): Promise<BigNumber>;

    profitAndLossPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    round(overrides?: CallOverrides): Promise<BigNumber>;

    roundLength(overrides?: CallOverrides): Promise<BigNumber>;

    roundPools(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    sUSD(overrides?: CallOverrides): Promise<BigNumber>;

    setDefaultLiquidityProvider(
      _defaultLiquidityProvider: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setMaxAllowedDeposit(
      _maxAllowedDeposit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setMaxAllowedUsers(
      _maxAllowedUsers: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setMinAllowedDeposit(
      _minDepositAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setNeedsTransformingCollateral(
      _needsTransformingCollateral: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setOnlyWhitelistedStakersAllowed(
      flagToSet: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setPaused(
      _setPausing: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setPoolRoundMastercopy(
      _poolRoundMastercopy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setRoundLength(
      _roundLength: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setSportAmm(
      _sportAMM: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setStakedThalesMultiplier(
      _stakedThalesMultiplier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setStakingThales(
      _stakingThales: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setWhitelistedAddresses(
      _whitelistedAddresses: PromiseOrValue<string>[],
      _flag: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setWhitelistedStakerAddresses(
      _whitelistedAddresses: PromiseOrValue<string>[],
      _flag: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    sportsAMM(overrides?: CallOverrides): Promise<BigNumber>;

    stakedThalesMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

    stakingThales(overrides?: CallOverrides): Promise<BigNumber>;

    start(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    started(overrides?: CallOverrides): Promise<BigNumber>;

    totalDeposited(overrides?: CallOverrides): Promise<BigNumber>;

    tradingMarketsPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    transferOwnershipAtInit(
      proxyAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    transferTokens(
      tokens: PromiseOrValue<string>[],
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      all: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    transferTokensFromLiquidityPool(
      tokens: PromiseOrValue<string>[],
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      all: PromiseOrValue<boolean>,
      pool: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    userInRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    usersCurrentlyInPool(overrides?: CallOverrides): Promise<BigNumber>;

    usersPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    whitelistedDeposits(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    whitelistedStakers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    withdrawalRequest(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    withdrawalRequested(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    allocationPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    balancesPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    canCloseCurrentRound(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    closeRound(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    commitTrade(
      market: PromiseOrValue<string>,
      amountToMint: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    cumulativePnLBetweenRounds(
      roundA: PromiseOrValue<BigNumberish>,
      roundB: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    cumulativeProfitAndLoss(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    defaultLiquidityProvider(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    deposit(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    exerciseMarketsReadyToExercised(
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    firstRoundStartTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getMarketPool(market: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getMarketRound(market: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getMaxAvailableDepositForUser(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getNeededStakedThalesToWithdrawForUser(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getOptionsForBuy(
      market: PromiseOrValue<string>,
      optionsAmount: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    getOptionsForBuyByAddress(
      market: PromiseOrValue<string>,
      optionsAmount: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    getOrCreateMarketPool(
      market: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    getRoundEndTime(_round: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getRoundStartTime(_round: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    hasMarketsReadyToBeExercised(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initNonReentrant(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    initialize(
      params: SportAMMLiquidityPool.InitParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    isTradingMarketInARound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    isUserLPing(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    marketAlreadyExercisedInRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    maxAllowedDeposit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    maxAllowedUsers(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minDepositAmount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    needsTransformingCollateral(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    nominatedOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    onlyWhitelistedStakersAllowed(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    poolRoundMastercopy(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    profitAndLossPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    round(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    roundLength(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    roundPools(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    sUSD(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setDefaultLiquidityProvider(
      _defaultLiquidityProvider: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setMaxAllowedDeposit(
      _maxAllowedDeposit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setMaxAllowedUsers(
      _maxAllowedUsers: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setMinAllowedDeposit(
      _minDepositAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setNeedsTransformingCollateral(
      _needsTransformingCollateral: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setOnlyWhitelistedStakersAllowed(
      flagToSet: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setPaused(
      _setPausing: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setPoolRoundMastercopy(
      _poolRoundMastercopy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setRoundLength(
      _roundLength: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setSportAmm(
      _sportAMM: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setStakedThalesMultiplier(
      _stakedThalesMultiplier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setStakingThales(
      _stakingThales: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setWhitelistedAddresses(
      _whitelistedAddresses: PromiseOrValue<string>[],
      _flag: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setWhitelistedStakerAddresses(
      _whitelistedAddresses: PromiseOrValue<string>[],
      _flag: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    sportsAMM(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    stakedThalesMultiplier(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    stakingThales(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    start(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    started(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalDeposited(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tradingMarketsPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    transferOwnershipAtInit(
      proxyAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    transferTokens(
      tokens: PromiseOrValue<string>[],
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      all: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    transferTokensFromLiquidityPool(
      tokens: PromiseOrValue<string>[],
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      all: PromiseOrValue<boolean>,
      pool: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    userInRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    usersCurrentlyInPool(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    usersPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    whitelistedDeposits(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    whitelistedStakers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdrawalRequest(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    withdrawalRequested(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}

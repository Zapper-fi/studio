/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace AmmVault {
  export type InitParamsStruct = {
    _owner: PromiseOrValue<string>;
    _thalesAmm: PromiseOrValue<string>;
    _sUSD: PromiseOrValue<string>;
    _roundLength: PromiseOrValue<BigNumberish>;
    _priceLowerLimit: PromiseOrValue<BigNumberish>;
    _priceUpperLimit: PromiseOrValue<BigNumberish>;
    _skewImpactLimit: PromiseOrValue<BigNumberish>;
    _allocationLimitsPerMarketPerRound: PromiseOrValue<BigNumberish>;
    _maxAllowedDeposit: PromiseOrValue<BigNumberish>;
    _utilizationRate: PromiseOrValue<BigNumberish>;
    _minDepositAmount: PromiseOrValue<BigNumberish>;
    _maxAllowedUsers: PromiseOrValue<BigNumberish>;
    _minTradeAmount: PromiseOrValue<BigNumberish>;
  };

  export type InitParamsStructOutput = [
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    _owner: string;
    _thalesAmm: string;
    _sUSD: string;
    _roundLength: BigNumber;
    _priceLowerLimit: BigNumber;
    _priceUpperLimit: BigNumber;
    _skewImpactLimit: BigNumber;
    _allocationLimitsPerMarketPerRound: BigNumber;
    _maxAllowedDeposit: BigNumber;
    _utilizationRate: BigNumber;
    _minDepositAmount: BigNumber;
    _maxAllowedUsers: BigNumber;
    _minTradeAmount: BigNumber;
  };
}

export interface VaultsInterface extends utils.Interface {
  functions: {
    "acceptOwnership()": FunctionFragment;
    "allocationLimitsPerMarketPerRound()": FunctionFragment;
    "allocationPerRound(uint256)": FunctionFragment;
    "allocationSpentInARound(uint256)": FunctionFragment;
    "allocationSpentPerRound(uint256,address)": FunctionFragment;
    "balancesPerRound(uint256,address)": FunctionFragment;
    "canCloseCurrentRound()": FunctionFragment;
    "capPerRound(uint256)": FunctionFragment;
    "closeRound()": FunctionFragment;
    "cumulativePnLBetweenRounds(uint256,uint256)": FunctionFragment;
    "cumulativeProfitAndLoss(uint256)": FunctionFragment;
    "deposit(uint256)": FunctionFragment;
    "depositReceipts(address)": FunctionFragment;
    "getAvailableAllocationForMarket(address)": FunctionFragment;
    "getAvailableToDeposit()": FunctionFragment;
    "getBalancesPerRound(uint256,address)": FunctionFragment;
    "getCurrentRoundEnd()": FunctionFragment;
    "initNonReentrant()": FunctionFragment;
    "initialize((address,address,address,uint256,uint256,uint256,int256,uint256,uint256,uint256,uint256,uint256,uint256))": FunctionFragment;
    "isTradingMarketInARound(uint256,address)": FunctionFragment;
    "maxAllowedDeposit()": FunctionFragment;
    "maxAllowedUsers()": FunctionFragment;
    "minDepositAmount()": FunctionFragment;
    "minTradeAmount()": FunctionFragment;
    "nominateNewOwner(address)": FunctionFragment;
    "nominatedOwner()": FunctionFragment;
    "owner()": FunctionFragment;
    "paused()": FunctionFragment;
    "priceLowerLimit()": FunctionFragment;
    "priceUpperLimit()": FunctionFragment;
    "profitAndLossPerRound(uint256)": FunctionFragment;
    "round()": FunctionFragment;
    "roundLength()": FunctionFragment;
    "roundStartTime(uint256)": FunctionFragment;
    "sUSD()": FunctionFragment;
    "setAllocationLimits(uint256)": FunctionFragment;
    "setMaxAllowedDeposit(uint256)": FunctionFragment;
    "setMaxAllowedUsers(uint256)": FunctionFragment;
    "setMinAllowedDeposit(uint256)": FunctionFragment;
    "setMinTradeAmount(uint256)": FunctionFragment;
    "setOwner(address)": FunctionFragment;
    "setPriceLimits(uint256,uint256)": FunctionFragment;
    "setRoundLength(uint256)": FunctionFragment;
    "setSkewImpactLimit(int256)": FunctionFragment;
    "setStakingThales(address)": FunctionFragment;
    "setThalesAmm(address)": FunctionFragment;
    "setUtilizationRate(uint256)": FunctionFragment;
    "skewImpactLimit()": FunctionFragment;
    "stakingThales()": FunctionFragment;
    "startVault()": FunctionFragment;
    "thalesAMM()": FunctionFragment;
    "trade(address,uint256,uint8)": FunctionFragment;
    "tradingAllocation()": FunctionFragment;
    "tradingMarketPositionPerRound(uint256,address)": FunctionFragment;
    "tradingMarketsPerRound(uint256,uint256)": FunctionFragment;
    "transferOwnershipAtInit(address)": FunctionFragment;
    "userInRound(uint256,address)": FunctionFragment;
    "usersCurrentlyInVault()": FunctionFragment;
    "usersPerRound(uint256,uint256)": FunctionFragment;
    "utilizationRate()": FunctionFragment;
    "vaultStarted()": FunctionFragment;
    "withdrawalRequest()": FunctionFragment;
    "withdrawalRequested(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "acceptOwnership"
      | "allocationLimitsPerMarketPerRound"
      | "allocationPerRound"
      | "allocationSpentInARound"
      | "allocationSpentPerRound"
      | "balancesPerRound"
      | "canCloseCurrentRound"
      | "capPerRound"
      | "closeRound"
      | "cumulativePnLBetweenRounds"
      | "cumulativeProfitAndLoss"
      | "deposit"
      | "depositReceipts"
      | "getAvailableAllocationForMarket"
      | "getAvailableToDeposit"
      | "getBalancesPerRound"
      | "getCurrentRoundEnd"
      | "initNonReentrant"
      | "initialize"
      | "isTradingMarketInARound"
      | "maxAllowedDeposit"
      | "maxAllowedUsers"
      | "minDepositAmount"
      | "minTradeAmount"
      | "nominateNewOwner"
      | "nominatedOwner"
      | "owner"
      | "paused"
      | "priceLowerLimit"
      | "priceUpperLimit"
      | "profitAndLossPerRound"
      | "round"
      | "roundLength"
      | "roundStartTime"
      | "sUSD"
      | "setAllocationLimits"
      | "setMaxAllowedDeposit"
      | "setMaxAllowedUsers"
      | "setMinAllowedDeposit"
      | "setMinTradeAmount"
      | "setOwner"
      | "setPriceLimits"
      | "setRoundLength"
      | "setSkewImpactLimit"
      | "setStakingThales"
      | "setThalesAmm"
      | "setUtilizationRate"
      | "skewImpactLimit"
      | "stakingThales"
      | "startVault"
      | "thalesAMM"
      | "trade"
      | "tradingAllocation"
      | "tradingMarketPositionPerRound"
      | "tradingMarketsPerRound"
      | "transferOwnershipAtInit"
      | "userInRound"
      | "usersCurrentlyInVault"
      | "usersPerRound"
      | "utilizationRate"
      | "vaultStarted"
      | "withdrawalRequest"
      | "withdrawalRequested"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "acceptOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "allocationLimitsPerMarketPerRound",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "allocationPerRound",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "allocationSpentInARound",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "allocationSpentPerRound",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "balancesPerRound",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "canCloseCurrentRound",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "capPerRound",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "closeRound",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "cumulativePnLBetweenRounds",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "cumulativeProfitAndLoss",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "deposit",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "depositReceipts",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAvailableAllocationForMarket",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAvailableToDeposit",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getBalancesPerRound",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrentRoundEnd",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initNonReentrant",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [AmmVault.InitParamsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "isTradingMarketInARound",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "maxAllowedDeposit",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "maxAllowedUsers",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "minDepositAmount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "minTradeAmount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nominateNewOwner",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "nominatedOwner",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "priceLowerLimit",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "priceUpperLimit",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "profitAndLossPerRound",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "round", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "roundLength",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "roundStartTime",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "sUSD", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setAllocationLimits",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setMaxAllowedDeposit",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setMaxAllowedUsers",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setMinAllowedDeposit",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setMinTradeAmount",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setOwner",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setPriceLimits",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setRoundLength",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setSkewImpactLimit",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setStakingThales",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setThalesAmm",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setUtilizationRate",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "skewImpactLimit",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "stakingThales",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "startVault",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "thalesAMM", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "trade",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "tradingAllocation",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tradingMarketPositionPerRound",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "tradingMarketsPerRound",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnershipAtInit",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "userInRound",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "usersCurrentlyInVault",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "usersPerRound",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "utilizationRate",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "vaultStarted",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawalRequest",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawalRequested",
    values: [PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(
    functionFragment: "acceptOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allocationLimitsPerMarketPerRound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allocationPerRound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allocationSpentInARound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allocationSpentPerRound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "balancesPerRound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "canCloseCurrentRound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "capPerRound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "closeRound", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "cumulativePnLBetweenRounds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cumulativeProfitAndLoss",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "depositReceipts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAvailableAllocationForMarket",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAvailableToDeposit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBalancesPerRound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCurrentRoundEnd",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initNonReentrant",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isTradingMarketInARound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "maxAllowedDeposit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "maxAllowedUsers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "minDepositAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "minTradeAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nominateNewOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nominatedOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "priceLowerLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "priceUpperLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "profitAndLossPerRound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "round", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "roundLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "roundStartTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "sUSD", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setAllocationLimits",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMaxAllowedDeposit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMaxAllowedUsers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMinAllowedDeposit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMinTradeAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setOwner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setPriceLimits",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setRoundLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setSkewImpactLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setStakingThales",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setThalesAmm",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setUtilizationRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "skewImpactLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stakingThales",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "startVault", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "thalesAMM", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "trade", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "tradingAllocation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tradingMarketPositionPerRound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tradingMarketsPerRound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnershipAtInit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "userInRound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "usersCurrentlyInVault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "usersPerRound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "utilizationRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "vaultStarted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawalRequest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawalRequested",
    data: BytesLike
  ): Result;

  events: {
    "Claimed(address,uint256)": EventFragment;
    "Deposited(address,uint256)": EventFragment;
    "MaxAllowedDepositChanged(uint256)": EventFragment;
    "MaxAllowedUsersChanged(uint256)": EventFragment;
    "MinAllowedDepositChanged(uint256)": EventFragment;
    "OwnerChanged(address,address)": EventFragment;
    "OwnerNominated(address)": EventFragment;
    "Paused(address)": EventFragment;
    "RoundClosed(uint256,uint256)": EventFragment;
    "RoundLengthChanged(uint256)": EventFragment;
    "SetAllocationLimits(uint256)": EventFragment;
    "SetMinTradeAmount(uint256)": EventFragment;
    "SetPriceLimits(uint256,uint256)": EventFragment;
    "SetSUSD(address)": EventFragment;
    "SetSkewImpactLimit(int256)": EventFragment;
    "StakingThalesChanged(address)": EventFragment;
    "ThalesAMMChanged(address)": EventFragment;
    "TradeExecuted(address,uint8,uint256,uint256)": EventFragment;
    "Unpaused(address)": EventFragment;
    "UtilizationRateChanged(uint256)": EventFragment;
    "VaultStarted()": EventFragment;
    "WithdrawalRequested(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Claimed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Deposited"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MaxAllowedDepositChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MaxAllowedUsersChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MinAllowedDepositChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnerChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnerNominated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Paused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoundClosed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoundLengthChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetAllocationLimits"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetMinTradeAmount"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetPriceLimits"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetSUSD"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetSkewImpactLimit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakingThalesChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ThalesAMMChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TradeExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unpaused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UtilizationRateChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultStarted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WithdrawalRequested"): EventFragment;
}

export interface ClaimedEventObject {
  user: string;
  amount: BigNumber;
}
export type ClaimedEvent = TypedEvent<[string, BigNumber], ClaimedEventObject>;

export type ClaimedEventFilter = TypedEventFilter<ClaimedEvent>;

export interface DepositedEventObject {
  user: string;
  amount: BigNumber;
}
export type DepositedEvent = TypedEvent<
  [string, BigNumber],
  DepositedEventObject
>;

export type DepositedEventFilter = TypedEventFilter<DepositedEvent>;

export interface MaxAllowedDepositChangedEventObject {
  maxAllowedDeposit: BigNumber;
}
export type MaxAllowedDepositChangedEvent = TypedEvent<
  [BigNumber],
  MaxAllowedDepositChangedEventObject
>;

export type MaxAllowedDepositChangedEventFilter =
  TypedEventFilter<MaxAllowedDepositChangedEvent>;

export interface MaxAllowedUsersChangedEventObject {
  MaxAllowedUsersChanged: BigNumber;
}
export type MaxAllowedUsersChangedEvent = TypedEvent<
  [BigNumber],
  MaxAllowedUsersChangedEventObject
>;

export type MaxAllowedUsersChangedEventFilter =
  TypedEventFilter<MaxAllowedUsersChangedEvent>;

export interface MinAllowedDepositChangedEventObject {
  minAllowedDeposit: BigNumber;
}
export type MinAllowedDepositChangedEvent = TypedEvent<
  [BigNumber],
  MinAllowedDepositChangedEventObject
>;

export type MinAllowedDepositChangedEventFilter =
  TypedEventFilter<MinAllowedDepositChangedEvent>;

export interface OwnerChangedEventObject {
  oldOwner: string;
  newOwner: string;
}
export type OwnerChangedEvent = TypedEvent<
  [string, string],
  OwnerChangedEventObject
>;

export type OwnerChangedEventFilter = TypedEventFilter<OwnerChangedEvent>;

export interface OwnerNominatedEventObject {
  newOwner: string;
}
export type OwnerNominatedEvent = TypedEvent<
  [string],
  OwnerNominatedEventObject
>;

export type OwnerNominatedEventFilter = TypedEventFilter<OwnerNominatedEvent>;

export interface PausedEventObject {
  account: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface RoundClosedEventObject {
  round: BigNumber;
  roundPnL: BigNumber;
}
export type RoundClosedEvent = TypedEvent<
  [BigNumber, BigNumber],
  RoundClosedEventObject
>;

export type RoundClosedEventFilter = TypedEventFilter<RoundClosedEvent>;

export interface RoundLengthChangedEventObject {
  roundLength: BigNumber;
}
export type RoundLengthChangedEvent = TypedEvent<
  [BigNumber],
  RoundLengthChangedEventObject
>;

export type RoundLengthChangedEventFilter =
  TypedEventFilter<RoundLengthChangedEvent>;

export interface SetAllocationLimitsEventObject {
  allocationLimitsPerMarketPerRound: BigNumber;
}
export type SetAllocationLimitsEvent = TypedEvent<
  [BigNumber],
  SetAllocationLimitsEventObject
>;

export type SetAllocationLimitsEventFilter =
  TypedEventFilter<SetAllocationLimitsEvent>;

export interface SetMinTradeAmountEventObject {
  SetMinTradeAmount: BigNumber;
}
export type SetMinTradeAmountEvent = TypedEvent<
  [BigNumber],
  SetMinTradeAmountEventObject
>;

export type SetMinTradeAmountEventFilter =
  TypedEventFilter<SetMinTradeAmountEvent>;

export interface SetPriceLimitsEventObject {
  priceLowerLimit: BigNumber;
  priceUpperLimit: BigNumber;
}
export type SetPriceLimitsEvent = TypedEvent<
  [BigNumber, BigNumber],
  SetPriceLimitsEventObject
>;

export type SetPriceLimitsEventFilter = TypedEventFilter<SetPriceLimitsEvent>;

export interface SetSUSDEventObject {
  sUSD: string;
}
export type SetSUSDEvent = TypedEvent<[string], SetSUSDEventObject>;

export type SetSUSDEventFilter = TypedEventFilter<SetSUSDEvent>;

export interface SetSkewImpactLimitEventObject {
  skewImpact: BigNumber;
}
export type SetSkewImpactLimitEvent = TypedEvent<
  [BigNumber],
  SetSkewImpactLimitEventObject
>;

export type SetSkewImpactLimitEventFilter =
  TypedEventFilter<SetSkewImpactLimitEvent>;

export interface StakingThalesChangedEventObject {
  stakingThales: string;
}
export type StakingThalesChangedEvent = TypedEvent<
  [string],
  StakingThalesChangedEventObject
>;

export type StakingThalesChangedEventFilter =
  TypedEventFilter<StakingThalesChangedEvent>;

export interface ThalesAMMChangedEventObject {
  thalesAmm: string;
}
export type ThalesAMMChangedEvent = TypedEvent<
  [string],
  ThalesAMMChangedEventObject
>;

export type ThalesAMMChangedEventFilter =
  TypedEventFilter<ThalesAMMChangedEvent>;

export interface TradeExecutedEventObject {
  market: string;
  position: number;
  amount: BigNumber;
  quote: BigNumber;
}
export type TradeExecutedEvent = TypedEvent<
  [string, number, BigNumber, BigNumber],
  TradeExecutedEventObject
>;

export type TradeExecutedEventFilter = TypedEventFilter<TradeExecutedEvent>;

export interface UnpausedEventObject {
  account: string;
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface UtilizationRateChangedEventObject {
  utilizationRate: BigNumber;
}
export type UtilizationRateChangedEvent = TypedEvent<
  [BigNumber],
  UtilizationRateChangedEventObject
>;

export type UtilizationRateChangedEventFilter =
  TypedEventFilter<UtilizationRateChangedEvent>;

export interface VaultStartedEventObject {}
export type VaultStartedEvent = TypedEvent<[], VaultStartedEventObject>;

export type VaultStartedEventFilter = TypedEventFilter<VaultStartedEvent>;

export interface WithdrawalRequestedEventObject {
  user: string;
}
export type WithdrawalRequestedEvent = TypedEvent<
  [string],
  WithdrawalRequestedEventObject
>;

export type WithdrawalRequestedEventFilter =
  TypedEventFilter<WithdrawalRequestedEvent>;

export interface Vaults extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: VaultsInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    acceptOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    allocationLimitsPerMarketPerRound(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    allocationPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    allocationSpentInARound(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    allocationSpentPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    balancesPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    canCloseCurrentRound(overrides?: CallOverrides): Promise<[boolean]>;

    capPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    closeRound(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    cumulativePnLBetweenRounds(
      roundA: PromiseOrValue<BigNumberish>,
      roundB: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    cumulativeProfitAndLoss(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    deposit(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    depositReceipts(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { round: BigNumber; amount: BigNumber }
    >;

    getAvailableAllocationForMarket(
      market: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getAvailableToDeposit(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { returned: BigNumber }>;

    getBalancesPerRound(
      _round: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getCurrentRoundEnd(overrides?: CallOverrides): Promise<[BigNumber]>;

    initNonReentrant(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    initialize(
      params: AmmVault.InitParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isTradingMarketInARound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    maxAllowedDeposit(overrides?: CallOverrides): Promise<[BigNumber]>;

    maxAllowedUsers(overrides?: CallOverrides): Promise<[BigNumber]>;

    minDepositAmount(overrides?: CallOverrides): Promise<[BigNumber]>;

    minTradeAmount(overrides?: CallOverrides): Promise<[BigNumber]>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    nominatedOwner(overrides?: CallOverrides): Promise<[string]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    priceLowerLimit(overrides?: CallOverrides): Promise<[BigNumber]>;

    priceUpperLimit(overrides?: CallOverrides): Promise<[BigNumber]>;

    profitAndLossPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    round(overrides?: CallOverrides): Promise<[BigNumber]>;

    roundLength(overrides?: CallOverrides): Promise<[BigNumber]>;

    roundStartTime(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    sUSD(overrides?: CallOverrides): Promise<[string]>;

    setAllocationLimits(
      _allocationLimitsPerMarketPerRound: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMaxAllowedDeposit(
      _maxAllowedDeposit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMaxAllowedUsers(
      _maxAllowedUsers: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMinAllowedDeposit(
      _minDepositAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMinTradeAmount(
      _minTradeAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPriceLimits(
      _priceLowerLimit: PromiseOrValue<BigNumberish>,
      _priceUpperLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setRoundLength(
      _roundLength: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setSkewImpactLimit(
      _skewImpactLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setStakingThales(
      _stakingThales: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setThalesAmm(
      _thalesAMM: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setUtilizationRate(
      _utilizationRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    skewImpactLimit(overrides?: CallOverrides): Promise<[BigNumber]>;

    stakingThales(overrides?: CallOverrides): Promise<[string]>;

    startVault(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    thalesAMM(overrides?: CallOverrides): Promise<[string]>;

    trade(
      market: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    tradingAllocation(overrides?: CallOverrides): Promise<[BigNumber]>;

    tradingMarketPositionPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[number]>;

    tradingMarketsPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    transferOwnershipAtInit(
      proxyAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    userInRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    usersCurrentlyInVault(overrides?: CallOverrides): Promise<[BigNumber]>;

    usersPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    utilizationRate(overrides?: CallOverrides): Promise<[BigNumber]>;

    vaultStarted(overrides?: CallOverrides): Promise<[boolean]>;

    withdrawalRequest(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawalRequested(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;
  };

  acceptOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  allocationLimitsPerMarketPerRound(
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  allocationPerRound(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  allocationSpentInARound(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  allocationSpentPerRound(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  balancesPerRound(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  canCloseCurrentRound(overrides?: CallOverrides): Promise<boolean>;

  capPerRound(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  closeRound(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  cumulativePnLBetweenRounds(
    roundA: PromiseOrValue<BigNumberish>,
    roundB: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  cumulativeProfitAndLoss(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  deposit(
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  depositReceipts(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber] & { round: BigNumber; amount: BigNumber }>;

  getAvailableAllocationForMarket(
    market: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getAvailableToDeposit(overrides?: CallOverrides): Promise<BigNumber>;

  getBalancesPerRound(
    _round: PromiseOrValue<BigNumberish>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getCurrentRoundEnd(overrides?: CallOverrides): Promise<BigNumber>;

  initNonReentrant(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  initialize(
    params: AmmVault.InitParamsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isTradingMarketInARound(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  maxAllowedDeposit(overrides?: CallOverrides): Promise<BigNumber>;

  maxAllowedUsers(overrides?: CallOverrides): Promise<BigNumber>;

  minDepositAmount(overrides?: CallOverrides): Promise<BigNumber>;

  minTradeAmount(overrides?: CallOverrides): Promise<BigNumber>;

  nominateNewOwner(
    _owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  nominatedOwner(overrides?: CallOverrides): Promise<string>;

  owner(overrides?: CallOverrides): Promise<string>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  priceLowerLimit(overrides?: CallOverrides): Promise<BigNumber>;

  priceUpperLimit(overrides?: CallOverrides): Promise<BigNumber>;

  profitAndLossPerRound(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  round(overrides?: CallOverrides): Promise<BigNumber>;

  roundLength(overrides?: CallOverrides): Promise<BigNumber>;

  roundStartTime(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  sUSD(overrides?: CallOverrides): Promise<string>;

  setAllocationLimits(
    _allocationLimitsPerMarketPerRound: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMaxAllowedDeposit(
    _maxAllowedDeposit: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMaxAllowedUsers(
    _maxAllowedUsers: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMinAllowedDeposit(
    _minDepositAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMinTradeAmount(
    _minTradeAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOwner(
    _owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPriceLimits(
    _priceLowerLimit: PromiseOrValue<BigNumberish>,
    _priceUpperLimit: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setRoundLength(
    _roundLength: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setSkewImpactLimit(
    _skewImpactLimit: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setStakingThales(
    _stakingThales: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setThalesAmm(
    _thalesAMM: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setUtilizationRate(
    _utilizationRate: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  skewImpactLimit(overrides?: CallOverrides): Promise<BigNumber>;

  stakingThales(overrides?: CallOverrides): Promise<string>;

  startVault(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  thalesAMM(overrides?: CallOverrides): Promise<string>;

  trade(
    market: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    position: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  tradingAllocation(overrides?: CallOverrides): Promise<BigNumber>;

  tradingMarketPositionPerRound(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<number>;

  tradingMarketsPerRound(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  transferOwnershipAtInit(
    proxyAddress: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  userInRound(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  usersCurrentlyInVault(overrides?: CallOverrides): Promise<BigNumber>;

  usersPerRound(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  utilizationRate(overrides?: CallOverrides): Promise<BigNumber>;

  vaultStarted(overrides?: CallOverrides): Promise<boolean>;

  withdrawalRequest(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawalRequested(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  callStatic: {
    acceptOwnership(overrides?: CallOverrides): Promise<void>;

    allocationLimitsPerMarketPerRound(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    allocationPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    allocationSpentInARound(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    allocationSpentPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    balancesPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    canCloseCurrentRound(overrides?: CallOverrides): Promise<boolean>;

    capPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    closeRound(overrides?: CallOverrides): Promise<void>;

    cumulativePnLBetweenRounds(
      roundA: PromiseOrValue<BigNumberish>,
      roundB: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cumulativeProfitAndLoss(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    deposit(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    depositReceipts(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { round: BigNumber; amount: BigNumber }
    >;

    getAvailableAllocationForMarket(
      market: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAvailableToDeposit(overrides?: CallOverrides): Promise<BigNumber>;

    getBalancesPerRound(
      _round: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCurrentRoundEnd(overrides?: CallOverrides): Promise<BigNumber>;

    initNonReentrant(overrides?: CallOverrides): Promise<void>;

    initialize(
      params: AmmVault.InitParamsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    isTradingMarketInARound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    maxAllowedDeposit(overrides?: CallOverrides): Promise<BigNumber>;

    maxAllowedUsers(overrides?: CallOverrides): Promise<BigNumber>;

    minDepositAmount(overrides?: CallOverrides): Promise<BigNumber>;

    minTradeAmount(overrides?: CallOverrides): Promise<BigNumber>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    nominatedOwner(overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    priceLowerLimit(overrides?: CallOverrides): Promise<BigNumber>;

    priceUpperLimit(overrides?: CallOverrides): Promise<BigNumber>;

    profitAndLossPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    round(overrides?: CallOverrides): Promise<BigNumber>;

    roundLength(overrides?: CallOverrides): Promise<BigNumber>;

    roundStartTime(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    sUSD(overrides?: CallOverrides): Promise<string>;

    setAllocationLimits(
      _allocationLimitsPerMarketPerRound: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMaxAllowedDeposit(
      _maxAllowedDeposit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMaxAllowedUsers(
      _maxAllowedUsers: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMinAllowedDeposit(
      _minDepositAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMinTradeAmount(
      _minTradeAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOwner(
      _owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPriceLimits(
      _priceLowerLimit: PromiseOrValue<BigNumberish>,
      _priceUpperLimit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setRoundLength(
      _roundLength: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setSkewImpactLimit(
      _skewImpactLimit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setStakingThales(
      _stakingThales: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setThalesAmm(
      _thalesAMM: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setUtilizationRate(
      _utilizationRate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    skewImpactLimit(overrides?: CallOverrides): Promise<BigNumber>;

    stakingThales(overrides?: CallOverrides): Promise<string>;

    startVault(overrides?: CallOverrides): Promise<void>;

    thalesAMM(overrides?: CallOverrides): Promise<string>;

    trade(
      market: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    tradingAllocation(overrides?: CallOverrides): Promise<BigNumber>;

    tradingMarketPositionPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<number>;

    tradingMarketsPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    transferOwnershipAtInit(
      proxyAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    userInRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    usersCurrentlyInVault(overrides?: CallOverrides): Promise<BigNumber>;

    usersPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    utilizationRate(overrides?: CallOverrides): Promise<BigNumber>;

    vaultStarted(overrides?: CallOverrides): Promise<boolean>;

    withdrawalRequest(overrides?: CallOverrides): Promise<void>;

    withdrawalRequested(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {
    "Claimed(address,uint256)"(user?: null, amount?: null): ClaimedEventFilter;
    Claimed(user?: null, amount?: null): ClaimedEventFilter;

    "Deposited(address,uint256)"(
      user?: null,
      amount?: null
    ): DepositedEventFilter;
    Deposited(user?: null, amount?: null): DepositedEventFilter;

    "MaxAllowedDepositChanged(uint256)"(
      maxAllowedDeposit?: null
    ): MaxAllowedDepositChangedEventFilter;
    MaxAllowedDepositChanged(
      maxAllowedDeposit?: null
    ): MaxAllowedDepositChangedEventFilter;

    "MaxAllowedUsersChanged(uint256)"(
      MaxAllowedUsersChanged?: null
    ): MaxAllowedUsersChangedEventFilter;
    MaxAllowedUsersChanged(
      MaxAllowedUsersChanged?: null
    ): MaxAllowedUsersChangedEventFilter;

    "MinAllowedDepositChanged(uint256)"(
      minAllowedDeposit?: null
    ): MinAllowedDepositChangedEventFilter;
    MinAllowedDepositChanged(
      minAllowedDeposit?: null
    ): MinAllowedDepositChangedEventFilter;

    "OwnerChanged(address,address)"(
      oldOwner?: null,
      newOwner?: null
    ): OwnerChangedEventFilter;
    OwnerChanged(oldOwner?: null, newOwner?: null): OwnerChangedEventFilter;

    "OwnerNominated(address)"(newOwner?: null): OwnerNominatedEventFilter;
    OwnerNominated(newOwner?: null): OwnerNominatedEventFilter;

    "Paused(address)"(account?: null): PausedEventFilter;
    Paused(account?: null): PausedEventFilter;

    "RoundClosed(uint256,uint256)"(
      round?: null,
      roundPnL?: null
    ): RoundClosedEventFilter;
    RoundClosed(round?: null, roundPnL?: null): RoundClosedEventFilter;

    "RoundLengthChanged(uint256)"(
      roundLength?: null
    ): RoundLengthChangedEventFilter;
    RoundLengthChanged(roundLength?: null): RoundLengthChangedEventFilter;

    "SetAllocationLimits(uint256)"(
      allocationLimitsPerMarketPerRound?: null
    ): SetAllocationLimitsEventFilter;
    SetAllocationLimits(
      allocationLimitsPerMarketPerRound?: null
    ): SetAllocationLimitsEventFilter;

    "SetMinTradeAmount(uint256)"(
      SetMinTradeAmount?: null
    ): SetMinTradeAmountEventFilter;
    SetMinTradeAmount(SetMinTradeAmount?: null): SetMinTradeAmountEventFilter;

    "SetPriceLimits(uint256,uint256)"(
      priceLowerLimit?: null,
      priceUpperLimit?: null
    ): SetPriceLimitsEventFilter;
    SetPriceLimits(
      priceLowerLimit?: null,
      priceUpperLimit?: null
    ): SetPriceLimitsEventFilter;

    "SetSUSD(address)"(sUSD?: null): SetSUSDEventFilter;
    SetSUSD(sUSD?: null): SetSUSDEventFilter;

    "SetSkewImpactLimit(int256)"(
      skewImpact?: null
    ): SetSkewImpactLimitEventFilter;
    SetSkewImpactLimit(skewImpact?: null): SetSkewImpactLimitEventFilter;

    "StakingThalesChanged(address)"(
      stakingThales?: null
    ): StakingThalesChangedEventFilter;
    StakingThalesChanged(stakingThales?: null): StakingThalesChangedEventFilter;

    "ThalesAMMChanged(address)"(thalesAmm?: null): ThalesAMMChangedEventFilter;
    ThalesAMMChanged(thalesAmm?: null): ThalesAMMChangedEventFilter;

    "TradeExecuted(address,uint8,uint256,uint256)"(
      market?: null,
      position?: null,
      amount?: null,
      quote?: null
    ): TradeExecutedEventFilter;
    TradeExecuted(
      market?: null,
      position?: null,
      amount?: null,
      quote?: null
    ): TradeExecutedEventFilter;

    "Unpaused(address)"(account?: null): UnpausedEventFilter;
    Unpaused(account?: null): UnpausedEventFilter;

    "UtilizationRateChanged(uint256)"(
      utilizationRate?: null
    ): UtilizationRateChangedEventFilter;
    UtilizationRateChanged(
      utilizationRate?: null
    ): UtilizationRateChangedEventFilter;

    "VaultStarted()"(): VaultStartedEventFilter;
    VaultStarted(): VaultStartedEventFilter;

    "WithdrawalRequested(address)"(user?: null): WithdrawalRequestedEventFilter;
    WithdrawalRequested(user?: null): WithdrawalRequestedEventFilter;
  };

  estimateGas: {
    acceptOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    allocationLimitsPerMarketPerRound(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    allocationPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    allocationSpentInARound(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    allocationSpentPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    balancesPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    canCloseCurrentRound(overrides?: CallOverrides): Promise<BigNumber>;

    capPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    closeRound(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    cumulativePnLBetweenRounds(
      roundA: PromiseOrValue<BigNumberish>,
      roundB: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cumulativeProfitAndLoss(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    deposit(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    depositReceipts(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAvailableAllocationForMarket(
      market: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAvailableToDeposit(overrides?: CallOverrides): Promise<BigNumber>;

    getBalancesPerRound(
      _round: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCurrentRoundEnd(overrides?: CallOverrides): Promise<BigNumber>;

    initNonReentrant(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    initialize(
      params: AmmVault.InitParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isTradingMarketInARound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    maxAllowedDeposit(overrides?: CallOverrides): Promise<BigNumber>;

    maxAllowedUsers(overrides?: CallOverrides): Promise<BigNumber>;

    minDepositAmount(overrides?: CallOverrides): Promise<BigNumber>;

    minTradeAmount(overrides?: CallOverrides): Promise<BigNumber>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    nominatedOwner(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    priceLowerLimit(overrides?: CallOverrides): Promise<BigNumber>;

    priceUpperLimit(overrides?: CallOverrides): Promise<BigNumber>;

    profitAndLossPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    round(overrides?: CallOverrides): Promise<BigNumber>;

    roundLength(overrides?: CallOverrides): Promise<BigNumber>;

    roundStartTime(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    sUSD(overrides?: CallOverrides): Promise<BigNumber>;

    setAllocationLimits(
      _allocationLimitsPerMarketPerRound: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMaxAllowedDeposit(
      _maxAllowedDeposit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMaxAllowedUsers(
      _maxAllowedUsers: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMinAllowedDeposit(
      _minDepositAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMinTradeAmount(
      _minTradeAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPriceLimits(
      _priceLowerLimit: PromiseOrValue<BigNumberish>,
      _priceUpperLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setRoundLength(
      _roundLength: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setSkewImpactLimit(
      _skewImpactLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setStakingThales(
      _stakingThales: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setThalesAmm(
      _thalesAMM: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setUtilizationRate(
      _utilizationRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    skewImpactLimit(overrides?: CallOverrides): Promise<BigNumber>;

    stakingThales(overrides?: CallOverrides): Promise<BigNumber>;

    startVault(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    thalesAMM(overrides?: CallOverrides): Promise<BigNumber>;

    trade(
      market: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    tradingAllocation(overrides?: CallOverrides): Promise<BigNumber>;

    tradingMarketPositionPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tradingMarketsPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferOwnershipAtInit(
      proxyAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    userInRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    usersCurrentlyInVault(overrides?: CallOverrides): Promise<BigNumber>;

    usersPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    utilizationRate(overrides?: CallOverrides): Promise<BigNumber>;

    vaultStarted(overrides?: CallOverrides): Promise<BigNumber>;

    withdrawalRequest(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawalRequested(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    acceptOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    allocationLimitsPerMarketPerRound(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    allocationPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    allocationSpentInARound(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    allocationSpentPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    balancesPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    canCloseCurrentRound(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    capPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    closeRound(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    cumulativePnLBetweenRounds(
      roundA: PromiseOrValue<BigNumberish>,
      roundB: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    cumulativeProfitAndLoss(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    deposit(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    depositReceipts(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAvailableAllocationForMarket(
      market: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAvailableToDeposit(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBalancesPerRound(
      _round: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCurrentRoundEnd(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initNonReentrant(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    initialize(
      params: AmmVault.InitParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isTradingMarketInARound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    maxAllowedDeposit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    maxAllowedUsers(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minDepositAmount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minTradeAmount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    nominatedOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    priceLowerLimit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    priceUpperLimit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    profitAndLossPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    round(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    roundLength(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    roundStartTime(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    sUSD(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setAllocationLimits(
      _allocationLimitsPerMarketPerRound: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMaxAllowedDeposit(
      _maxAllowedDeposit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMaxAllowedUsers(
      _maxAllowedUsers: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMinAllowedDeposit(
      _minDepositAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMinTradeAmount(
      _minTradeAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPriceLimits(
      _priceLowerLimit: PromiseOrValue<BigNumberish>,
      _priceUpperLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setRoundLength(
      _roundLength: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setSkewImpactLimit(
      _skewImpactLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setStakingThales(
      _stakingThales: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setThalesAmm(
      _thalesAMM: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setUtilizationRate(
      _utilizationRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    skewImpactLimit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    stakingThales(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    startVault(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    thalesAMM(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    trade(
      market: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    tradingAllocation(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tradingMarketPositionPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tradingMarketsPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    transferOwnershipAtInit(
      proxyAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    userInRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    usersCurrentlyInVault(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    usersPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    utilizationRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    vaultStarted(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdrawalRequest(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawalRequested(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export declare namespace AmmVault {
  export type InitParamsStruct = {
    _owner: PromiseOrValue<string>;
    _thalesAmm: PromiseOrValue<string>;
    _sUSD: PromiseOrValue<string>;
    _roundLength: PromiseOrValue<BigNumberish>;
    _priceLowerLimit: PromiseOrValue<BigNumberish>;
    _priceUpperLimit: PromiseOrValue<BigNumberish>;
    _skewImpactLimit: PromiseOrValue<BigNumberish>;
    _allocationLimitsPerMarketPerRound: PromiseOrValue<BigNumberish>;
    _maxAllowedDeposit: PromiseOrValue<BigNumberish>;
    _utilizationRate: PromiseOrValue<BigNumberish>;
    _minDepositAmount: PromiseOrValue<BigNumberish>;
    _maxAllowedUsers: PromiseOrValue<BigNumberish>;
    _minTradeAmount: PromiseOrValue<BigNumberish>;
  };

  export type InitParamsStructOutput = [
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
  ] & {
    _owner: string;
    _thalesAmm: string;
    _sUSD: string;
    _roundLength: BigNumber;
    _priceLowerLimit: BigNumber;
    _priceUpperLimit: BigNumber;
    _skewImpactLimit: BigNumber;
    _allocationLimitsPerMarketPerRound: BigNumber;
    _maxAllowedDeposit: BigNumber;
    _utilizationRate: BigNumber;
    _minDepositAmount: BigNumber;
    _maxAllowedUsers: BigNumber;
    _minTradeAmount: BigNumber;
  };
}

export interface VaultsInterface extends utils.Interface {
  functions: {
    'acceptOwnership()': FunctionFragment;
    'allocationLimitsPerMarketPerRound()': FunctionFragment;
    'allocationPerRound(uint256)': FunctionFragment;
    'allocationSpentInARound(uint256)': FunctionFragment;
    'allocationSpentPerRound(uint256,address)': FunctionFragment;
    'balancesPerRound(uint256,address)': FunctionFragment;
    'canCloseCurrentRound()': FunctionFragment;
    'capPerRound(uint256)': FunctionFragment;
    'closeRound()': FunctionFragment;
    'cumulativePnLBetweenRounds(uint256,uint256)': FunctionFragment;
    'cumulativeProfitAndLoss(uint256)': FunctionFragment;
    'deposit(uint256)': FunctionFragment;
    'depositReceipts(address)': FunctionFragment;
    'getAvailableAllocationForMarket(address)': FunctionFragment;
    'getAvailableToDeposit()': FunctionFragment;
    'getBalancesPerRound(uint256,address)': FunctionFragment;
    'getCurrentRoundEnd()': FunctionFragment;
    'initNonReentrant()': FunctionFragment;
    'initialize((address,address,address,uint256,uint256,uint256,int256,uint256,uint256,uint256,uint256,uint256,uint256))': FunctionFragment;
    'isTradingMarketInARound(uint256,address)': FunctionFragment;
    'maxAllowedDeposit()': FunctionFragment;
    'maxAllowedUsers()': FunctionFragment;
    'minDepositAmount()': FunctionFragment;
    'minTradeAmount()': FunctionFragment;
    'nominateNewOwner(address)': FunctionFragment;
    'nominatedOwner()': FunctionFragment;
    'owner()': FunctionFragment;
    'paused()': FunctionFragment;
    'priceLowerLimit()': FunctionFragment;
    'priceUpperLimit()': FunctionFragment;
    'profitAndLossPerRound(uint256)': FunctionFragment;
    'round()': FunctionFragment;
    'roundLength()': FunctionFragment;
    'roundStartTime(uint256)': FunctionFragment;
    'sUSD()': FunctionFragment;
    'setAllocationLimits(uint256)': FunctionFragment;
    'setMaxAllowedDeposit(uint256)': FunctionFragment;
    'setMaxAllowedUsers(uint256)': FunctionFragment;
    'setMinAllowedDeposit(uint256)': FunctionFragment;
    'setMinTradeAmount(uint256)': FunctionFragment;
    'setOwner(address)': FunctionFragment;
    'setPriceLimits(uint256,uint256)': FunctionFragment;
    'setRoundLength(uint256)': FunctionFragment;
    'setSkewImpactLimit(int256)': FunctionFragment;
    'setStakingThales(address)': FunctionFragment;
    'setThalesAmm(address)': FunctionFragment;
    'setUtilizationRate(uint256)': FunctionFragment;
    'skewImpactLimit()': FunctionFragment;
    'stakingThales()': FunctionFragment;
    'startVault()': FunctionFragment;
    'thalesAMM()': FunctionFragment;
    'trade(address,uint256,uint8)': FunctionFragment;
    'tradingAllocation()': FunctionFragment;
    'tradingMarketPositionPerRound(uint256,address)': FunctionFragment;
    'tradingMarketsPerRound(uint256,uint256)': FunctionFragment;
    'transferOwnershipAtInit(address)': FunctionFragment;
    'userInRound(uint256,address)': FunctionFragment;
    'usersCurrentlyInVault()': FunctionFragment;
    'usersPerRound(uint256,uint256)': FunctionFragment;
    'utilizationRate()': FunctionFragment;
    'vaultStarted()': FunctionFragment;
    'withdrawalRequest()': FunctionFragment;
    'withdrawalRequested(address)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'acceptOwnership'
      | 'allocationLimitsPerMarketPerRound'
      | 'allocationPerRound'
      | 'allocationSpentInARound'
      | 'allocationSpentPerRound'
      | 'balancesPerRound'
      | 'canCloseCurrentRound'
      | 'capPerRound'
      | 'closeRound'
      | 'cumulativePnLBetweenRounds'
      | 'cumulativeProfitAndLoss'
      | 'deposit'
      | 'depositReceipts'
      | 'getAvailableAllocationForMarket'
      | 'getAvailableToDeposit'
      | 'getBalancesPerRound'
      | 'getCurrentRoundEnd'
      | 'initNonReentrant'
      | 'initialize'
      | 'isTradingMarketInARound'
      | 'maxAllowedDeposit'
      | 'maxAllowedUsers'
      | 'minDepositAmount'
      | 'minTradeAmount'
      | 'nominateNewOwner'
      | 'nominatedOwner'
      | 'owner'
      | 'paused'
      | 'priceLowerLimit'
      | 'priceUpperLimit'
      | 'profitAndLossPerRound'
      | 'round'
      | 'roundLength'
      | 'roundStartTime'
      | 'sUSD'
      | 'setAllocationLimits'
      | 'setMaxAllowedDeposit'
      | 'setMaxAllowedUsers'
      | 'setMinAllowedDeposit'
      | 'setMinTradeAmount'
      | 'setOwner'
      | 'setPriceLimits'
      | 'setRoundLength'
      | 'setSkewImpactLimit'
      | 'setStakingThales'
      | 'setThalesAmm'
      | 'setUtilizationRate'
      | 'skewImpactLimit'
      | 'stakingThales'
      | 'startVault'
      | 'thalesAMM'
      | 'trade'
      | 'tradingAllocation'
      | 'tradingMarketPositionPerRound'
      | 'tradingMarketsPerRound'
      | 'transferOwnershipAtInit'
      | 'userInRound'
      | 'usersCurrentlyInVault'
      | 'usersPerRound'
      | 'utilizationRate'
      | 'vaultStarted'
      | 'withdrawalRequest'
      | 'withdrawalRequested',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'acceptOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'allocationLimitsPerMarketPerRound', values?: undefined): string;
  encodeFunctionData(functionFragment: 'allocationPerRound', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'allocationSpentInARound', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'allocationSpentPerRound',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'balancesPerRound',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'canCloseCurrentRound', values?: undefined): string;
  encodeFunctionData(functionFragment: 'capPerRound', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'closeRound', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'cumulativePnLBetweenRounds',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'cumulativeProfitAndLoss', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'deposit', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'depositReceipts', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getAvailableAllocationForMarket', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getAvailableToDeposit', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'getBalancesPerRound',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'getCurrentRoundEnd', values?: undefined): string;
  encodeFunctionData(functionFragment: 'initNonReentrant', values?: undefined): string;
  encodeFunctionData(functionFragment: 'initialize', values: [AmmVault.InitParamsStruct]): string;
  encodeFunctionData(
    functionFragment: 'isTradingMarketInARound',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'maxAllowedDeposit', values?: undefined): string;
  encodeFunctionData(functionFragment: 'maxAllowedUsers', values?: undefined): string;
  encodeFunctionData(functionFragment: 'minDepositAmount', values?: undefined): string;
  encodeFunctionData(functionFragment: 'minTradeAmount', values?: undefined): string;
  encodeFunctionData(functionFragment: 'nominateNewOwner', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'nominatedOwner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'paused', values?: undefined): string;
  encodeFunctionData(functionFragment: 'priceLowerLimit', values?: undefined): string;
  encodeFunctionData(functionFragment: 'priceUpperLimit', values?: undefined): string;
  encodeFunctionData(functionFragment: 'profitAndLossPerRound', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'round', values?: undefined): string;
  encodeFunctionData(functionFragment: 'roundLength', values?: undefined): string;
  encodeFunctionData(functionFragment: 'roundStartTime', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'sUSD', values?: undefined): string;
  encodeFunctionData(functionFragment: 'setAllocationLimits', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setMaxAllowedDeposit', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setMaxAllowedUsers', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setMinAllowedDeposit', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setMinTradeAmount', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setOwner', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'setPriceLimits',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'setRoundLength', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setSkewImpactLimit', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setStakingThales', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setThalesAmm', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setUtilizationRate', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'skewImpactLimit', values?: undefined): string;
  encodeFunctionData(functionFragment: 'stakingThales', values?: undefined): string;
  encodeFunctionData(functionFragment: 'startVault', values?: undefined): string;
  encodeFunctionData(functionFragment: 'thalesAMM', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'trade',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'tradingAllocation', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'tradingMarketPositionPerRound',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'tradingMarketsPerRound',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'transferOwnershipAtInit', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'userInRound',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'usersCurrentlyInVault', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'usersPerRound',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'utilizationRate', values?: undefined): string;
  encodeFunctionData(functionFragment: 'vaultStarted', values?: undefined): string;
  encodeFunctionData(functionFragment: 'withdrawalRequest', values?: undefined): string;
  encodeFunctionData(functionFragment: 'withdrawalRequested', values: [PromiseOrValue<string>]): string;

  decodeFunctionResult(functionFragment: 'acceptOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allocationLimitsPerMarketPerRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allocationPerRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allocationSpentInARound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allocationSpentPerRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balancesPerRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'canCloseCurrentRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'capPerRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'closeRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cumulativePnLBetweenRounds', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cumulativeProfitAndLoss', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'depositReceipts', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getAvailableAllocationForMarket', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getAvailableToDeposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getBalancesPerRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getCurrentRoundEnd', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initNonReentrant', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isTradingMarketInARound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'maxAllowedDeposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'maxAllowedUsers', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'minDepositAmount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'minTradeAmount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nominateNewOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nominatedOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'paused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'priceLowerLimit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'priceUpperLimit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'profitAndLossPerRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'round', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'roundLength', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'roundStartTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'sUSD', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setAllocationLimits', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMaxAllowedDeposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMaxAllowedUsers', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMinAllowedDeposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMinTradeAmount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setPriceLimits', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setRoundLength', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setSkewImpactLimit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setStakingThales', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setThalesAmm', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setUtilizationRate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'skewImpactLimit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stakingThales', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'startVault', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'thalesAMM', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'trade', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tradingAllocation', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tradingMarketPositionPerRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tradingMarketsPerRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnershipAtInit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userInRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'usersCurrentlyInVault', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'usersPerRound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'utilizationRate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'vaultStarted', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawalRequest', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawalRequested', data: BytesLike): Result;

  events: {
    'Claimed(address,uint256)': EventFragment;
    'Deposited(address,uint256)': EventFragment;
    'MaxAllowedDepositChanged(uint256)': EventFragment;
    'MaxAllowedUsersChanged(uint256)': EventFragment;
    'MinAllowedDepositChanged(uint256)': EventFragment;
    'OwnerChanged(address,address)': EventFragment;
    'OwnerNominated(address)': EventFragment;
    'Paused(address)': EventFragment;
    'RoundClosed(uint256,uint256)': EventFragment;
    'RoundLengthChanged(uint256)': EventFragment;
    'SetAllocationLimits(uint256)': EventFragment;
    'SetMinTradeAmount(uint256)': EventFragment;
    'SetPriceLimits(uint256,uint256)': EventFragment;
    'SetSUSD(address)': EventFragment;
    'SetSkewImpactLimit(int256)': EventFragment;
    'StakingThalesChanged(address)': EventFragment;
    'ThalesAMMChanged(address)': EventFragment;
    'TradeExecuted(address,uint8,uint256,uint256)': EventFragment;
    'Unpaused(address)': EventFragment;
    'UtilizationRateChanged(uint256)': EventFragment;
    'VaultStarted()': EventFragment;
    'WithdrawalRequested(address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'Claimed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Deposited'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'MaxAllowedDepositChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'MaxAllowedUsersChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'MinAllowedDepositChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnerChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnerNominated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Paused'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoundClosed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoundLengthChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SetAllocationLimits'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SetMinTradeAmount'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SetPriceLimits'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SetSUSD'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SetSkewImpactLimit'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'StakingThalesChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ThalesAMMChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TradeExecuted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Unpaused'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'UtilizationRateChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'VaultStarted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'WithdrawalRequested'): EventFragment;
}

export interface ClaimedEventObject {
  user: string;
  amount: BigNumber;
}
export type ClaimedEvent = TypedEvent<[string, BigNumber], ClaimedEventObject>;

export type ClaimedEventFilter = TypedEventFilter<ClaimedEvent>;

export interface DepositedEventObject {
  user: string;
  amount: BigNumber;
}
export type DepositedEvent = TypedEvent<[string, BigNumber], DepositedEventObject>;

export type DepositedEventFilter = TypedEventFilter<DepositedEvent>;

export interface MaxAllowedDepositChangedEventObject {
  maxAllowedDeposit: BigNumber;
}
export type MaxAllowedDepositChangedEvent = TypedEvent<[BigNumber], MaxAllowedDepositChangedEventObject>;

export type MaxAllowedDepositChangedEventFilter = TypedEventFilter<MaxAllowedDepositChangedEvent>;

export interface MaxAllowedUsersChangedEventObject {
  MaxAllowedUsersChanged: BigNumber;
}
export type MaxAllowedUsersChangedEvent = TypedEvent<[BigNumber], MaxAllowedUsersChangedEventObject>;

export type MaxAllowedUsersChangedEventFilter = TypedEventFilter<MaxAllowedUsersChangedEvent>;

export interface MinAllowedDepositChangedEventObject {
  minAllowedDeposit: BigNumber;
}
export type MinAllowedDepositChangedEvent = TypedEvent<[BigNumber], MinAllowedDepositChangedEventObject>;

export type MinAllowedDepositChangedEventFilter = TypedEventFilter<MinAllowedDepositChangedEvent>;

export interface OwnerChangedEventObject {
  oldOwner: string;
  newOwner: string;
}
export type OwnerChangedEvent = TypedEvent<[string, string], OwnerChangedEventObject>;

export type OwnerChangedEventFilter = TypedEventFilter<OwnerChangedEvent>;

export interface OwnerNominatedEventObject {
  newOwner: string;
}
export type OwnerNominatedEvent = TypedEvent<[string], OwnerNominatedEventObject>;

export type OwnerNominatedEventFilter = TypedEventFilter<OwnerNominatedEvent>;

export interface PausedEventObject {
  account: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface RoundClosedEventObject {
  round: BigNumber;
  roundPnL: BigNumber;
}
export type RoundClosedEvent = TypedEvent<[BigNumber, BigNumber], RoundClosedEventObject>;

export type RoundClosedEventFilter = TypedEventFilter<RoundClosedEvent>;

export interface RoundLengthChangedEventObject {
  roundLength: BigNumber;
}
export type RoundLengthChangedEvent = TypedEvent<[BigNumber], RoundLengthChangedEventObject>;

export type RoundLengthChangedEventFilter = TypedEventFilter<RoundLengthChangedEvent>;

export interface SetAllocationLimitsEventObject {
  allocationLimitsPerMarketPerRound: BigNumber;
}
export type SetAllocationLimitsEvent = TypedEvent<[BigNumber], SetAllocationLimitsEventObject>;

export type SetAllocationLimitsEventFilter = TypedEventFilter<SetAllocationLimitsEvent>;

export interface SetMinTradeAmountEventObject {
  SetMinTradeAmount: BigNumber;
}
export type SetMinTradeAmountEvent = TypedEvent<[BigNumber], SetMinTradeAmountEventObject>;

export type SetMinTradeAmountEventFilter = TypedEventFilter<SetMinTradeAmountEvent>;

export interface SetPriceLimitsEventObject {
  priceLowerLimit: BigNumber;
  priceUpperLimit: BigNumber;
}
export type SetPriceLimitsEvent = TypedEvent<[BigNumber, BigNumber], SetPriceLimitsEventObject>;

export type SetPriceLimitsEventFilter = TypedEventFilter<SetPriceLimitsEvent>;

export interface SetSUSDEventObject {
  sUSD: string;
}
export type SetSUSDEvent = TypedEvent<[string], SetSUSDEventObject>;

export type SetSUSDEventFilter = TypedEventFilter<SetSUSDEvent>;

export interface SetSkewImpactLimitEventObject {
  skewImpact: BigNumber;
}
export type SetSkewImpactLimitEvent = TypedEvent<[BigNumber], SetSkewImpactLimitEventObject>;

export type SetSkewImpactLimitEventFilter = TypedEventFilter<SetSkewImpactLimitEvent>;

export interface StakingThalesChangedEventObject {
  stakingThales: string;
}
export type StakingThalesChangedEvent = TypedEvent<[string], StakingThalesChangedEventObject>;

export type StakingThalesChangedEventFilter = TypedEventFilter<StakingThalesChangedEvent>;

export interface ThalesAMMChangedEventObject {
  thalesAmm: string;
}
export type ThalesAMMChangedEvent = TypedEvent<[string], ThalesAMMChangedEventObject>;

export type ThalesAMMChangedEventFilter = TypedEventFilter<ThalesAMMChangedEvent>;

export interface TradeExecutedEventObject {
  market: string;
  position: number;
  amount: BigNumber;
  quote: BigNumber;
}
export type TradeExecutedEvent = TypedEvent<[string, number, BigNumber, BigNumber], TradeExecutedEventObject>;

export type TradeExecutedEventFilter = TypedEventFilter<TradeExecutedEvent>;

export interface UnpausedEventObject {
  account: string;
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface UtilizationRateChangedEventObject {
  utilizationRate: BigNumber;
}
export type UtilizationRateChangedEvent = TypedEvent<[BigNumber], UtilizationRateChangedEventObject>;

export type UtilizationRateChangedEventFilter = TypedEventFilter<UtilizationRateChangedEvent>;

export interface VaultStartedEventObject {}
export type VaultStartedEvent = TypedEvent<[], VaultStartedEventObject>;

export type VaultStartedEventFilter = TypedEventFilter<VaultStartedEvent>;

export interface WithdrawalRequestedEventObject {
  user: string;
}
export type WithdrawalRequestedEvent = TypedEvent<[string], WithdrawalRequestedEventObject>;

export type WithdrawalRequestedEventFilter = TypedEventFilter<WithdrawalRequestedEvent>;

export interface Vaults extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: VaultsInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    allocationLimitsPerMarketPerRound(overrides?: CallOverrides): Promise<[BigNumber]>;

    allocationPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    allocationSpentInARound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    allocationSpentPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    balancesPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    canCloseCurrentRound(overrides?: CallOverrides): Promise<[boolean]>;

    capPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    closeRound(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    cumulativePnLBetweenRounds(
      roundA: PromiseOrValue<BigNumberish>,
      roundB: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    cumulativeProfitAndLoss(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    deposit(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    depositReceipts(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { round: BigNumber; amount: BigNumber }>;

    getAvailableAllocationForMarket(market: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    getAvailableToDeposit(overrides?: CallOverrides): Promise<[BigNumber] & { returned: BigNumber }>;

    getBalancesPerRound(
      _round: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    getCurrentRoundEnd(overrides?: CallOverrides): Promise<[BigNumber]>;

    initNonReentrant(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    initialize(
      params: AmmVault.InitParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    isTradingMarketInARound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    maxAllowedDeposit(overrides?: CallOverrides): Promise<[BigNumber]>;

    maxAllowedUsers(overrides?: CallOverrides): Promise<[BigNumber]>;

    minDepositAmount(overrides?: CallOverrides): Promise<[BigNumber]>;

    minTradeAmount(overrides?: CallOverrides): Promise<[BigNumber]>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    nominatedOwner(overrides?: CallOverrides): Promise<[string]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    priceLowerLimit(overrides?: CallOverrides): Promise<[BigNumber]>;

    priceUpperLimit(overrides?: CallOverrides): Promise<[BigNumber]>;

    profitAndLossPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    round(overrides?: CallOverrides): Promise<[BigNumber]>;

    roundLength(overrides?: CallOverrides): Promise<[BigNumber]>;

    roundStartTime(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    sUSD(overrides?: CallOverrides): Promise<[string]>;

    setAllocationLimits(
      _allocationLimitsPerMarketPerRound: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setMaxAllowedDeposit(
      _maxAllowedDeposit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setMaxAllowedUsers(
      _maxAllowedUsers: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setMinAllowedDeposit(
      _minDepositAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setMinTradeAmount(
      _minTradeAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setPriceLimits(
      _priceLowerLimit: PromiseOrValue<BigNumberish>,
      _priceUpperLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setRoundLength(
      _roundLength: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setSkewImpactLimit(
      _skewImpactLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setStakingThales(
      _stakingThales: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setThalesAmm(
      _thalesAMM: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setUtilizationRate(
      _utilizationRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    skewImpactLimit(overrides?: CallOverrides): Promise<[BigNumber]>;

    stakingThales(overrides?: CallOverrides): Promise<[string]>;

    startVault(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    thalesAMM(overrides?: CallOverrides): Promise<[string]>;

    trade(
      market: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    tradingAllocation(overrides?: CallOverrides): Promise<[BigNumber]>;

    tradingMarketPositionPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[number]>;

    tradingMarketsPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string]>;

    transferOwnershipAtInit(
      proxyAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    userInRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    usersCurrentlyInVault(overrides?: CallOverrides): Promise<[BigNumber]>;

    usersPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string]>;

    utilizationRate(overrides?: CallOverrides): Promise<[BigNumber]>;

    vaultStarted(overrides?: CallOverrides): Promise<[boolean]>;

    withdrawalRequest(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    withdrawalRequested(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
  };

  acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  allocationLimitsPerMarketPerRound(overrides?: CallOverrides): Promise<BigNumber>;

  allocationPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  allocationSpentInARound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  allocationSpentPerRound(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  balancesPerRound(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  canCloseCurrentRound(overrides?: CallOverrides): Promise<boolean>;

  capPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  closeRound(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  cumulativePnLBetweenRounds(
    roundA: PromiseOrValue<BigNumberish>,
    roundB: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  cumulativeProfitAndLoss(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  deposit(
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  depositReceipts(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, BigNumber] & { round: BigNumber; amount: BigNumber }>;

  getAvailableAllocationForMarket(market: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  getAvailableToDeposit(overrides?: CallOverrides): Promise<BigNumber>;

  getBalancesPerRound(
    _round: PromiseOrValue<BigNumberish>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  getCurrentRoundEnd(overrides?: CallOverrides): Promise<BigNumber>;

  initNonReentrant(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  initialize(
    params: AmmVault.InitParamsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  isTradingMarketInARound(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  maxAllowedDeposit(overrides?: CallOverrides): Promise<BigNumber>;

  maxAllowedUsers(overrides?: CallOverrides): Promise<BigNumber>;

  minDepositAmount(overrides?: CallOverrides): Promise<BigNumber>;

  minTradeAmount(overrides?: CallOverrides): Promise<BigNumber>;

  nominateNewOwner(
    _owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  nominatedOwner(overrides?: CallOverrides): Promise<string>;

  owner(overrides?: CallOverrides): Promise<string>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  priceLowerLimit(overrides?: CallOverrides): Promise<BigNumber>;

  priceUpperLimit(overrides?: CallOverrides): Promise<BigNumber>;

  profitAndLossPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  round(overrides?: CallOverrides): Promise<BigNumber>;

  roundLength(overrides?: CallOverrides): Promise<BigNumber>;

  roundStartTime(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  sUSD(overrides?: CallOverrides): Promise<string>;

  setAllocationLimits(
    _allocationLimitsPerMarketPerRound: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setMaxAllowedDeposit(
    _maxAllowedDeposit: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setMaxAllowedUsers(
    _maxAllowedUsers: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setMinAllowedDeposit(
    _minDepositAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setMinTradeAmount(
    _minTradeAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setOwner(
    _owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setPriceLimits(
    _priceLowerLimit: PromiseOrValue<BigNumberish>,
    _priceUpperLimit: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setRoundLength(
    _roundLength: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setSkewImpactLimit(
    _skewImpactLimit: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setStakingThales(
    _stakingThales: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setThalesAmm(
    _thalesAMM: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setUtilizationRate(
    _utilizationRate: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  skewImpactLimit(overrides?: CallOverrides): Promise<BigNumber>;

  stakingThales(overrides?: CallOverrides): Promise<string>;

  startVault(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  thalesAMM(overrides?: CallOverrides): Promise<string>;

  trade(
    market: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    position: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  tradingAllocation(overrides?: CallOverrides): Promise<BigNumber>;

  tradingMarketPositionPerRound(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<number>;

  tradingMarketsPerRound(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<string>;

  transferOwnershipAtInit(
    proxyAddress: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  userInRound(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  usersCurrentlyInVault(overrides?: CallOverrides): Promise<BigNumber>;

  usersPerRound(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<string>;

  utilizationRate(overrides?: CallOverrides): Promise<BigNumber>;

  vaultStarted(overrides?: CallOverrides): Promise<boolean>;

  withdrawalRequest(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  withdrawalRequested(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  callStatic: {
    acceptOwnership(overrides?: CallOverrides): Promise<void>;

    allocationLimitsPerMarketPerRound(overrides?: CallOverrides): Promise<BigNumber>;

    allocationPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    allocationSpentInARound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    allocationSpentPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    balancesPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    canCloseCurrentRound(overrides?: CallOverrides): Promise<boolean>;

    capPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    closeRound(overrides?: CallOverrides): Promise<void>;

    cumulativePnLBetweenRounds(
      roundA: PromiseOrValue<BigNumberish>,
      roundB: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    cumulativeProfitAndLoss(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    deposit(amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    depositReceipts(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { round: BigNumber; amount: BigNumber }>;

    getAvailableAllocationForMarket(market: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getAvailableToDeposit(overrides?: CallOverrides): Promise<BigNumber>;

    getBalancesPerRound(
      _round: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getCurrentRoundEnd(overrides?: CallOverrides): Promise<BigNumber>;

    initNonReentrant(overrides?: CallOverrides): Promise<void>;

    initialize(params: AmmVault.InitParamsStruct, overrides?: CallOverrides): Promise<void>;

    isTradingMarketInARound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    maxAllowedDeposit(overrides?: CallOverrides): Promise<BigNumber>;

    maxAllowedUsers(overrides?: CallOverrides): Promise<BigNumber>;

    minDepositAmount(overrides?: CallOverrides): Promise<BigNumber>;

    minTradeAmount(overrides?: CallOverrides): Promise<BigNumber>;

    nominateNewOwner(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    nominatedOwner(overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    priceLowerLimit(overrides?: CallOverrides): Promise<BigNumber>;

    priceUpperLimit(overrides?: CallOverrides): Promise<BigNumber>;

    profitAndLossPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    round(overrides?: CallOverrides): Promise<BigNumber>;

    roundLength(overrides?: CallOverrides): Promise<BigNumber>;

    roundStartTime(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    sUSD(overrides?: CallOverrides): Promise<string>;

    setAllocationLimits(
      _allocationLimitsPerMarketPerRound: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setMaxAllowedDeposit(_maxAllowedDeposit: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setMaxAllowedUsers(_maxAllowedUsers: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setMinAllowedDeposit(_minDepositAmount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setMinTradeAmount(_minTradeAmount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setOwner(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setPriceLimits(
      _priceLowerLimit: PromiseOrValue<BigNumberish>,
      _priceUpperLimit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setRoundLength(_roundLength: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setSkewImpactLimit(_skewImpactLimit: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setStakingThales(_stakingThales: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setThalesAmm(_thalesAMM: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setUtilizationRate(_utilizationRate: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    skewImpactLimit(overrides?: CallOverrides): Promise<BigNumber>;

    stakingThales(overrides?: CallOverrides): Promise<string>;

    startVault(overrides?: CallOverrides): Promise<void>;

    thalesAMM(overrides?: CallOverrides): Promise<string>;

    trade(
      market: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    tradingAllocation(overrides?: CallOverrides): Promise<BigNumber>;

    tradingMarketPositionPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<number>;

    tradingMarketsPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<string>;

    transferOwnershipAtInit(proxyAddress: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    userInRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    usersCurrentlyInVault(overrides?: CallOverrides): Promise<BigNumber>;

    usersPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<string>;

    utilizationRate(overrides?: CallOverrides): Promise<BigNumber>;

    vaultStarted(overrides?: CallOverrides): Promise<boolean>;

    withdrawalRequest(overrides?: CallOverrides): Promise<void>;

    withdrawalRequested(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
  };

  filters: {
    'Claimed(address,uint256)'(user?: null, amount?: null): ClaimedEventFilter;
    Claimed(user?: null, amount?: null): ClaimedEventFilter;

    'Deposited(address,uint256)'(user?: null, amount?: null): DepositedEventFilter;
    Deposited(user?: null, amount?: null): DepositedEventFilter;

    'MaxAllowedDepositChanged(uint256)'(maxAllowedDeposit?: null): MaxAllowedDepositChangedEventFilter;
    MaxAllowedDepositChanged(maxAllowedDeposit?: null): MaxAllowedDepositChangedEventFilter;

    'MaxAllowedUsersChanged(uint256)'(MaxAllowedUsersChanged?: null): MaxAllowedUsersChangedEventFilter;
    MaxAllowedUsersChanged(MaxAllowedUsersChanged?: null): MaxAllowedUsersChangedEventFilter;

    'MinAllowedDepositChanged(uint256)'(minAllowedDeposit?: null): MinAllowedDepositChangedEventFilter;
    MinAllowedDepositChanged(minAllowedDeposit?: null): MinAllowedDepositChangedEventFilter;

    'OwnerChanged(address,address)'(oldOwner?: null, newOwner?: null): OwnerChangedEventFilter;
    OwnerChanged(oldOwner?: null, newOwner?: null): OwnerChangedEventFilter;

    'OwnerNominated(address)'(newOwner?: null): OwnerNominatedEventFilter;
    OwnerNominated(newOwner?: null): OwnerNominatedEventFilter;

    'Paused(address)'(account?: null): PausedEventFilter;
    Paused(account?: null): PausedEventFilter;

    'RoundClosed(uint256,uint256)'(round?: null, roundPnL?: null): RoundClosedEventFilter;
    RoundClosed(round?: null, roundPnL?: null): RoundClosedEventFilter;

    'RoundLengthChanged(uint256)'(roundLength?: null): RoundLengthChangedEventFilter;
    RoundLengthChanged(roundLength?: null): RoundLengthChangedEventFilter;

    'SetAllocationLimits(uint256)'(allocationLimitsPerMarketPerRound?: null): SetAllocationLimitsEventFilter;
    SetAllocationLimits(allocationLimitsPerMarketPerRound?: null): SetAllocationLimitsEventFilter;

    'SetMinTradeAmount(uint256)'(SetMinTradeAmount?: null): SetMinTradeAmountEventFilter;
    SetMinTradeAmount(SetMinTradeAmount?: null): SetMinTradeAmountEventFilter;

    'SetPriceLimits(uint256,uint256)'(priceLowerLimit?: null, priceUpperLimit?: null): SetPriceLimitsEventFilter;
    SetPriceLimits(priceLowerLimit?: null, priceUpperLimit?: null): SetPriceLimitsEventFilter;

    'SetSUSD(address)'(sUSD?: null): SetSUSDEventFilter;
    SetSUSD(sUSD?: null): SetSUSDEventFilter;

    'SetSkewImpactLimit(int256)'(skewImpact?: null): SetSkewImpactLimitEventFilter;
    SetSkewImpactLimit(skewImpact?: null): SetSkewImpactLimitEventFilter;

    'StakingThalesChanged(address)'(stakingThales?: null): StakingThalesChangedEventFilter;
    StakingThalesChanged(stakingThales?: null): StakingThalesChangedEventFilter;

    'ThalesAMMChanged(address)'(thalesAmm?: null): ThalesAMMChangedEventFilter;
    ThalesAMMChanged(thalesAmm?: null): ThalesAMMChangedEventFilter;

    'TradeExecuted(address,uint8,uint256,uint256)'(
      market?: null,
      position?: null,
      amount?: null,
      quote?: null,
    ): TradeExecutedEventFilter;
    TradeExecuted(market?: null, position?: null, amount?: null, quote?: null): TradeExecutedEventFilter;

    'Unpaused(address)'(account?: null): UnpausedEventFilter;
    Unpaused(account?: null): UnpausedEventFilter;

    'UtilizationRateChanged(uint256)'(utilizationRate?: null): UtilizationRateChangedEventFilter;
    UtilizationRateChanged(utilizationRate?: null): UtilizationRateChangedEventFilter;

    'VaultStarted()'(): VaultStartedEventFilter;
    VaultStarted(): VaultStartedEventFilter;

    'WithdrawalRequested(address)'(user?: null): WithdrawalRequestedEventFilter;
    WithdrawalRequested(user?: null): WithdrawalRequestedEventFilter;
  };

  estimateGas: {
    acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    allocationLimitsPerMarketPerRound(overrides?: CallOverrides): Promise<BigNumber>;

    allocationPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    allocationSpentInARound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    allocationSpentPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    balancesPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    canCloseCurrentRound(overrides?: CallOverrides): Promise<BigNumber>;

    capPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    closeRound(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    cumulativePnLBetweenRounds(
      roundA: PromiseOrValue<BigNumberish>,
      roundB: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    cumulativeProfitAndLoss(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    deposit(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    depositReceipts(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getAvailableAllocationForMarket(market: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getAvailableToDeposit(overrides?: CallOverrides): Promise<BigNumber>;

    getBalancesPerRound(
      _round: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getCurrentRoundEnd(overrides?: CallOverrides): Promise<BigNumber>;

    initNonReentrant(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    initialize(
      params: AmmVault.InitParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    isTradingMarketInARound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    maxAllowedDeposit(overrides?: CallOverrides): Promise<BigNumber>;

    maxAllowedUsers(overrides?: CallOverrides): Promise<BigNumber>;

    minDepositAmount(overrides?: CallOverrides): Promise<BigNumber>;

    minTradeAmount(overrides?: CallOverrides): Promise<BigNumber>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    nominatedOwner(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    priceLowerLimit(overrides?: CallOverrides): Promise<BigNumber>;

    priceUpperLimit(overrides?: CallOverrides): Promise<BigNumber>;

    profitAndLossPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    round(overrides?: CallOverrides): Promise<BigNumber>;

    roundLength(overrides?: CallOverrides): Promise<BigNumber>;

    roundStartTime(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    sUSD(overrides?: CallOverrides): Promise<BigNumber>;

    setAllocationLimits(
      _allocationLimitsPerMarketPerRound: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setMaxAllowedDeposit(
      _maxAllowedDeposit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setMaxAllowedUsers(
      _maxAllowedUsers: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setMinAllowedDeposit(
      _minDepositAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setMinTradeAmount(
      _minTradeAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setPriceLimits(
      _priceLowerLimit: PromiseOrValue<BigNumberish>,
      _priceUpperLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setRoundLength(
      _roundLength: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setSkewImpactLimit(
      _skewImpactLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setStakingThales(
      _stakingThales: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setThalesAmm(
      _thalesAMM: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setUtilizationRate(
      _utilizationRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    skewImpactLimit(overrides?: CallOverrides): Promise<BigNumber>;

    stakingThales(overrides?: CallOverrides): Promise<BigNumber>;

    startVault(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    thalesAMM(overrides?: CallOverrides): Promise<BigNumber>;

    trade(
      market: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    tradingAllocation(overrides?: CallOverrides): Promise<BigNumber>;

    tradingMarketPositionPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    tradingMarketsPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    transferOwnershipAtInit(
      proxyAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    userInRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    usersCurrentlyInVault(overrides?: CallOverrides): Promise<BigNumber>;

    usersPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    utilizationRate(overrides?: CallOverrides): Promise<BigNumber>;

    vaultStarted(overrides?: CallOverrides): Promise<BigNumber>;

    withdrawalRequest(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    withdrawalRequested(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    allocationLimitsPerMarketPerRound(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    allocationPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    allocationSpentInARound(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    allocationSpentPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    balancesPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    canCloseCurrentRound(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    capPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    closeRound(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    cumulativePnLBetweenRounds(
      roundA: PromiseOrValue<BigNumberish>,
      roundB: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    cumulativeProfitAndLoss(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    deposit(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    depositReceipts(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getAvailableAllocationForMarket(
      market: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getAvailableToDeposit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getBalancesPerRound(
      _round: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getCurrentRoundEnd(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initNonReentrant(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    initialize(
      params: AmmVault.InitParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    isTradingMarketInARound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    maxAllowedDeposit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    maxAllowedUsers(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minDepositAmount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minTradeAmount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    nominatedOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    priceLowerLimit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    priceUpperLimit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    profitAndLossPerRound(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    round(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    roundLength(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    roundStartTime(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    sUSD(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setAllocationLimits(
      _allocationLimitsPerMarketPerRound: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setMaxAllowedDeposit(
      _maxAllowedDeposit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setMaxAllowedUsers(
      _maxAllowedUsers: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setMinAllowedDeposit(
      _minDepositAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setMinTradeAmount(
      _minTradeAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setPriceLimits(
      _priceLowerLimit: PromiseOrValue<BigNumberish>,
      _priceUpperLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setRoundLength(
      _roundLength: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setSkewImpactLimit(
      _skewImpactLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setStakingThales(
      _stakingThales: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setThalesAmm(
      _thalesAMM: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setUtilizationRate(
      _utilizationRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    skewImpactLimit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    stakingThales(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    startVault(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    thalesAMM(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    trade(
      market: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    tradingAllocation(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tradingMarketPositionPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    tradingMarketsPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    transferOwnershipAtInit(
      proxyAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    userInRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    usersCurrentlyInVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    usersPerRound(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    utilizationRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    vaultStarted(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdrawalRequest(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    withdrawalRequested(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export interface VelodromeV2VoterInterface extends utils.Interface {
  functions: {
    'claimBribes(address[],address[][],uint256)': FunctionFragment;
    'claimFees(address[],address[][],uint256)': FunctionFragment;
    'claimRewards(address[])': FunctionFragment;
    'claimable(address)': FunctionFragment;
    'createGauge(address,address)': FunctionFragment;
    'depositManaged(uint256,uint256)': FunctionFragment;
    'distribute(address[])': FunctionFragment;
    'distribute(uint256,uint256)': FunctionFragment;
    'emergencyCouncil()': FunctionFragment;
    'epochGovernor()': FunctionFragment;
    'epochNext(uint256)': FunctionFragment;
    'epochStart(uint256)': FunctionFragment;
    'epochVoteEnd(uint256)': FunctionFragment;
    'epochVoteStart(uint256)': FunctionFragment;
    'factoryRegistry()': FunctionFragment;
    'forwarder()': FunctionFragment;
    'gaugeToBribe(address)': FunctionFragment;
    'gaugeToFees(address)': FunctionFragment;
    'gauges(address)': FunctionFragment;
    'governor()': FunctionFragment;
    'initialize(address[],address)': FunctionFragment;
    'isAlive(address)': FunctionFragment;
    'isGauge(address)': FunctionFragment;
    'isTrustedForwarder(address)': FunctionFragment;
    'isWhitelistedNFT(uint256)': FunctionFragment;
    'isWhitelistedToken(address)': FunctionFragment;
    'killGauge(address)': FunctionFragment;
    'lastVoted(uint256)': FunctionFragment;
    'length()': FunctionFragment;
    'maxVotingNum()': FunctionFragment;
    'minter()': FunctionFragment;
    'notifyRewardAmount(uint256)': FunctionFragment;
    'poke(uint256)': FunctionFragment;
    'poolForGauge(address)': FunctionFragment;
    'poolVote(uint256,uint256)': FunctionFragment;
    'pools(uint256)': FunctionFragment;
    'reset(uint256)': FunctionFragment;
    'reviveGauge(address)': FunctionFragment;
    'setEmergencyCouncil(address)': FunctionFragment;
    'setEpochGovernor(address)': FunctionFragment;
    'setGovernor(address)': FunctionFragment;
    'setMaxVotingNum(uint256)': FunctionFragment;
    'totalWeight()': FunctionFragment;
    'updateFor(address)': FunctionFragment;
    'updateFor(uint256,uint256)': FunctionFragment;
    'updateFor(address[])': FunctionFragment;
    'usedWeights(uint256)': FunctionFragment;
    'v1Factory()': FunctionFragment;
    've()': FunctionFragment;
    'vote(uint256,address[],uint256[])': FunctionFragment;
    'votes(uint256,address)': FunctionFragment;
    'weights(address)': FunctionFragment;
    'whitelistNFT(uint256,bool)': FunctionFragment;
    'whitelistToken(address,bool)': FunctionFragment;
    'withdrawManaged(uint256)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'claimBribes'
      | 'claimFees'
      | 'claimRewards'
      | 'claimable'
      | 'createGauge'
      | 'depositManaged'
      | 'distribute(address[])'
      | 'distribute(uint256,uint256)'
      | 'emergencyCouncil'
      | 'epochGovernor'
      | 'epochNext'
      | 'epochStart'
      | 'epochVoteEnd'
      | 'epochVoteStart'
      | 'factoryRegistry'
      | 'forwarder'
      | 'gaugeToBribe'
      | 'gaugeToFees'
      | 'gauges'
      | 'governor'
      | 'initialize'
      | 'isAlive'
      | 'isGauge'
      | 'isTrustedForwarder'
      | 'isWhitelistedNFT'
      | 'isWhitelistedToken'
      | 'killGauge'
      | 'lastVoted'
      | 'length'
      | 'maxVotingNum'
      | 'minter'
      | 'notifyRewardAmount'
      | 'poke'
      | 'poolForGauge'
      | 'poolVote'
      | 'pools'
      | 'reset'
      | 'reviveGauge'
      | 'setEmergencyCouncil'
      | 'setEpochGovernor'
      | 'setGovernor'
      | 'setMaxVotingNum'
      | 'totalWeight'
      | 'updateFor(address)'
      | 'updateFor(uint256,uint256)'
      | 'updateFor(address[])'
      | 'usedWeights'
      | 'v1Factory'
      | 've'
      | 'vote'
      | 'votes'
      | 'weights'
      | 'whitelistNFT'
      | 'whitelistToken'
      | 'withdrawManaged',
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: 'claimBribes',
    values: [PromiseOrValue<string>[], PromiseOrValue<string>[][], PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'claimFees',
    values: [PromiseOrValue<string>[], PromiseOrValue<string>[][], PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'claimRewards', values: [PromiseOrValue<string>[]]): string;
  encodeFunctionData(functionFragment: 'claimable', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'createGauge', values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'depositManaged',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'distribute(address[])', values: [PromiseOrValue<string>[]]): string;
  encodeFunctionData(
    functionFragment: 'distribute(uint256,uint256)',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'emergencyCouncil', values?: undefined): string;
  encodeFunctionData(functionFragment: 'epochGovernor', values?: undefined): string;
  encodeFunctionData(functionFragment: 'epochNext', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'epochStart', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'epochVoteEnd', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'epochVoteStart', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'factoryRegistry', values?: undefined): string;
  encodeFunctionData(functionFragment: 'forwarder', values?: undefined): string;
  encodeFunctionData(functionFragment: 'gaugeToBribe', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'gaugeToFees', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'gauges', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'governor', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'initialize',
    values: [PromiseOrValue<string>[], PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'isAlive', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'isGauge', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'isTrustedForwarder', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'isWhitelistedNFT', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'isWhitelistedToken', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'killGauge', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'lastVoted', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'length', values?: undefined): string;
  encodeFunctionData(functionFragment: 'maxVotingNum', values?: undefined): string;
  encodeFunctionData(functionFragment: 'minter', values?: undefined): string;
  encodeFunctionData(functionFragment: 'notifyRewardAmount', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'poke', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'poolForGauge', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'poolVote',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'pools', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'reset', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'reviveGauge', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setEmergencyCouncil', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setEpochGovernor', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setGovernor', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setMaxVotingNum', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'totalWeight', values?: undefined): string;
  encodeFunctionData(functionFragment: 'updateFor(address)', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'updateFor(uint256,uint256)',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'updateFor(address[])', values: [PromiseOrValue<string>[]]): string;
  encodeFunctionData(functionFragment: 'usedWeights', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'v1Factory', values?: undefined): string;
  encodeFunctionData(functionFragment: 've', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'vote',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]],
  ): string;
  encodeFunctionData(functionFragment: 'votes', values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'weights', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'whitelistNFT',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'whitelistToken',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'withdrawManaged', values: [PromiseOrValue<BigNumberish>]): string;

  decodeFunctionResult(functionFragment: 'claimBribes', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimFees', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimable', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'createGauge', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'depositManaged', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'distribute(address[])', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'distribute(uint256,uint256)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'emergencyCouncil', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'epochGovernor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'epochNext', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'epochStart', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'epochVoteEnd', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'epochVoteStart', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'factoryRegistry', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'forwarder', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'gaugeToBribe', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'gaugeToFees', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'gauges', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'governor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isAlive', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isGauge', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isTrustedForwarder', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isWhitelistedNFT', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isWhitelistedToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'killGauge', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lastVoted', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'length', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'maxVotingNum', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'minter', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'notifyRewardAmount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'poke', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'poolForGauge', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'poolVote', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pools', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'reset', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'reviveGauge', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setEmergencyCouncil', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setEpochGovernor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setGovernor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMaxVotingNum', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalWeight', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateFor(address)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateFor(uint256,uint256)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateFor(address[])', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'usedWeights', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'v1Factory', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 've', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'vote', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'votes', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'weights', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'whitelistNFT', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'whitelistToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawManaged', data: BytesLike): Result;

  events: {
    'Abstained(address,address,uint256,uint256,uint256,uint256)': EventFragment;
    'DistributeReward(address,address,uint256)': EventFragment;
    'GaugeCreated(address,address,address,address,address,address,address,address)': EventFragment;
    'GaugeKilled(address)': EventFragment;
    'GaugeRevived(address)': EventFragment;
    'NotifyReward(address,address,uint256)': EventFragment;
    'Voted(address,address,uint256,uint256,uint256,uint256)': EventFragment;
    'WhitelistNFT(address,uint256,bool)': EventFragment;
    'WhitelistToken(address,address,bool)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'Abstained'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'DistributeReward'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'GaugeCreated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'GaugeKilled'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'GaugeRevived'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NotifyReward'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Voted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'WhitelistNFT'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'WhitelistToken'): EventFragment;
}

export interface AbstainedEventObject {
  voter: string;
  pool: string;
  tokenId: BigNumber;
  weight: BigNumber;
  totalWeight: BigNumber;
  timestamp: BigNumber;
}
export type AbstainedEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, BigNumber, BigNumber],
  AbstainedEventObject
>;

export type AbstainedEventFilter = TypedEventFilter<AbstainedEvent>;

export interface DistributeRewardEventObject {
  sender: string;
  gauge: string;
  amount: BigNumber;
}
export type DistributeRewardEvent = TypedEvent<[string, string, BigNumber], DistributeRewardEventObject>;

export type DistributeRewardEventFilter = TypedEventFilter<DistributeRewardEvent>;

export interface GaugeCreatedEventObject {
  poolFactory: string;
  votingRewardsFactory: string;
  gaugeFactory: string;
  pool: string;
  bribeVotingReward: string;
  feeVotingReward: string;
  gauge: string;
  creator: string;
}
export type GaugeCreatedEvent = TypedEvent<
  [string, string, string, string, string, string, string, string],
  GaugeCreatedEventObject
>;

export type GaugeCreatedEventFilter = TypedEventFilter<GaugeCreatedEvent>;

export interface GaugeKilledEventObject {
  gauge: string;
}
export type GaugeKilledEvent = TypedEvent<[string], GaugeKilledEventObject>;

export type GaugeKilledEventFilter = TypedEventFilter<GaugeKilledEvent>;

export interface GaugeRevivedEventObject {
  gauge: string;
}
export type GaugeRevivedEvent = TypedEvent<[string], GaugeRevivedEventObject>;

export type GaugeRevivedEventFilter = TypedEventFilter<GaugeRevivedEvent>;

export interface NotifyRewardEventObject {
  sender: string;
  reward: string;
  amount: BigNumber;
}
export type NotifyRewardEvent = TypedEvent<[string, string, BigNumber], NotifyRewardEventObject>;

export type NotifyRewardEventFilter = TypedEventFilter<NotifyRewardEvent>;

export interface VotedEventObject {
  voter: string;
  pool: string;
  tokenId: BigNumber;
  weight: BigNumber;
  totalWeight: BigNumber;
  timestamp: BigNumber;
}
export type VotedEvent = TypedEvent<[string, string, BigNumber, BigNumber, BigNumber, BigNumber], VotedEventObject>;

export type VotedEventFilter = TypedEventFilter<VotedEvent>;

export interface WhitelistNFTEventObject {
  whitelister: string;
  tokenId: BigNumber;
  _bool: boolean;
}
export type WhitelistNFTEvent = TypedEvent<[string, BigNumber, boolean], WhitelistNFTEventObject>;

export type WhitelistNFTEventFilter = TypedEventFilter<WhitelistNFTEvent>;

export interface WhitelistTokenEventObject {
  whitelister: string;
  token: string;
  _bool: boolean;
}
export type WhitelistTokenEvent = TypedEvent<[string, string, boolean], WhitelistTokenEventObject>;

export type WhitelistTokenEventFilter = TypedEventFilter<WhitelistTokenEvent>;

export interface VelodromeV2Voter extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: VelodromeV2VoterInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    claimBribes(
      _bribes: PromiseOrValue<string>[],
      _tokens: PromiseOrValue<string>[][],
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    claimFees(
      _fees: PromiseOrValue<string>[],
      _tokens: PromiseOrValue<string>[][],
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    claimRewards(
      _gauges: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    claimable(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    createGauge(
      _poolFactory: PromiseOrValue<string>,
      _pool: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    depositManaged(
      _tokenId: PromiseOrValue<BigNumberish>,
      _mTokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'distribute(address[])'(
      _gauges: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'distribute(uint256,uint256)'(
      _start: PromiseOrValue<BigNumberish>,
      _finish: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    emergencyCouncil(overrides?: CallOverrides): Promise<[string]>;

    epochGovernor(overrides?: CallOverrides): Promise<[string]>;

    epochNext(_timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    epochStart(_timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    epochVoteEnd(_timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    epochVoteStart(_timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    factoryRegistry(overrides?: CallOverrides): Promise<[string]>;

    forwarder(overrides?: CallOverrides): Promise<[string]>;

    gaugeToBribe(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;

    gaugeToFees(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;

    gauges(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;

    governor(overrides?: CallOverrides): Promise<[string]>;

    initialize(
      _tokens: PromiseOrValue<string>[],
      _minter: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    isAlive(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    isGauge(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    isTrustedForwarder(forwarder: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    isWhitelistedNFT(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[boolean]>;

    isWhitelistedToken(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    killGauge(
      _gauge: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    lastVoted(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    length(overrides?: CallOverrides): Promise<[BigNumber]>;

    maxVotingNum(overrides?: CallOverrides): Promise<[BigNumber]>;

    minter(overrides?: CallOverrides): Promise<[string]>;

    notifyRewardAmount(
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    poke(
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    poolForGauge(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;

    poolVote(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string]>;

    pools(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    reset(
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    reviveGauge(
      _gauge: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setEmergencyCouncil(
      _council: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setEpochGovernor(
      _epochGovernor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setGovernor(
      _governor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setMaxVotingNum(
      _maxVotingNum: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    totalWeight(overrides?: CallOverrides): Promise<[BigNumber]>;

    'updateFor(address)'(
      _gauge: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'updateFor(uint256,uint256)'(
      start: PromiseOrValue<BigNumberish>,
      end: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'updateFor(address[])'(
      _gauges: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    usedWeights(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    v1Factory(overrides?: CallOverrides): Promise<[string]>;

    ve(overrides?: CallOverrides): Promise<[string]>;

    vote(
      _tokenId: PromiseOrValue<BigNumberish>,
      _poolVote: PromiseOrValue<string>[],
      _weights: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    votes(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    weights(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    whitelistNFT(
      _tokenId: PromiseOrValue<BigNumberish>,
      _bool: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    whitelistToken(
      _token: PromiseOrValue<string>,
      _bool: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    withdrawManaged(
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;
  };

  claimBribes(
    _bribes: PromiseOrValue<string>[],
    _tokens: PromiseOrValue<string>[][],
    _tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  claimFees(
    _fees: PromiseOrValue<string>[],
    _tokens: PromiseOrValue<string>[][],
    _tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  claimRewards(
    _gauges: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  claimable(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  createGauge(
    _poolFactory: PromiseOrValue<string>,
    _pool: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  depositManaged(
    _tokenId: PromiseOrValue<BigNumberish>,
    _mTokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'distribute(address[])'(
    _gauges: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'distribute(uint256,uint256)'(
    _start: PromiseOrValue<BigNumberish>,
    _finish: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  emergencyCouncil(overrides?: CallOverrides): Promise<string>;

  epochGovernor(overrides?: CallOverrides): Promise<string>;

  epochNext(_timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  epochStart(_timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  epochVoteEnd(_timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  epochVoteStart(_timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  factoryRegistry(overrides?: CallOverrides): Promise<string>;

  forwarder(overrides?: CallOverrides): Promise<string>;

  gaugeToBribe(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  gaugeToFees(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  gauges(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  governor(overrides?: CallOverrides): Promise<string>;

  initialize(
    _tokens: PromiseOrValue<string>[],
    _minter: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  isAlive(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  isGauge(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  isTrustedForwarder(forwarder: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  isWhitelistedNFT(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>;

  isWhitelistedToken(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  killGauge(
    _gauge: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  lastVoted(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  length(overrides?: CallOverrides): Promise<BigNumber>;

  maxVotingNum(overrides?: CallOverrides): Promise<BigNumber>;

  minter(overrides?: CallOverrides): Promise<string>;

  notifyRewardAmount(
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  poke(
    _tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  poolForGauge(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  poolVote(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<string>;

  pools(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  reset(
    _tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  reviveGauge(
    _gauge: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setEmergencyCouncil(
    _council: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setEpochGovernor(
    _epochGovernor: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setGovernor(
    _governor: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setMaxVotingNum(
    _maxVotingNum: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  totalWeight(overrides?: CallOverrides): Promise<BigNumber>;

  'updateFor(address)'(
    _gauge: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'updateFor(uint256,uint256)'(
    start: PromiseOrValue<BigNumberish>,
    end: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'updateFor(address[])'(
    _gauges: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  usedWeights(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  v1Factory(overrides?: CallOverrides): Promise<string>;

  ve(overrides?: CallOverrides): Promise<string>;

  vote(
    _tokenId: PromiseOrValue<BigNumberish>,
    _poolVote: PromiseOrValue<string>[],
    _weights: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  votes(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  weights(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  whitelistNFT(
    _tokenId: PromiseOrValue<BigNumberish>,
    _bool: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  whitelistToken(
    _token: PromiseOrValue<string>,
    _bool: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  withdrawManaged(
    _tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    claimBribes(
      _bribes: PromiseOrValue<string>[],
      _tokens: PromiseOrValue<string>[][],
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    claimFees(
      _fees: PromiseOrValue<string>[],
      _tokens: PromiseOrValue<string>[][],
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    claimRewards(_gauges: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;

    claimable(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    createGauge(
      _poolFactory: PromiseOrValue<string>,
      _pool: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<string>;

    depositManaged(
      _tokenId: PromiseOrValue<BigNumberish>,
      _mTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    'distribute(address[])'(_gauges: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;

    'distribute(uint256,uint256)'(
      _start: PromiseOrValue<BigNumberish>,
      _finish: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    emergencyCouncil(overrides?: CallOverrides): Promise<string>;

    epochGovernor(overrides?: CallOverrides): Promise<string>;

    epochNext(_timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    epochStart(_timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    epochVoteEnd(_timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    epochVoteStart(_timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    factoryRegistry(overrides?: CallOverrides): Promise<string>;

    forwarder(overrides?: CallOverrides): Promise<string>;

    gaugeToBribe(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    gaugeToFees(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    gauges(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    governor(overrides?: CallOverrides): Promise<string>;

    initialize(
      _tokens: PromiseOrValue<string>[],
      _minter: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    isAlive(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    isGauge(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    isTrustedForwarder(forwarder: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    isWhitelistedNFT(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>;

    isWhitelistedToken(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    killGauge(_gauge: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    lastVoted(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    length(overrides?: CallOverrides): Promise<BigNumber>;

    maxVotingNum(overrides?: CallOverrides): Promise<BigNumber>;

    minter(overrides?: CallOverrides): Promise<string>;

    notifyRewardAmount(_amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    poke(_tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    poolForGauge(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    poolVote(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<string>;

    pools(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    reset(_tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    reviveGauge(_gauge: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setEmergencyCouncil(_council: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setEpochGovernor(_epochGovernor: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setGovernor(_governor: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setMaxVotingNum(_maxVotingNum: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    totalWeight(overrides?: CallOverrides): Promise<BigNumber>;

    'updateFor(address)'(_gauge: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    'updateFor(uint256,uint256)'(
      start: PromiseOrValue<BigNumberish>,
      end: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    'updateFor(address[])'(_gauges: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;

    usedWeights(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    v1Factory(overrides?: CallOverrides): Promise<string>;

    ve(overrides?: CallOverrides): Promise<string>;

    vote(
      _tokenId: PromiseOrValue<BigNumberish>,
      _poolVote: PromiseOrValue<string>[],
      _weights: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<void>;

    votes(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    weights(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    whitelistNFT(
      _tokenId: PromiseOrValue<BigNumberish>,
      _bool: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    whitelistToken(
      _token: PromiseOrValue<string>,
      _bool: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    withdrawManaged(_tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
  };

  filters: {
    'Abstained(address,address,uint256,uint256,uint256,uint256)'(
      voter?: PromiseOrValue<string> | null,
      pool?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null,
      weight?: null,
      totalWeight?: null,
      timestamp?: null,
    ): AbstainedEventFilter;
    Abstained(
      voter?: PromiseOrValue<string> | null,
      pool?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null,
      weight?: null,
      totalWeight?: null,
      timestamp?: null,
    ): AbstainedEventFilter;

    'DistributeReward(address,address,uint256)'(
      sender?: PromiseOrValue<string> | null,
      gauge?: PromiseOrValue<string> | null,
      amount?: null,
    ): DistributeRewardEventFilter;
    DistributeReward(
      sender?: PromiseOrValue<string> | null,
      gauge?: PromiseOrValue<string> | null,
      amount?: null,
    ): DistributeRewardEventFilter;

    'GaugeCreated(address,address,address,address,address,address,address,address)'(
      poolFactory?: PromiseOrValue<string> | null,
      votingRewardsFactory?: PromiseOrValue<string> | null,
      gaugeFactory?: PromiseOrValue<string> | null,
      pool?: null,
      bribeVotingReward?: null,
      feeVotingReward?: null,
      gauge?: null,
      creator?: null,
    ): GaugeCreatedEventFilter;
    GaugeCreated(
      poolFactory?: PromiseOrValue<string> | null,
      votingRewardsFactory?: PromiseOrValue<string> | null,
      gaugeFactory?: PromiseOrValue<string> | null,
      pool?: null,
      bribeVotingReward?: null,
      feeVotingReward?: null,
      gauge?: null,
      creator?: null,
    ): GaugeCreatedEventFilter;

    'GaugeKilled(address)'(gauge?: PromiseOrValue<string> | null): GaugeKilledEventFilter;
    GaugeKilled(gauge?: PromiseOrValue<string> | null): GaugeKilledEventFilter;

    'GaugeRevived(address)'(gauge?: PromiseOrValue<string> | null): GaugeRevivedEventFilter;
    GaugeRevived(gauge?: PromiseOrValue<string> | null): GaugeRevivedEventFilter;

    'NotifyReward(address,address,uint256)'(
      sender?: PromiseOrValue<string> | null,
      reward?: PromiseOrValue<string> | null,
      amount?: null,
    ): NotifyRewardEventFilter;
    NotifyReward(
      sender?: PromiseOrValue<string> | null,
      reward?: PromiseOrValue<string> | null,
      amount?: null,
    ): NotifyRewardEventFilter;

    'Voted(address,address,uint256,uint256,uint256,uint256)'(
      voter?: PromiseOrValue<string> | null,
      pool?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null,
      weight?: null,
      totalWeight?: null,
      timestamp?: null,
    ): VotedEventFilter;
    Voted(
      voter?: PromiseOrValue<string> | null,
      pool?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null,
      weight?: null,
      totalWeight?: null,
      timestamp?: null,
    ): VotedEventFilter;

    'WhitelistNFT(address,uint256,bool)'(
      whitelister?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null,
      _bool?: PromiseOrValue<boolean> | null,
    ): WhitelistNFTEventFilter;
    WhitelistNFT(
      whitelister?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null,
      _bool?: PromiseOrValue<boolean> | null,
    ): WhitelistNFTEventFilter;

    'WhitelistToken(address,address,bool)'(
      whitelister?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      _bool?: PromiseOrValue<boolean> | null,
    ): WhitelistTokenEventFilter;
    WhitelistToken(
      whitelister?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      _bool?: PromiseOrValue<boolean> | null,
    ): WhitelistTokenEventFilter;
  };

  estimateGas: {
    claimBribes(
      _bribes: PromiseOrValue<string>[],
      _tokens: PromiseOrValue<string>[][],
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    claimFees(
      _fees: PromiseOrValue<string>[],
      _tokens: PromiseOrValue<string>[][],
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    claimRewards(
      _gauges: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    claimable(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    createGauge(
      _poolFactory: PromiseOrValue<string>,
      _pool: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    depositManaged(
      _tokenId: PromiseOrValue<BigNumberish>,
      _mTokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'distribute(address[])'(
      _gauges: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'distribute(uint256,uint256)'(
      _start: PromiseOrValue<BigNumberish>,
      _finish: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    emergencyCouncil(overrides?: CallOverrides): Promise<BigNumber>;

    epochGovernor(overrides?: CallOverrides): Promise<BigNumber>;

    epochNext(_timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    epochStart(_timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    epochVoteEnd(_timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    epochVoteStart(_timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    factoryRegistry(overrides?: CallOverrides): Promise<BigNumber>;

    forwarder(overrides?: CallOverrides): Promise<BigNumber>;

    gaugeToBribe(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    gaugeToFees(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    gauges(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    governor(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      _tokens: PromiseOrValue<string>[],
      _minter: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    isAlive(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    isGauge(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    isTrustedForwarder(forwarder: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    isWhitelistedNFT(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    isWhitelistedToken(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    killGauge(
      _gauge: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    lastVoted(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    length(overrides?: CallOverrides): Promise<BigNumber>;

    maxVotingNum(overrides?: CallOverrides): Promise<BigNumber>;

    minter(overrides?: CallOverrides): Promise<BigNumber>;

    notifyRewardAmount(
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    poke(
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    poolForGauge(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    poolVote(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    pools(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    reset(
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    reviveGauge(
      _gauge: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setEmergencyCouncil(
      _council: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setEpochGovernor(
      _epochGovernor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setGovernor(
      _governor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setMaxVotingNum(
      _maxVotingNum: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    totalWeight(overrides?: CallOverrides): Promise<BigNumber>;

    'updateFor(address)'(
      _gauge: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'updateFor(uint256,uint256)'(
      start: PromiseOrValue<BigNumberish>,
      end: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'updateFor(address[])'(
      _gauges: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    usedWeights(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    v1Factory(overrides?: CallOverrides): Promise<BigNumber>;

    ve(overrides?: CallOverrides): Promise<BigNumber>;

    vote(
      _tokenId: PromiseOrValue<BigNumberish>,
      _poolVote: PromiseOrValue<string>[],
      _weights: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    votes(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    weights(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    whitelistNFT(
      _tokenId: PromiseOrValue<BigNumberish>,
      _bool: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    whitelistToken(
      _token: PromiseOrValue<string>,
      _bool: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    withdrawManaged(
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    claimBribes(
      _bribes: PromiseOrValue<string>[],
      _tokens: PromiseOrValue<string>[][],
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    claimFees(
      _fees: PromiseOrValue<string>[],
      _tokens: PromiseOrValue<string>[][],
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    claimRewards(
      _gauges: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    claimable(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    createGauge(
      _poolFactory: PromiseOrValue<string>,
      _pool: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    depositManaged(
      _tokenId: PromiseOrValue<BigNumberish>,
      _mTokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'distribute(address[])'(
      _gauges: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'distribute(uint256,uint256)'(
      _start: PromiseOrValue<BigNumberish>,
      _finish: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    emergencyCouncil(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    epochGovernor(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    epochNext(_timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    epochStart(_timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    epochVoteEnd(_timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    epochVoteStart(_timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    factoryRegistry(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    forwarder(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    gaugeToBribe(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    gaugeToFees(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    gauges(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    governor(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initialize(
      _tokens: PromiseOrValue<string>[],
      _minter: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    isAlive(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isGauge(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isTrustedForwarder(forwarder: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isWhitelistedNFT(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isWhitelistedToken(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    killGauge(
      _gauge: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    lastVoted(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    length(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    maxVotingNum(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minter(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    notifyRewardAmount(
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    poke(
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    poolForGauge(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    poolVote(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    pools(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    reset(
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    reviveGauge(
      _gauge: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setEmergencyCouncil(
      _council: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setEpochGovernor(
      _epochGovernor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setGovernor(
      _governor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setMaxVotingNum(
      _maxVotingNum: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    totalWeight(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'updateFor(address)'(
      _gauge: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'updateFor(uint256,uint256)'(
      start: PromiseOrValue<BigNumberish>,
      end: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'updateFor(address[])'(
      _gauges: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    usedWeights(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    v1Factory(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ve(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    vote(
      _tokenId: PromiseOrValue<BigNumberish>,
      _poolVote: PromiseOrValue<string>[],
      _weights: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    votes(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    weights(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    whitelistNFT(
      _tokenId: PromiseOrValue<BigNumberish>,
      _bool: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    whitelistToken(
      _token: PromiseOrValue<string>,
      _bool: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    withdrawManaged(
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;
  };
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export type PrimeRateStruct = {
  supplyFactor: PromiseOrValue<BigNumberish>;
  debtFactor: PromiseOrValue<BigNumberish>;
  oracleSupplyRate: PromiseOrValue<BigNumberish>;
};

export type PrimeRateStructOutput = [BigNumber, BigNumber, BigNumber] & {
  supplyFactor: BigNumber;
  debtFactor: BigNumber;
  oracleSupplyRate: BigNumber;
};

export type PrimeCashFactorsStruct = {
  lastAccrueTime: PromiseOrValue<BigNumberish>;
  totalPrimeSupply: PromiseOrValue<BigNumberish>;
  totalPrimeDebt: PromiseOrValue<BigNumberish>;
  oracleSupplyRate: PromiseOrValue<BigNumberish>;
  lastTotalUnderlyingValue: PromiseOrValue<BigNumberish>;
  underlyingScalar: PromiseOrValue<BigNumberish>;
  supplyScalar: PromiseOrValue<BigNumberish>;
  debtScalar: PromiseOrValue<BigNumberish>;
  rateOracleTimeWindow: PromiseOrValue<BigNumberish>;
};

export type PrimeCashFactorsStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
] & {
  lastAccrueTime: BigNumber;
  totalPrimeSupply: BigNumber;
  totalPrimeDebt: BigNumber;
  oracleSupplyRate: BigNumber;
  lastTotalUnderlyingValue: BigNumber;
  underlyingScalar: BigNumber;
  supplyScalar: BigNumber;
  debtScalar: BigNumber;
  rateOracleTimeWindow: BigNumber;
};

export type BalanceActionStruct = {
  actionType: PromiseOrValue<BigNumberish>;
  currencyId: PromiseOrValue<BigNumberish>;
  depositActionAmount: PromiseOrValue<BigNumberish>;
  withdrawAmountInternalPrecision: PromiseOrValue<BigNumberish>;
  withdrawEntireCashBalance: PromiseOrValue<boolean>;
  redeemToUnderlying: PromiseOrValue<boolean>;
};

export type BalanceActionStructOutput = [number, number, BigNumber, BigNumber, boolean, boolean] & {
  actionType: number;
  currencyId: number;
  depositActionAmount: BigNumber;
  withdrawAmountInternalPrecision: BigNumber;
  withdrawEntireCashBalance: boolean;
  redeemToUnderlying: boolean;
};

export type BalanceActionWithTradesStruct = {
  actionType: PromiseOrValue<BigNumberish>;
  currencyId: PromiseOrValue<BigNumberish>;
  depositActionAmount: PromiseOrValue<BigNumberish>;
  withdrawAmountInternalPrecision: PromiseOrValue<BigNumberish>;
  withdrawEntireCashBalance: PromiseOrValue<boolean>;
  redeemToUnderlying: PromiseOrValue<boolean>;
  trades: PromiseOrValue<BytesLike>[];
};

export type BalanceActionWithTradesStructOutput = [number, number, BigNumber, BigNumber, boolean, boolean, string[]] & {
  actionType: number;
  currencyId: number;
  depositActionAmount: BigNumber;
  withdrawAmountInternalPrecision: BigNumber;
  withdrawEntireCashBalance: boolean;
  redeemToUnderlying: boolean;
  trades: string[];
};

export type BatchLendStruct = {
  currencyId: PromiseOrValue<BigNumberish>;
  depositUnderlying: PromiseOrValue<boolean>;
  trades: PromiseOrValue<BytesLike>[];
};

export type BatchLendStructOutput = [number, boolean, string[]] & {
  currencyId: number;
  depositUnderlying: boolean;
  trades: string[];
};

export type VaultAccountStruct = {
  accountDebtUnderlying: PromiseOrValue<BigNumberish>;
  maturity: PromiseOrValue<BigNumberish>;
  vaultShares: PromiseOrValue<BigNumberish>;
  account: PromiseOrValue<string>;
  tempCashBalance: PromiseOrValue<BigNumberish>;
  lastUpdateBlockTime: PromiseOrValue<BigNumberish>;
};

export type VaultAccountStructOutput = [BigNumber, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
  accountDebtUnderlying: BigNumber;
  maturity: BigNumber;
  vaultShares: BigNumber;
  account: string;
  tempCashBalance: BigNumber;
  lastUpdateBlockTime: BigNumber;
};

export type VaultConfigStruct = {
  vault: PromiseOrValue<string>;
  flags: PromiseOrValue<BigNumberish>;
  borrowCurrencyId: PromiseOrValue<BigNumberish>;
  minAccountBorrowSize: PromiseOrValue<BigNumberish>;
  feeRate: PromiseOrValue<BigNumberish>;
  minCollateralRatio: PromiseOrValue<BigNumberish>;
  liquidationRate: PromiseOrValue<BigNumberish>;
  reserveFeeShare: PromiseOrValue<BigNumberish>;
  maxBorrowMarketIndex: PromiseOrValue<BigNumberish>;
  maxDeleverageCollateralRatio: PromiseOrValue<BigNumberish>;
  secondaryBorrowCurrencies: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>];
  primeRate: PrimeRateStruct;
  maxRequiredAccountCollateralRatio: PromiseOrValue<BigNumberish>;
  minAccountSecondaryBorrow: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>];
  excessCashLiquidationBonus: PromiseOrValue<BigNumberish>;
};

export type VaultConfigStructOutput = [
  string,
  number,
  number,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  [number, number],
  PrimeRateStructOutput,
  BigNumber,
  [BigNumber, BigNumber],
  BigNumber,
] & {
  vault: string;
  flags: number;
  borrowCurrencyId: number;
  minAccountBorrowSize: BigNumber;
  feeRate: BigNumber;
  minCollateralRatio: BigNumber;
  liquidationRate: BigNumber;
  reserveFeeShare: BigNumber;
  maxBorrowMarketIndex: BigNumber;
  maxDeleverageCollateralRatio: BigNumber;
  secondaryBorrowCurrencies: [number, number];
  primeRate: PrimeRateStructOutput;
  maxRequiredAccountCollateralRatio: BigNumber;
  minAccountSecondaryBorrow: [BigNumber, BigNumber];
  excessCashLiquidationBonus: BigNumber;
};

export type VaultStateStruct = {
  maturity: PromiseOrValue<BigNumberish>;
  totalDebtUnderlying: PromiseOrValue<BigNumberish>;
  totalVaultShares: PromiseOrValue<BigNumberish>;
  isSettled: PromiseOrValue<boolean>;
};

export type VaultStateStructOutput = [BigNumber, BigNumber, BigNumber, boolean] & {
  maturity: BigNumber;
  totalDebtUnderlying: BigNumber;
  totalVaultShares: BigNumber;
  isSettled: boolean;
};

export type PortfolioAssetStruct = {
  currencyId: PromiseOrValue<BigNumberish>;
  maturity: PromiseOrValue<BigNumberish>;
  assetType: PromiseOrValue<BigNumberish>;
  notional: PromiseOrValue<BigNumberish>;
  storageSlot: PromiseOrValue<BigNumberish>;
  storageState: PromiseOrValue<BigNumberish>;
};

export type PortfolioAssetStructOutput = [number, BigNumber, BigNumber, BigNumber, BigNumber, number] & {
  currencyId: number;
  maturity: BigNumber;
  assetType: BigNumber;
  notional: BigNumber;
  storageSlot: BigNumber;
  storageState: number;
};

export type CashGroupSettingsStruct = {
  maxMarketIndex: PromiseOrValue<BigNumberish>;
  rateOracleTimeWindow5Min: PromiseOrValue<BigNumberish>;
  maxDiscountFactor5BPS: PromiseOrValue<BigNumberish>;
  reserveFeeShare: PromiseOrValue<BigNumberish>;
  debtBuffer25BPS: PromiseOrValue<BigNumberish>;
  fCashHaircut25BPS: PromiseOrValue<BigNumberish>;
  minOracleRate25BPS: PromiseOrValue<BigNumberish>;
  liquidationfCashHaircut25BPS: PromiseOrValue<BigNumberish>;
  liquidationDebtBuffer25BPS: PromiseOrValue<BigNumberish>;
  maxOracleRate25BPS: PromiseOrValue<BigNumberish>;
};

export type CashGroupSettingsStructOutput = [
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  number,
] & {
  maxMarketIndex: number;
  rateOracleTimeWindow5Min: number;
  maxDiscountFactor5BPS: number;
  reserveFeeShare: number;
  debtBuffer25BPS: number;
  fCashHaircut25BPS: number;
  minOracleRate25BPS: number;
  liquidationfCashHaircut25BPS: number;
  liquidationDebtBuffer25BPS: number;
  maxOracleRate25BPS: number;
};

export type AccountContextStruct = {
  nextSettleTime: PromiseOrValue<BigNumberish>;
  hasDebt: PromiseOrValue<BytesLike>;
  assetArrayLength: PromiseOrValue<BigNumberish>;
  bitmapCurrencyId: PromiseOrValue<BigNumberish>;
  activeCurrencies: PromiseOrValue<BytesLike>;
  allowPrimeBorrow: PromiseOrValue<boolean>;
};

export type AccountContextStructOutput = [number, string, number, number, string, boolean] & {
  nextSettleTime: number;
  hasDebt: string;
  assetArrayLength: number;
  bitmapCurrencyId: number;
  activeCurrencies: string;
  allowPrimeBorrow: boolean;
};

export type AccountBalanceStruct = {
  currencyId: PromiseOrValue<BigNumberish>;
  cashBalance: PromiseOrValue<BigNumberish>;
  nTokenBalance: PromiseOrValue<BigNumberish>;
  lastClaimTime: PromiseOrValue<BigNumberish>;
  accountIncentiveDebt: PromiseOrValue<BigNumberish>;
};

export type AccountBalanceStructOutput = [number, BigNumber, BigNumber, BigNumber, BigNumber] & {
  currencyId: number;
  cashBalance: BigNumber;
  nTokenBalance: BigNumber;
  lastClaimTime: BigNumber;
  accountIncentiveDebt: BigNumber;
};

export type MarketParametersStruct = {
  storageSlot: PromiseOrValue<BytesLike>;
  maturity: PromiseOrValue<BigNumberish>;
  totalfCash: PromiseOrValue<BigNumberish>;
  totalPrimeCash: PromiseOrValue<BigNumberish>;
  totalLiquidity: PromiseOrValue<BigNumberish>;
  lastImpliedRate: PromiseOrValue<BigNumberish>;
  oracleRate: PromiseOrValue<BigNumberish>;
  previousTradeTime: PromiseOrValue<BigNumberish>;
};

export type MarketParametersStructOutput = [
  string,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
] & {
  storageSlot: string;
  maturity: BigNumber;
  totalfCash: BigNumber;
  totalPrimeCash: BigNumber;
  totalLiquidity: BigNumber;
  lastImpliedRate: BigNumber;
  oracleRate: BigNumber;
  previousTradeTime: BigNumber;
};

export type Deprecated_AssetRateParametersStruct = {
  rateOracle: PromiseOrValue<string>;
  rate: PromiseOrValue<BigNumberish>;
  underlyingDecimals: PromiseOrValue<BigNumberish>;
};

export type Deprecated_AssetRateParametersStructOutput = [string, BigNumber, BigNumber] & {
  rateOracle: string;
  rate: BigNumber;
  underlyingDecimals: BigNumber;
};

export type TokenStruct = {
  tokenAddress: PromiseOrValue<string>;
  hasTransferFee: PromiseOrValue<boolean>;
  decimals: PromiseOrValue<BigNumberish>;
  tokenType: PromiseOrValue<BigNumberish>;
  deprecated_maxCollateralBalance: PromiseOrValue<BigNumberish>;
};

export type TokenStructOutput = [string, boolean, BigNumber, number, BigNumber] & {
  tokenAddress: string;
  hasTransferFee: boolean;
  decimals: BigNumber;
  tokenType: number;
  deprecated_maxCollateralBalance: BigNumber;
};

export type ETHRateStruct = {
  rateDecimals: PromiseOrValue<BigNumberish>;
  rate: PromiseOrValue<BigNumberish>;
  buffer: PromiseOrValue<BigNumberish>;
  haircut: PromiseOrValue<BigNumberish>;
  liquidationDiscount: PromiseOrValue<BigNumberish>;
};

export type ETHRateStructOutput = [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
  rateDecimals: BigNumber;
  rate: BigNumber;
  buffer: BigNumber;
  haircut: BigNumber;
  liquidationDiscount: BigNumber;
};

export type InterestRateParametersStruct = {
  kinkUtilization1: PromiseOrValue<BigNumberish>;
  kinkUtilization2: PromiseOrValue<BigNumberish>;
  kinkRate1: PromiseOrValue<BigNumberish>;
  kinkRate2: PromiseOrValue<BigNumberish>;
  maxRate: PromiseOrValue<BigNumberish>;
  minFeeRate: PromiseOrValue<BigNumberish>;
  maxFeeRate: PromiseOrValue<BigNumberish>;
  feeRatePercent: PromiseOrValue<BigNumberish>;
};

export type InterestRateParametersStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
] & {
  kinkUtilization1: BigNumber;
  kinkUtilization2: BigNumber;
  kinkRate1: BigNumber;
  kinkRate2: BigNumber;
  maxRate: BigNumber;
  minFeeRate: BigNumber;
  maxFeeRate: BigNumber;
  feeRatePercent: BigNumber;
};

export type ETHRateStorageStruct = {
  rateOracle: PromiseOrValue<string>;
  rateDecimalPlaces: PromiseOrValue<BigNumberish>;
  mustInvert: PromiseOrValue<boolean>;
  buffer: PromiseOrValue<BigNumberish>;
  haircut: PromiseOrValue<BigNumberish>;
  liquidationDiscount: PromiseOrValue<BigNumberish>;
};

export type ETHRateStorageStructOutput = [string, number, boolean, number, number, number] & {
  rateOracle: string;
  rateDecimalPlaces: number;
  mustInvert: boolean;
  buffer: number;
  haircut: number;
  liquidationDiscount: number;
};

export type AssetRateStorageStruct = {
  rateOracle: PromiseOrValue<string>;
  underlyingDecimalPlaces: PromiseOrValue<BigNumberish>;
};

export type AssetRateStorageStructOutput = [string, number] & {
  rateOracle: string;
  underlyingDecimalPlaces: number;
};

export type VaultAccountHealthFactorsStruct = {
  collateralRatio: PromiseOrValue<BigNumberish>;
  totalDebtOutstandingInPrimary: PromiseOrValue<BigNumberish>;
  vaultShareValueUnderlying: PromiseOrValue<BigNumberish>;
  netDebtOutstanding: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>];
};

export type VaultAccountHealthFactorsStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  [BigNumber, BigNumber, BigNumber],
] & {
  collateralRatio: BigNumber;
  totalDebtOutstandingInPrimary: BigNumber;
  vaultShareValueUnderlying: BigNumber;
  netDebtOutstanding: [BigNumber, BigNumber, BigNumber];
};

export type TokenStorageStruct = {
  tokenAddress: PromiseOrValue<string>;
  hasTransferFee: PromiseOrValue<boolean>;
  tokenType: PromiseOrValue<BigNumberish>;
  decimalPlaces: PromiseOrValue<BigNumberish>;
  deprecated_maxCollateralBalance: PromiseOrValue<BigNumberish>;
};

export type TokenStorageStructOutput = [string, boolean, number, number, BigNumber] & {
  tokenAddress: string;
  hasTransferFee: boolean;
  tokenType: number;
  decimalPlaces: number;
  deprecated_maxCollateralBalance: BigNumber;
};

export type InterestRateCurveSettingsStruct = {
  kinkUtilization1: PromiseOrValue<BigNumberish>;
  kinkUtilization2: PromiseOrValue<BigNumberish>;
  kinkRate1: PromiseOrValue<BigNumberish>;
  kinkRate2: PromiseOrValue<BigNumberish>;
  maxRateUnits: PromiseOrValue<BigNumberish>;
  minFeeRate5BPS: PromiseOrValue<BigNumberish>;
  maxFeeRate25BPS: PromiseOrValue<BigNumberish>;
  feeRatePercent: PromiseOrValue<BigNumberish>;
};

export type InterestRateCurveSettingsStructOutput = [number, number, number, number, number, number, number, number] & {
  kinkUtilization1: number;
  kinkUtilization2: number;
  kinkRate1: number;
  kinkRate2: number;
  maxRateUnits: number;
  minFeeRate5BPS: number;
  maxFeeRate25BPS: number;
  feeRatePercent: number;
};

export type VaultConfigParamsStruct = {
  flags: PromiseOrValue<BigNumberish>;
  borrowCurrencyId: PromiseOrValue<BigNumberish>;
  minAccountBorrowSize: PromiseOrValue<BigNumberish>;
  minCollateralRatioBPS: PromiseOrValue<BigNumberish>;
  feeRate5BPS: PromiseOrValue<BigNumberish>;
  liquidationRate: PromiseOrValue<BigNumberish>;
  reserveFeeShare: PromiseOrValue<BigNumberish>;
  maxBorrowMarketIndex: PromiseOrValue<BigNumberish>;
  maxDeleverageCollateralRatioBPS: PromiseOrValue<BigNumberish>;
  secondaryBorrowCurrencies: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>];
  maxRequiredAccountCollateralRatioBPS: PromiseOrValue<BigNumberish>;
  minAccountSecondaryBorrow: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>];
  excessCashLiquidationBonus: PromiseOrValue<BigNumberish>;
};

export type VaultConfigParamsStructOutput = [
  number,
  number,
  BigNumber,
  number,
  number,
  number,
  number,
  number,
  number,
  [number, number],
  number,
  [BigNumber, BigNumber],
  number,
] & {
  flags: number;
  borrowCurrencyId: number;
  minAccountBorrowSize: BigNumber;
  minCollateralRatioBPS: number;
  feeRate5BPS: number;
  liquidationRate: number;
  reserveFeeShare: number;
  maxBorrowMarketIndex: number;
  maxDeleverageCollateralRatioBPS: number;
  secondaryBorrowCurrencies: [number, number];
  maxRequiredAccountCollateralRatioBPS: number;
  minAccountSecondaryBorrow: [BigNumber, BigNumber];
  excessCashLiquidationBonus: number;
};

export declare namespace NotionalTreasury {
  export type RebalancingTargetConfigStruct = {
    holding: PromiseOrValue<string>;
    target: PromiseOrValue<BigNumberish>;
  };

  export type RebalancingTargetConfigStructOutput = [string, number] & {
    holding: string;
    target: number;
  };
}

export interface NotionalViewInterface extends utils.Interface {
  functions: {
    'accruePrimeInterest(uint16)': FunctionFragment;
    'balanceOf(address,uint256)': FunctionFragment;
    'balanceOfBatch(address[],uint256[])': FunctionFragment;
    'batchBalanceAction(address,(uint8,uint16,uint256,uint256,bool,bool)[])': FunctionFragment;
    'batchBalanceAndTradeAction(address,(uint8,uint16,uint256,uint256,bool,bool,bytes32[])[])': FunctionFragment;
    'batchBalanceAndTradeActionWithCallback(address,(uint8,uint16,uint256,uint256,bool,bool,bytes32[])[],bytes)': FunctionFragment;
    'batchLend(address,(uint16,bool,bytes32[])[])': FunctionFragment;
    'borrowSecondaryCurrencyToVault(address,uint256,uint256[2],uint32[2],uint32[2])': FunctionFragment;
    'calculateCollateralCurrencyLiquidation(address,uint16,uint16,uint128,uint96)': FunctionFragment;
    'calculateDepositAmountInDeleverage(uint256,(int256,uint256,uint256,address,int256,uint256),(address,uint16,uint16,int256,int256,int256,int256,int256,uint256,int256,uint16[2],(int256,int256,uint256),int256,int256[2],int256),(uint256,int256,uint256,bool),int256)': FunctionFragment;
    'calculateLocalCurrencyLiquidation(address,uint16,uint96)': FunctionFragment;
    'calculateNTokensToMint(uint16,uint88)': FunctionFragment;
    'calculatefCashCrossCurrencyLiquidation(address,uint16,uint16,uint256[],uint256[])': FunctionFragment;
    'calculatefCashLocalLiquidation(address,uint16,uint256[],uint256[])': FunctionFragment;
    'checkVaultAccountCollateralRatio(address,address)': FunctionFragment;
    'claimCOMPAndTransfer(address[])': FunctionFragment;
    'claimOwnership()': FunctionFragment;
    'convertCashBalanceToExternal(uint16,int256,bool)': FunctionFragment;
    'convertNTokenToUnderlying(uint16,int256)': FunctionFragment;
    'convertSettledfCash(uint16,uint256,int256,uint256)': FunctionFragment;
    'convertUnderlyingToPrimeCash(uint16,int256)': FunctionFragment;
    'decodeERC1155Id(uint256)': FunctionFragment;
    'decodeToAssets(uint256[],uint256[])': FunctionFragment;
    'deleverageAccount(address,address,address,uint16,int256)': FunctionFragment;
    'depositAssetToken(address,uint16,uint256)': FunctionFragment;
    'depositUnderlyingToken(address,uint16,uint256)': FunctionFragment;
    'enableBitmapCurrency(uint16)': FunctionFragment;
    'enableCashGroup(uint16,(uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8),string,string)': FunctionFragment;
    'enablePrimeBorrow(bool)': FunctionFragment;
    'enablePrimeDebt(uint16,string,string)': FunctionFragment;
    'encode(uint16,uint256,uint256,address,bool)': FunctionFragment;
    'encodeToId(uint16,uint40,uint8)': FunctionFragment;
    'enterVault(address,address,uint256,uint256,uint256,uint32,bytes)': FunctionFragment;
    'exitVault(address,address,address,uint256,uint256,uint32,bytes)': FunctionFragment;
    'getAccount(address)': FunctionFragment;
    'getAccountBalance(uint16,address)': FunctionFragment;
    'getAccountContext(address)': FunctionFragment;
    'getAccountPortfolio(address)': FunctionFragment;
    'getAccountPrimeDebtBalance(uint16,address)': FunctionFragment;
    'getActiveMarkets(uint16)': FunctionFragment;
    'getActiveMarketsAtBlockTime(uint16,uint32)': FunctionFragment;
    'getAssetsBitmap(address,uint16)': FunctionFragment;
    'getAuthorizedCallbackContractStatus(address)': FunctionFragment;
    'getBalanceOfPrimeCash(uint16,address)': FunctionFragment;
    'getBorrowCapacity(address,uint16)': FunctionFragment;
    'getCashAmountGivenfCashAmount(uint16,int88,uint256,uint256)': FunctionFragment;
    'getCashGroup(uint16)': FunctionFragment;
    'getCashGroupAndAssetRate(uint16)': FunctionFragment;
    'getCurrency(uint16)': FunctionFragment;
    'getCurrencyAndRates(uint16)': FunctionFragment;
    'getCurrencyId(address)': FunctionFragment;
    'getDepositFromfCashLend(uint16,uint256,uint256,uint32,uint256)': FunctionFragment;
    'getDepositParameters(uint16)': FunctionFragment;
    'getFreeCollateral(address)': FunctionFragment;
    'getGlobalTransferOperatorStatus(address)': FunctionFragment;
    'getImplementation()': FunctionFragment;
    'getInitializationParameters(uint16)': FunctionFragment;
    'getInterestRateCurve(uint16)': FunctionFragment;
    'getMarket(uint16,uint256,uint256)': FunctionFragment;
    'getMarketIndex(uint256,uint256)': FunctionFragment;
    'getMaxCurrencyId()': FunctionFragment;
    'getNTokenAccount(address)': FunctionFragment;
    'getNTokenPortfolio(address)': FunctionFragment;
    'getNoteToken()': FunctionFragment;
    'getOwnershipStatus()': FunctionFragment;
    'getPresentfCashValue(uint16,uint256,int256,uint256,bool)': FunctionFragment;
    'getPrimeCashHoldingsOracle(uint16)': FunctionFragment;
    'getPrimeFactors(uint16,uint256)': FunctionFragment;
    'getPrimeFactorsStored(uint16)': FunctionFragment;
    'getPrimeInterestRate(uint16)': FunctionFragment;
    'getPrimeInterestRateCurve(uint16)': FunctionFragment;
    'getPrincipalFromfCashBorrow(uint16,uint256,uint256,uint32,uint256)': FunctionFragment;
    'getRateStorage(uint16)': FunctionFragment;
    'getRebalancingCooldown(uint16)': FunctionFragment;
    'getRebalancingTarget(uint16,address)': FunctionFragment;
    'getReserveBalance(uint16)': FunctionFragment;
    'getReserveBuffer(uint16)': FunctionFragment;
    'getSecondaryBorrow(address,uint16,uint256)': FunctionFragment;
    'getSecondaryIncentiveRewarder(uint16)': FunctionFragment;
    'getSettlementRate(uint16,uint40)': FunctionFragment;
    'getStoredTokenBalances(address[])': FunctionFragment;
    'getTotalfCashDebtOutstanding(uint16,uint256)': FunctionFragment;
    'getTreasuryManager()': FunctionFragment;
    'getVaultAccount(address,address)': FunctionFragment;
    'getVaultAccountHealthFactors(address,address)': FunctionFragment;
    'getVaultAccountSecondaryDebt(address,address)': FunctionFragment;
    'getVaultAccountWithFeeAccrual(address,address)': FunctionFragment;
    'getVaultConfig(address)': FunctionFragment;
    'getVaultState(address,uint256)': FunctionFragment;
    'getfCashAmountGivenCashAmount(uint16,int88,uint256,uint256)': FunctionFragment;
    'getfCashBorrowFromPrincipal(uint16,uint256,uint256,uint32,uint256,bool)': FunctionFragment;
    'getfCashLendFromDeposit(uint16,uint256,uint256,uint32,uint256,bool)': FunctionFragment;
    'getfCashNotional(address,uint16,uint256)': FunctionFragment;
    'getfCashRequiredToLiquidateCash(uint16,uint256,int256)': FunctionFragment;
    'initializeMarkets(uint16,bool)': FunctionFragment;
    'isApprovedForAll(address,address)': FunctionFragment;
    'liquidateCollateralCurrency(address,uint16,uint16,uint128,uint96,bool,bool)': FunctionFragment;
    'liquidateExcessVaultCash(address,address,address,uint256,uint256,uint256)': FunctionFragment;
    'liquidateLocalCurrency(address,uint16,uint96)': FunctionFragment;
    'liquidateVaultCashBalance(address,address,address,uint256,int256)': FunctionFragment;
    'liquidatefCashCrossCurrency(address,uint16,uint16,uint256[],uint256[])': FunctionFragment;
    'liquidatefCashLocal(address,uint16,uint256[],uint256[])': FunctionFragment;
    'listCurrency((address,bool,uint8,uint8,uint72),(address,uint8,bool,uint8,uint8,uint8),(uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8),address,bool,uint8,string,string)': FunctionFragment;
    'nTokenAddress(uint16)': FunctionFragment;
    'nTokenBalanceOf(uint16,address)': FunctionFragment;
    'nTokenClaimIncentives()': FunctionFragment;
    'nTokenGetClaimableIncentives(address,uint256)': FunctionFragment;
    'nTokenPresentValueAssetDenominated(uint16)': FunctionFragment;
    'nTokenPresentValueUnderlyingDenominated(uint16)': FunctionFragment;
    'nTokenRedeem(address,uint16,uint96,bool,bool)': FunctionFragment;
    'nTokenTotalSupply(address)': FunctionFragment;
    'nTokenTransfer(uint16,address,address,uint256)': FunctionFragment;
    'nTokenTransferAllowance(uint16,address,address)': FunctionFragment;
    'nTokenTransferApprove(uint16,address,address,uint256)': FunctionFragment;
    'nTokenTransferApproveAll(address,uint256)': FunctionFragment;
    'nTokenTransferFrom(uint16,address,address,address,uint256)': FunctionFragment;
    'owner()': FunctionFragment;
    'pCashAddress(uint16)': FunctionFragment;
    'pCashTransfer(uint16,address,address,uint256)': FunctionFragment;
    'pCashTransferAllowance(uint16,address,address)': FunctionFragment;
    'pCashTransferApprove(uint16,address,address,uint256)': FunctionFragment;
    'pCashTransferFrom(uint16,address,address,address,uint256)': FunctionFragment;
    'pDebtAddress(uint16)': FunctionFragment;
    'pauseGuardian()': FunctionFragment;
    'pauseRouter()': FunctionFragment;
    'rebalance(uint16[])': FunctionFragment;
    'repaySecondaryCurrencyFromVault(address,uint256,uint256[2],uint32[2])': FunctionFragment;
    'rollVaultPosition(address,address,uint256,uint256,uint256,uint32,uint32,bytes)': FunctionFragment;
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)': FunctionFragment;
    'safeTransferFrom(address,address,uint256,uint256,bytes)': FunctionFragment;
    'setApprovalForAll(address,bool)': FunctionFragment;
    'setMaxBorrowCapacity(address,uint80)': FunctionFragment;
    'setMaxUnderlyingSupply(uint16,uint256)': FunctionFragment;
    'setPauseRouterAndGuardian(address,address)': FunctionFragment;
    'setRebalancingCooldown(uint16,uint40)': FunctionFragment;
    'setRebalancingTargets(uint16,(address,uint8)[])': FunctionFragment;
    'setReserveBuffer(uint16,uint256)': FunctionFragment;
    'setReserveCashBalance(uint16,int256)': FunctionFragment;
    'setTreasuryManager(address)': FunctionFragment;
    'setVaultDeleverageStatus(address,bool)': FunctionFragment;
    'setVaultPauseStatus(address,bool)': FunctionFragment;
    'settleAccount(address)': FunctionFragment;
    'settleSecondaryBorrowForAccount(address,address)': FunctionFragment;
    'settleVaultAccount(address,address)': FunctionFragment;
    'signedBalanceOf(address,uint256)': FunctionFragment;
    'signedBalanceOfBatch(address[],uint256[])': FunctionFragment;
    'signedBalanceOfVaultTokenId(address,uint256)': FunctionFragment;
    'supportsInterface(bytes4)': FunctionFragment;
    'sweepCashIntoMarkets(uint16)': FunctionFragment;
    'transferOwnership(address,bool)': FunctionFragment;
    'transferReserveToTreasury(uint16[])': FunctionFragment;
    'updateAuthorizedCallbackContract(address,bool)': FunctionFragment;
    'updateCashGroup(uint16,(uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8))': FunctionFragment;
    'updateDepositParameters(uint16,uint32[],uint32[])': FunctionFragment;
    'updateETHRate(uint16,address,bool,uint8,uint8,uint8)': FunctionFragment;
    'updateIncentiveEmissionRate(uint16,uint32)': FunctionFragment;
    'updateInitializationParameters(uint16,uint32[],uint32[])': FunctionFragment;
    'updateInterestRateCurve(uint16,uint8[],(uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8)[])': FunctionFragment;
    'updatePrimeCashCurve(uint16,(uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8))': FunctionFragment;
    'updatePrimeCashHoldingsOracle(uint16,address)': FunctionFragment;
    'updateSecondaryBorrowCapacity(address,uint16,uint80)': FunctionFragment;
    'updateTokenCollateralParameters(uint16,uint8,uint8,uint8,uint8,uint8)': FunctionFragment;
    'updateVault(address,(uint16,uint16,uint256,uint16,uint8,uint8,uint8,uint8,uint16,uint16[2],uint16,uint256[2],uint8),uint80)': FunctionFragment;
    'upgradeBeacon(uint8,address)': FunctionFragment;
    'upgradeTo(address)': FunctionFragment;
    'upgradeToAndCall(address,bytes)': FunctionFragment;
    'withdraw(uint16,uint88,bool)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'accruePrimeInterest'
      | 'balanceOf'
      | 'balanceOfBatch'
      | 'batchBalanceAction'
      | 'batchBalanceAndTradeAction'
      | 'batchBalanceAndTradeActionWithCallback'
      | 'batchLend'
      | 'borrowSecondaryCurrencyToVault'
      | 'calculateCollateralCurrencyLiquidation'
      | 'calculateDepositAmountInDeleverage'
      | 'calculateLocalCurrencyLiquidation'
      | 'calculateNTokensToMint'
      | 'calculatefCashCrossCurrencyLiquidation'
      | 'calculatefCashLocalLiquidation'
      | 'checkVaultAccountCollateralRatio'
      | 'claimCOMPAndTransfer'
      | 'claimOwnership'
      | 'convertCashBalanceToExternal'
      | 'convertNTokenToUnderlying'
      | 'convertSettledfCash'
      | 'convertUnderlyingToPrimeCash'
      | 'decodeERC1155Id'
      | 'decodeToAssets'
      | 'deleverageAccount'
      | 'depositAssetToken'
      | 'depositUnderlyingToken'
      | 'enableBitmapCurrency'
      | 'enableCashGroup'
      | 'enablePrimeBorrow'
      | 'enablePrimeDebt'
      | 'encode'
      | 'encodeToId'
      | 'enterVault'
      | 'exitVault'
      | 'getAccount'
      | 'getAccountBalance'
      | 'getAccountContext'
      | 'getAccountPortfolio'
      | 'getAccountPrimeDebtBalance'
      | 'getActiveMarkets'
      | 'getActiveMarketsAtBlockTime'
      | 'getAssetsBitmap'
      | 'getAuthorizedCallbackContractStatus'
      | 'getBalanceOfPrimeCash'
      | 'getBorrowCapacity'
      | 'getCashAmountGivenfCashAmount'
      | 'getCashGroup'
      | 'getCashGroupAndAssetRate'
      | 'getCurrency'
      | 'getCurrencyAndRates'
      | 'getCurrencyId'
      | 'getDepositFromfCashLend'
      | 'getDepositParameters'
      | 'getFreeCollateral'
      | 'getGlobalTransferOperatorStatus'
      | 'getImplementation'
      | 'getInitializationParameters'
      | 'getInterestRateCurve'
      | 'getMarket'
      | 'getMarketIndex'
      | 'getMaxCurrencyId'
      | 'getNTokenAccount'
      | 'getNTokenPortfolio'
      | 'getNoteToken'
      | 'getOwnershipStatus'
      | 'getPresentfCashValue'
      | 'getPrimeCashHoldingsOracle'
      | 'getPrimeFactors'
      | 'getPrimeFactorsStored'
      | 'getPrimeInterestRate'
      | 'getPrimeInterestRateCurve'
      | 'getPrincipalFromfCashBorrow'
      | 'getRateStorage'
      | 'getRebalancingCooldown'
      | 'getRebalancingTarget'
      | 'getReserveBalance'
      | 'getReserveBuffer'
      | 'getSecondaryBorrow'
      | 'getSecondaryIncentiveRewarder'
      | 'getSettlementRate'
      | 'getStoredTokenBalances'
      | 'getTotalfCashDebtOutstanding'
      | 'getTreasuryManager'
      | 'getVaultAccount'
      | 'getVaultAccountHealthFactors'
      | 'getVaultAccountSecondaryDebt'
      | 'getVaultAccountWithFeeAccrual'
      | 'getVaultConfig'
      | 'getVaultState'
      | 'getfCashAmountGivenCashAmount'
      | 'getfCashBorrowFromPrincipal'
      | 'getfCashLendFromDeposit'
      | 'getfCashNotional'
      | 'getfCashRequiredToLiquidateCash'
      | 'initializeMarkets'
      | 'isApprovedForAll'
      | 'liquidateCollateralCurrency'
      | 'liquidateExcessVaultCash'
      | 'liquidateLocalCurrency'
      | 'liquidateVaultCashBalance'
      | 'liquidatefCashCrossCurrency'
      | 'liquidatefCashLocal'
      | 'listCurrency'
      | 'nTokenAddress'
      | 'nTokenBalanceOf'
      | 'nTokenClaimIncentives'
      | 'nTokenGetClaimableIncentives'
      | 'nTokenPresentValueAssetDenominated'
      | 'nTokenPresentValueUnderlyingDenominated'
      | 'nTokenRedeem'
      | 'nTokenTotalSupply'
      | 'nTokenTransfer'
      | 'nTokenTransferAllowance'
      | 'nTokenTransferApprove'
      | 'nTokenTransferApproveAll'
      | 'nTokenTransferFrom'
      | 'owner'
      | 'pCashAddress'
      | 'pCashTransfer'
      | 'pCashTransferAllowance'
      | 'pCashTransferApprove'
      | 'pCashTransferFrom'
      | 'pDebtAddress'
      | 'pauseGuardian'
      | 'pauseRouter'
      | 'rebalance'
      | 'repaySecondaryCurrencyFromVault'
      | 'rollVaultPosition'
      | 'safeBatchTransferFrom'
      | 'safeTransferFrom'
      | 'setApprovalForAll'
      | 'setMaxBorrowCapacity'
      | 'setMaxUnderlyingSupply'
      | 'setPauseRouterAndGuardian'
      | 'setRebalancingCooldown'
      | 'setRebalancingTargets'
      | 'setReserveBuffer'
      | 'setReserveCashBalance'
      | 'setTreasuryManager'
      | 'setVaultDeleverageStatus'
      | 'setVaultPauseStatus'
      | 'settleAccount'
      | 'settleSecondaryBorrowForAccount'
      | 'settleVaultAccount'
      | 'signedBalanceOf'
      | 'signedBalanceOfBatch'
      | 'signedBalanceOfVaultTokenId'
      | 'supportsInterface'
      | 'sweepCashIntoMarkets'
      | 'transferOwnership'
      | 'transferReserveToTreasury'
      | 'updateAuthorizedCallbackContract'
      | 'updateCashGroup'
      | 'updateDepositParameters'
      | 'updateETHRate'
      | 'updateIncentiveEmissionRate'
      | 'updateInitializationParameters'
      | 'updateInterestRateCurve'
      | 'updatePrimeCashCurve'
      | 'updatePrimeCashHoldingsOracle'
      | 'updateSecondaryBorrowCapacity'
      | 'updateTokenCollateralParameters'
      | 'updateVault'
      | 'upgradeBeacon'
      | 'upgradeTo'
      | 'upgradeToAndCall'
      | 'withdraw',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'accruePrimeInterest', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'balanceOf',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'balanceOfBatch',
    values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'batchBalanceAction',
    values: [PromiseOrValue<string>, BalanceActionStruct[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'batchBalanceAndTradeAction',
    values: [PromiseOrValue<string>, BalanceActionWithTradesStruct[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'batchBalanceAndTradeActionWithCallback',
    values: [PromiseOrValue<string>, BalanceActionWithTradesStruct[], PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(functionFragment: 'batchLend', values: [PromiseOrValue<string>, BatchLendStruct[]]): string;
  encodeFunctionData(
    functionFragment: 'borrowSecondaryCurrencyToVault',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'calculateCollateralCurrencyLiquidation',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'calculateDepositAmountInDeleverage',
    values: [
      PromiseOrValue<BigNumberish>,
      VaultAccountStruct,
      VaultConfigStruct,
      VaultStateStruct,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'calculateLocalCurrencyLiquidation',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'calculateNTokensToMint',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'calculatefCashCrossCurrencyLiquidation',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'calculatefCashLocalLiquidation',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'checkVaultAccountCollateralRatio',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'claimCOMPAndTransfer', values: [PromiseOrValue<string>[]]): string;
  encodeFunctionData(functionFragment: 'claimOwnership', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'convertCashBalanceToExternal',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'convertNTokenToUnderlying',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'convertSettledfCash',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'convertUnderlyingToPrimeCash',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'decodeERC1155Id', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'decodeToAssets',
    values: [PromiseOrValue<BigNumberish>[], PromiseOrValue<BigNumberish>[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'deleverageAccount',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'depositAssetToken',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'depositUnderlyingToken',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'enableBitmapCurrency', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'enableCashGroup',
    values: [PromiseOrValue<BigNumberish>, CashGroupSettingsStruct, PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'enablePrimeBorrow', values: [PromiseOrValue<boolean>]): string;
  encodeFunctionData(
    functionFragment: 'enablePrimeDebt',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'encode',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'encodeToId',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'enterVault',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'exitVault',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'getAccount', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'getAccountBalance',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'getAccountContext', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getAccountPortfolio', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'getAccountPrimeDebtBalance',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'getActiveMarkets', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'getActiveMarketsAtBlockTime',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getAssetsBitmap',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'getAuthorizedCallbackContractStatus', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'getBalanceOfPrimeCash',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getBorrowCapacity',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getCashAmountGivenfCashAmount',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'getCashGroup', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getCashGroupAndAssetRate', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getCurrency', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getCurrencyAndRates', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getCurrencyId', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'getDepositFromfCashLend',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'getDepositParameters', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getFreeCollateral', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getGlobalTransferOperatorStatus', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getImplementation', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getInitializationParameters', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getInterestRateCurve', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'getMarket',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getMarketIndex',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'getMaxCurrencyId', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getNTokenAccount', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getNTokenPortfolio', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getNoteToken', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getOwnershipStatus', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'getPresentfCashValue',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'getPrimeCashHoldingsOracle', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'getPrimeFactors',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'getPrimeFactorsStored', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getPrimeInterestRate', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getPrimeInterestRateCurve', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'getPrincipalFromfCashBorrow',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'getRateStorage', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getRebalancingCooldown', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'getRebalancingTarget',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'getReserveBalance', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getReserveBuffer', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'getSecondaryBorrow',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'getSecondaryIncentiveRewarder', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'getSettlementRate',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'getStoredTokenBalances', values: [PromiseOrValue<string>[]]): string;
  encodeFunctionData(
    functionFragment: 'getTotalfCashDebtOutstanding',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'getTreasuryManager', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'getVaultAccount',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getVaultAccountHealthFactors',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getVaultAccountSecondaryDebt',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getVaultAccountWithFeeAccrual',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'getVaultConfig', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'getVaultState',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getfCashAmountGivenCashAmount',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'getfCashBorrowFromPrincipal',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'getfCashLendFromDeposit',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'getfCashNotional',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getfCashRequiredToLiquidateCash',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'initializeMarkets',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'isApprovedForAll',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'liquidateCollateralCurrency',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'liquidateExcessVaultCash',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'liquidateLocalCurrency',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'liquidateVaultCashBalance',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'liquidatefCashCrossCurrency',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'liquidatefCashLocal',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'listCurrency',
    values: [
      TokenStorageStruct,
      ETHRateStorageStruct,
      InterestRateCurveSettingsStruct,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'nTokenAddress', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'nTokenBalanceOf',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'nTokenClaimIncentives', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'nTokenGetClaimableIncentives',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'nTokenPresentValueAssetDenominated',
    values: [PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'nTokenPresentValueUnderlyingDenominated',
    values: [PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'nTokenRedeem',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'nTokenTotalSupply', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'nTokenTransfer',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'nTokenTransferAllowance',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'nTokenTransferApprove',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'nTokenTransferApproveAll',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'nTokenTransferFrom',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pCashAddress', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'pCashTransfer',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'pCashTransferAllowance',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'pCashTransferApprove',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'pCashTransferFrom',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'pDebtAddress', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'pauseGuardian', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pauseRouter', values?: undefined): string;
  encodeFunctionData(functionFragment: 'rebalance', values: [PromiseOrValue<BigNumberish>[]]): string;
  encodeFunctionData(
    functionFragment: 'repaySecondaryCurrencyFromVault',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'rollVaultPosition',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'safeBatchTransferFrom',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'safeTransferFrom',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'setApprovalForAll',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setMaxBorrowCapacity',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setMaxUnderlyingSupply',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setPauseRouterAndGuardian',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setRebalancingCooldown',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setRebalancingTargets',
    values: [PromiseOrValue<BigNumberish>, NotionalTreasury.RebalancingTargetConfigStruct[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'setReserveBuffer',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setReserveCashBalance',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'setTreasuryManager', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'setVaultDeleverageStatus',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setVaultPauseStatus',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'settleAccount', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'settleSecondaryBorrowForAccount',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'settleVaultAccount',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'signedBalanceOf',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'signedBalanceOfBatch',
    values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'signedBalanceOfVaultTokenId',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'supportsInterface', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(functionFragment: 'sweepCashIntoMarkets', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'transferOwnership',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'transferReserveToTreasury', values: [PromiseOrValue<BigNumberish>[]]): string;
  encodeFunctionData(
    functionFragment: 'updateAuthorizedCallbackContract',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'updateCashGroup',
    values: [PromiseOrValue<BigNumberish>, CashGroupSettingsStruct],
  ): string;
  encodeFunctionData(
    functionFragment: 'updateDepositParameters',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>[], PromiseOrValue<BigNumberish>[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'updateETHRate',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'updateIncentiveEmissionRate',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'updateInitializationParameters',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>[], PromiseOrValue<BigNumberish>[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'updateInterestRateCurve',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>[], InterestRateCurveSettingsStruct[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'updatePrimeCashCurve',
    values: [PromiseOrValue<BigNumberish>, InterestRateCurveSettingsStruct],
  ): string;
  encodeFunctionData(
    functionFragment: 'updatePrimeCashHoldingsOracle',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'updateSecondaryBorrowCapacity',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'updateTokenCollateralParameters',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'updateVault',
    values: [PromiseOrValue<string>, VaultConfigParamsStruct, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'upgradeBeacon',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'upgradeTo', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'upgradeToAndCall',
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'withdraw',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;

  decodeFunctionResult(functionFragment: 'accruePrimeInterest', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balanceOfBatch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'batchBalanceAction', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'batchBalanceAndTradeAction', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'batchBalanceAndTradeActionWithCallback', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'batchLend', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'borrowSecondaryCurrencyToVault', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'calculateCollateralCurrencyLiquidation', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'calculateDepositAmountInDeleverage', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'calculateLocalCurrencyLiquidation', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'calculateNTokensToMint', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'calculatefCashCrossCurrencyLiquidation', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'calculatefCashLocalLiquidation', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'checkVaultAccountCollateralRatio', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimCOMPAndTransfer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'convertCashBalanceToExternal', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'convertNTokenToUnderlying', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'convertSettledfCash', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'convertUnderlyingToPrimeCash', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'decodeERC1155Id', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'decodeToAssets', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deleverageAccount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'depositAssetToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'depositUnderlyingToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'enableBitmapCurrency', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'enableCashGroup', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'enablePrimeBorrow', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'enablePrimeDebt', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'encode', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'encodeToId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'enterVault', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exitVault', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getAccount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getAccountBalance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getAccountContext', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getAccountPortfolio', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getAccountPrimeDebtBalance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getActiveMarkets', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getActiveMarketsAtBlockTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getAssetsBitmap', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getAuthorizedCallbackContractStatus', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getBalanceOfPrimeCash', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getBorrowCapacity', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getCashAmountGivenfCashAmount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getCashGroup', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getCashGroupAndAssetRate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getCurrency', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getCurrencyAndRates', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getCurrencyId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getDepositFromfCashLend', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getDepositParameters', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getFreeCollateral', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getGlobalTransferOperatorStatus', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getImplementation', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getInitializationParameters', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getInterestRateCurve', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getMarket', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getMarketIndex', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getMaxCurrencyId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getNTokenAccount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getNTokenPortfolio', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getNoteToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getOwnershipStatus', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPresentfCashValue', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPrimeCashHoldingsOracle', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPrimeFactors', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPrimeFactorsStored', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPrimeInterestRate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPrimeInterestRateCurve', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPrincipalFromfCashBorrow', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getRateStorage', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getRebalancingCooldown', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getRebalancingTarget', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReserveBalance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReserveBuffer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getSecondaryBorrow', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getSecondaryIncentiveRewarder', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getSettlementRate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getStoredTokenBalances', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getTotalfCashDebtOutstanding', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getTreasuryManager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getVaultAccount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getVaultAccountHealthFactors', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getVaultAccountSecondaryDebt', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getVaultAccountWithFeeAccrual', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getVaultConfig', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getVaultState', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getfCashAmountGivenCashAmount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getfCashBorrowFromPrincipal', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getfCashLendFromDeposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getfCashNotional', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getfCashRequiredToLiquidateCash', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initializeMarkets', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isApprovedForAll', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidateCollateralCurrency', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidateExcessVaultCash', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidateLocalCurrency', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidateVaultCashBalance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidatefCashCrossCurrency', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidatefCashLocal', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'listCurrency', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nTokenAddress', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nTokenBalanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nTokenClaimIncentives', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nTokenGetClaimableIncentives', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nTokenPresentValueAssetDenominated', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nTokenPresentValueUnderlyingDenominated', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nTokenRedeem', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nTokenTotalSupply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nTokenTransfer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nTokenTransferAllowance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nTokenTransferApprove', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nTokenTransferApproveAll', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nTokenTransferFrom', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pCashAddress', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pCashTransfer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pCashTransferAllowance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pCashTransferApprove', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pCashTransferFrom', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pDebtAddress', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pauseGuardian', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pauseRouter', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rebalance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'repaySecondaryCurrencyFromVault', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rollVaultPosition', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'safeBatchTransferFrom', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'safeTransferFrom', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setApprovalForAll', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMaxBorrowCapacity', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMaxUnderlyingSupply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setPauseRouterAndGuardian', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setRebalancingCooldown', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setRebalancingTargets', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setReserveBuffer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setReserveCashBalance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setTreasuryManager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setVaultDeleverageStatus', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setVaultPauseStatus', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'settleAccount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'settleSecondaryBorrowForAccount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'settleVaultAccount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'signedBalanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'signedBalanceOfBatch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'signedBalanceOfVaultTokenId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'supportsInterface', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'sweepCashIntoMarkets', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferReserveToTreasury', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateAuthorizedCallbackContract', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateCashGroup', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateDepositParameters', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateETHRate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateIncentiveEmissionRate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateInitializationParameters', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateInterestRateCurve', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updatePrimeCashCurve', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updatePrimeCashHoldingsOracle', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateSecondaryBorrowCapacity', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateTokenCollateralParameters', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateVault', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'upgradeBeacon', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'upgradeTo', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'upgradeToAndCall', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result;

  events: {
    'AccountContextUpdate(address)': EventFragment;
    'AccountSettled(address)': EventFragment;
    'Approval(address,address,uint256)': EventFragment;
    'ApprovalForAll(address,address,bool)': EventFragment;
    'CurrencyRebalanced(uint16,uint256,uint256)': EventFragment;
    'DeployNToken(uint16,address)': EventFragment;
    'ExcessReserveBalanceHarvested(uint16,int256)': EventFragment;
    'IncentivesMigrated(uint16,uint256,uint256,uint256)': EventFragment;
    'LiquidateCollateralCurrency(address,address,uint16,uint16,int256,int256,int256)': EventFragment;
    'LiquidateLocalCurrency(address,address,uint16,int256)': EventFragment;
    'LiquidatefCashEvent(address,address,uint16,uint16,int256,uint256[],int256[])': EventFragment;
    'ListCurrency(uint16)': EventFragment;
    'MarketsInitialized(uint16)': EventFragment;
    'OwnershipTransferred(address,address)': EventFragment;
    'PauseRouterAndGuardianUpdated(address,address)': EventFragment;
    'PrimeCashCurveChanged(uint16)': EventFragment;
    'PrimeCashHoldingsOracleUpdated(uint16,address)': EventFragment;
    'PrimeCashInterestAccrued(uint16,uint256,uint256,uint256)': EventFragment;
    'PrimeProxyDeployed(uint16,address,bool)': EventFragment;
    'RebalancingCooldownUpdated(uint16,uint40)': EventFragment;
    'RebalancingTargetsUpdated(uint16,tuple[])': EventFragment;
    'ReserveBalanceUpdated(uint16,int256)': EventFragment;
    'ReserveBufferUpdated(uint16,uint256)': EventFragment;
    'SetPrimeSettlementRate(uint256,uint256,int256,int256)': EventFragment;
    'SweepCashIntoMarkets(uint16,int256)': EventFragment;
    'TokenMigrated(uint16)': EventFragment;
    'Transfer(address,address,uint256)': EventFragment;
    'TransferBatch(address,address,address,uint256[],uint256[])': EventFragment;
    'TransferSingle(address,address,address,uint256,uint256)': EventFragment;
    'TreasuryManagerChanged(address,address)': EventFragment;
    'URI(string,uint256)': EventFragment;
    'UpdateAssetRate(uint16)': EventFragment;
    'UpdateAuthorizedCallbackContract(address,bool)': EventFragment;
    'UpdateCashGroup(uint16)': EventFragment;
    'UpdateDepositParameters(uint16)': EventFragment;
    'UpdateETHRate(uint16)': EventFragment;
    'UpdateGlobalTransferOperator(address,bool)': EventFragment;
    'UpdateIncentiveEmissionRate(uint16,uint32)': EventFragment;
    'UpdateInitializationParameters(uint16)': EventFragment;
    'UpdateInterestRateCurve(uint16,uint8)': EventFragment;
    'UpdateMaxUnderlyingSupply(uint16,uint256)': EventFragment;
    'UpdateSecondaryIncentiveRewarder(uint16,address)': EventFragment;
    'UpdateTokenCollateralParameters(uint16)': EventFragment;
    'VaultAccountCashLiquidation(address,address,address,uint16,int256,int256)': EventFragment;
    'VaultBorrowCapacityChange(address,uint16,uint256)': EventFragment;
    'VaultDeleverageAccount(address,address,uint16,uint256,int256)': EventFragment;
    'VaultDeleverageStatus(address,bool)': EventFragment;
    'VaultLiquidatorProfit(address,address,address,uint256,bool)': EventFragment;
    'VaultPauseStatus(address,bool)': EventFragment;
    'VaultSecondaryTransaction(address,address,uint16,uint256,int256,int256)': EventFragment;
    'VaultUpdateSecondaryBorrowCapacity(address,uint16,uint80)': EventFragment;
    'VaultUpdated(address,bool,uint80)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'AccountContextUpdate'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'AccountSettled'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Approval'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ApprovalForAll'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CurrencyRebalanced'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'DeployNToken'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ExcessReserveBalanceHarvested'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'IncentivesMigrated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LiquidateCollateralCurrency'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LiquidateLocalCurrency'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LiquidatefCashEvent'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ListCurrency'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'MarketsInitialized'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'PauseRouterAndGuardianUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'PrimeCashCurveChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'PrimeCashHoldingsOracleUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'PrimeCashInterestAccrued'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'PrimeProxyDeployed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RebalancingCooldownUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RebalancingTargetsUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ReserveBalanceUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ReserveBufferUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SetPrimeSettlementRate'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SweepCashIntoMarkets'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TokenMigrated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Transfer'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TransferBatch'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TransferSingle'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TreasuryManagerChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'URI'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'UpdateAssetRate'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'UpdateAuthorizedCallbackContract'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'UpdateCashGroup'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'UpdateDepositParameters'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'UpdateETHRate'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'UpdateGlobalTransferOperator'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'UpdateIncentiveEmissionRate'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'UpdateInitializationParameters'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'UpdateInterestRateCurve'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'UpdateMaxUnderlyingSupply'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'UpdateSecondaryIncentiveRewarder'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'UpdateTokenCollateralParameters'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'VaultAccountCashLiquidation'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'VaultBorrowCapacityChange'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'VaultDeleverageAccount'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'VaultDeleverageStatus'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'VaultLiquidatorProfit'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'VaultPauseStatus'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'VaultSecondaryTransaction'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'VaultUpdateSecondaryBorrowCapacity'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'VaultUpdated'): EventFragment;
}

export interface AccountContextUpdateEventObject {
  account: string;
}
export type AccountContextUpdateEvent = TypedEvent<[string], AccountContextUpdateEventObject>;

export type AccountContextUpdateEventFilter = TypedEventFilter<AccountContextUpdateEvent>;

export interface AccountSettledEventObject {
  account: string;
}
export type AccountSettledEvent = TypedEvent<[string], AccountSettledEventObject>;

export type AccountSettledEventFilter = TypedEventFilter<AccountSettledEvent>;

export interface ApprovalEventObject {
  owner: string;
  spender: string;
  amount: BigNumber;
}
export type ApprovalEvent = TypedEvent<[string, string, BigNumber], ApprovalEventObject>;

export type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;

export interface ApprovalForAllEventObject {
  account: string;
  operator: string;
  approved: boolean;
}
export type ApprovalForAllEvent = TypedEvent<[string, string, boolean], ApprovalForAllEventObject>;

export type ApprovalForAllEventFilter = TypedEventFilter<ApprovalForAllEvent>;

export interface CurrencyRebalancedEventObject {
  currencyId: number;
  supplyFactor: BigNumber;
  annualizedInterestRate: BigNumber;
}
export type CurrencyRebalancedEvent = TypedEvent<[number, BigNumber, BigNumber], CurrencyRebalancedEventObject>;

export type CurrencyRebalancedEventFilter = TypedEventFilter<CurrencyRebalancedEvent>;

export interface DeployNTokenEventObject {
  currencyId: number;
  nTokenAddress: string;
}
export type DeployNTokenEvent = TypedEvent<[number, string], DeployNTokenEventObject>;

export type DeployNTokenEventFilter = TypedEventFilter<DeployNTokenEvent>;

export interface ExcessReserveBalanceHarvestedEventObject {
  currencyId: number;
  harvestAmount: BigNumber;
}
export type ExcessReserveBalanceHarvestedEvent = TypedEvent<
  [number, BigNumber],
  ExcessReserveBalanceHarvestedEventObject
>;

export type ExcessReserveBalanceHarvestedEventFilter = TypedEventFilter<ExcessReserveBalanceHarvestedEvent>;

export interface IncentivesMigratedEventObject {
  currencyId: number;
  migrationEmissionRate: BigNumber;
  finalIntegralTotalSupply: BigNumber;
  migrationTime: BigNumber;
}
export type IncentivesMigratedEvent = TypedEvent<
  [number, BigNumber, BigNumber, BigNumber],
  IncentivesMigratedEventObject
>;

export type IncentivesMigratedEventFilter = TypedEventFilter<IncentivesMigratedEvent>;

export interface LiquidateCollateralCurrencyEventObject {
  liquidated: string;
  liquidator: string;
  localCurrencyId: number;
  collateralCurrencyId: number;
  netLocalFromLiquidator: BigNumber;
  netCollateralTransfer: BigNumber;
  netNTokenTransfer: BigNumber;
}
export type LiquidateCollateralCurrencyEvent = TypedEvent<
  [string, string, number, number, BigNumber, BigNumber, BigNumber],
  LiquidateCollateralCurrencyEventObject
>;

export type LiquidateCollateralCurrencyEventFilter = TypedEventFilter<LiquidateCollateralCurrencyEvent>;

export interface LiquidateLocalCurrencyEventObject {
  liquidated: string;
  liquidator: string;
  localCurrencyId: number;
  netLocalFromLiquidator: BigNumber;
}
export type LiquidateLocalCurrencyEvent = TypedEvent<
  [string, string, number, BigNumber],
  LiquidateLocalCurrencyEventObject
>;

export type LiquidateLocalCurrencyEventFilter = TypedEventFilter<LiquidateLocalCurrencyEvent>;

export interface LiquidatefCashEventEventObject {
  liquidated: string;
  liquidator: string;
  localCurrencyId: number;
  fCashCurrency: number;
  netLocalFromLiquidator: BigNumber;
  fCashMaturities: BigNumber[];
  fCashNotionalTransfer: BigNumber[];
}
export type LiquidatefCashEventEvent = TypedEvent<
  [string, string, number, number, BigNumber, BigNumber[], BigNumber[]],
  LiquidatefCashEventEventObject
>;

export type LiquidatefCashEventEventFilter = TypedEventFilter<LiquidatefCashEventEvent>;

export interface ListCurrencyEventObject {
  newCurrencyId: number;
}
export type ListCurrencyEvent = TypedEvent<[number], ListCurrencyEventObject>;

export type ListCurrencyEventFilter = TypedEventFilter<ListCurrencyEvent>;

export interface MarketsInitializedEventObject {
  currencyId: number;
}
export type MarketsInitializedEvent = TypedEvent<[number], MarketsInitializedEventObject>;

export type MarketsInitializedEventFilter = TypedEventFilter<MarketsInitializedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<[string, string], OwnershipTransferredEventObject>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export interface PauseRouterAndGuardianUpdatedEventObject {
  pauseRouter: string;
  pauseGuardian: string;
}
export type PauseRouterAndGuardianUpdatedEvent = TypedEvent<[string, string], PauseRouterAndGuardianUpdatedEventObject>;

export type PauseRouterAndGuardianUpdatedEventFilter = TypedEventFilter<PauseRouterAndGuardianUpdatedEvent>;

export interface PrimeCashCurveChangedEventObject {
  currencyId: number;
}
export type PrimeCashCurveChangedEvent = TypedEvent<[number], PrimeCashCurveChangedEventObject>;

export type PrimeCashCurveChangedEventFilter = TypedEventFilter<PrimeCashCurveChangedEvent>;

export interface PrimeCashHoldingsOracleUpdatedEventObject {
  currencyId: number;
  oracle: string;
}
export type PrimeCashHoldingsOracleUpdatedEvent = TypedEvent<
  [number, string],
  PrimeCashHoldingsOracleUpdatedEventObject
>;

export type PrimeCashHoldingsOracleUpdatedEventFilter = TypedEventFilter<PrimeCashHoldingsOracleUpdatedEvent>;

export interface PrimeCashInterestAccruedEventObject {
  currencyId: number;
  underlyingScalar: BigNumber;
  supplyScalar: BigNumber;
  debtScalar: BigNumber;
}
export type PrimeCashInterestAccruedEvent = TypedEvent<
  [number, BigNumber, BigNumber, BigNumber],
  PrimeCashInterestAccruedEventObject
>;

export type PrimeCashInterestAccruedEventFilter = TypedEventFilter<PrimeCashInterestAccruedEvent>;

export interface PrimeProxyDeployedEventObject {
  currencyId: number;
  proxy: string;
  isCashProxy: boolean;
}
export type PrimeProxyDeployedEvent = TypedEvent<[number, string, boolean], PrimeProxyDeployedEventObject>;

export type PrimeProxyDeployedEventFilter = TypedEventFilter<PrimeProxyDeployedEvent>;

export interface RebalancingCooldownUpdatedEventObject {
  currencyId: number;
  cooldownTimeInSeconds: number;
}
export type RebalancingCooldownUpdatedEvent = TypedEvent<[number, number], RebalancingCooldownUpdatedEventObject>;

export type RebalancingCooldownUpdatedEventFilter = TypedEventFilter<RebalancingCooldownUpdatedEvent>;

export interface RebalancingTargetsUpdatedEventObject {
  currencyId: number;
  targets: NotionalTreasury.RebalancingTargetConfigStructOutput[];
}
export type RebalancingTargetsUpdatedEvent = TypedEvent<
  [number, NotionalTreasury.RebalancingTargetConfigStructOutput[]],
  RebalancingTargetsUpdatedEventObject
>;

export type RebalancingTargetsUpdatedEventFilter = TypedEventFilter<RebalancingTargetsUpdatedEvent>;

export interface ReserveBalanceUpdatedEventObject {
  currencyId: number;
  newBalance: BigNumber;
}
export type ReserveBalanceUpdatedEvent = TypedEvent<[number, BigNumber], ReserveBalanceUpdatedEventObject>;

export type ReserveBalanceUpdatedEventFilter = TypedEventFilter<ReserveBalanceUpdatedEvent>;

export interface ReserveBufferUpdatedEventObject {
  currencyId: number;
  bufferAmount: BigNumber;
}
export type ReserveBufferUpdatedEvent = TypedEvent<[number, BigNumber], ReserveBufferUpdatedEventObject>;

export type ReserveBufferUpdatedEventFilter = TypedEventFilter<ReserveBufferUpdatedEvent>;

export interface SetPrimeSettlementRateEventObject {
  currencyId: BigNumber;
  maturity: BigNumber;
  supplyFactor: BigNumber;
  debtFactor: BigNumber;
}
export type SetPrimeSettlementRateEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, BigNumber],
  SetPrimeSettlementRateEventObject
>;

export type SetPrimeSettlementRateEventFilter = TypedEventFilter<SetPrimeSettlementRateEvent>;

export interface SweepCashIntoMarketsEventObject {
  currencyId: number;
  cashIntoMarkets: BigNumber;
}
export type SweepCashIntoMarketsEvent = TypedEvent<[number, BigNumber], SweepCashIntoMarketsEventObject>;

export type SweepCashIntoMarketsEventFilter = TypedEventFilter<SweepCashIntoMarketsEvent>;

export interface TokenMigratedEventObject {
  currencyId: number;
}
export type TokenMigratedEvent = TypedEvent<[number], TokenMigratedEventObject>;

export type TokenMigratedEventFilter = TypedEventFilter<TokenMigratedEvent>;

export interface TransferEventObject {
  from: string;
  to: string;
  amount: BigNumber;
}
export type TransferEvent = TypedEvent<[string, string, BigNumber], TransferEventObject>;

export type TransferEventFilter = TypedEventFilter<TransferEvent>;

export interface TransferBatchEventObject {
  operator: string;
  from: string;
  to: string;
  ids: BigNumber[];
  values: BigNumber[];
}
export type TransferBatchEvent = TypedEvent<
  [string, string, string, BigNumber[], BigNumber[]],
  TransferBatchEventObject
>;

export type TransferBatchEventFilter = TypedEventFilter<TransferBatchEvent>;

export interface TransferSingleEventObject {
  operator: string;
  from: string;
  to: string;
  id: BigNumber;
  value: BigNumber;
}
export type TransferSingleEvent = TypedEvent<[string, string, string, BigNumber, BigNumber], TransferSingleEventObject>;

export type TransferSingleEventFilter = TypedEventFilter<TransferSingleEvent>;

export interface TreasuryManagerChangedEventObject {
  previousManager: string;
  newManager: string;
}
export type TreasuryManagerChangedEvent = TypedEvent<[string, string], TreasuryManagerChangedEventObject>;

export type TreasuryManagerChangedEventFilter = TypedEventFilter<TreasuryManagerChangedEvent>;

export interface URIEventObject {
  value: string;
  id: BigNumber;
}
export type URIEvent = TypedEvent<[string, BigNumber], URIEventObject>;

export type URIEventFilter = TypedEventFilter<URIEvent>;

export interface UpdateAssetRateEventObject {
  currencyId: number;
}
export type UpdateAssetRateEvent = TypedEvent<[number], UpdateAssetRateEventObject>;

export type UpdateAssetRateEventFilter = TypedEventFilter<UpdateAssetRateEvent>;

export interface UpdateAuthorizedCallbackContractEventObject {
  operator: string;
  approved: boolean;
}
export type UpdateAuthorizedCallbackContractEvent = TypedEvent<
  [string, boolean],
  UpdateAuthorizedCallbackContractEventObject
>;

export type UpdateAuthorizedCallbackContractEventFilter = TypedEventFilter<UpdateAuthorizedCallbackContractEvent>;

export interface UpdateCashGroupEventObject {
  currencyId: number;
}
export type UpdateCashGroupEvent = TypedEvent<[number], UpdateCashGroupEventObject>;

export type UpdateCashGroupEventFilter = TypedEventFilter<UpdateCashGroupEvent>;

export interface UpdateDepositParametersEventObject {
  currencyId: number;
}
export type UpdateDepositParametersEvent = TypedEvent<[number], UpdateDepositParametersEventObject>;

export type UpdateDepositParametersEventFilter = TypedEventFilter<UpdateDepositParametersEvent>;

export interface UpdateETHRateEventObject {
  currencyId: number;
}
export type UpdateETHRateEvent = TypedEvent<[number], UpdateETHRateEventObject>;

export type UpdateETHRateEventFilter = TypedEventFilter<UpdateETHRateEvent>;

export interface UpdateGlobalTransferOperatorEventObject {
  operator: string;
  approved: boolean;
}
export type UpdateGlobalTransferOperatorEvent = TypedEvent<[string, boolean], UpdateGlobalTransferOperatorEventObject>;

export type UpdateGlobalTransferOperatorEventFilter = TypedEventFilter<UpdateGlobalTransferOperatorEvent>;

export interface UpdateIncentiveEmissionRateEventObject {
  currencyId: number;
  newEmissionRate: number;
}
export type UpdateIncentiveEmissionRateEvent = TypedEvent<[number, number], UpdateIncentiveEmissionRateEventObject>;

export type UpdateIncentiveEmissionRateEventFilter = TypedEventFilter<UpdateIncentiveEmissionRateEvent>;

export interface UpdateInitializationParametersEventObject {
  currencyId: number;
}
export type UpdateInitializationParametersEvent = TypedEvent<[number], UpdateInitializationParametersEventObject>;

export type UpdateInitializationParametersEventFilter = TypedEventFilter<UpdateInitializationParametersEvent>;

export interface UpdateInterestRateCurveEventObject {
  currencyId: number;
  marketIndex: number;
}
export type UpdateInterestRateCurveEvent = TypedEvent<[number, number], UpdateInterestRateCurveEventObject>;

export type UpdateInterestRateCurveEventFilter = TypedEventFilter<UpdateInterestRateCurveEvent>;

export interface UpdateMaxUnderlyingSupplyEventObject {
  currencyId: number;
  maxUnderlyingSupply: BigNumber;
}
export type UpdateMaxUnderlyingSupplyEvent = TypedEvent<[number, BigNumber], UpdateMaxUnderlyingSupplyEventObject>;

export type UpdateMaxUnderlyingSupplyEventFilter = TypedEventFilter<UpdateMaxUnderlyingSupplyEvent>;

export interface UpdateSecondaryIncentiveRewarderEventObject {
  currencyId: number;
  rewarder: string;
}
export type UpdateSecondaryIncentiveRewarderEvent = TypedEvent<
  [number, string],
  UpdateSecondaryIncentiveRewarderEventObject
>;

export type UpdateSecondaryIncentiveRewarderEventFilter = TypedEventFilter<UpdateSecondaryIncentiveRewarderEvent>;

export interface UpdateTokenCollateralParametersEventObject {
  currencyId: number;
}
export type UpdateTokenCollateralParametersEvent = TypedEvent<[number], UpdateTokenCollateralParametersEventObject>;

export type UpdateTokenCollateralParametersEventFilter = TypedEventFilter<UpdateTokenCollateralParametersEvent>;

export interface VaultAccountCashLiquidationEventObject {
  vault: string;
  account: string;
  liquidator: string;
  currencyId: number;
  fCashDeposit: BigNumber;
  cashToLiquidator: BigNumber;
}
export type VaultAccountCashLiquidationEvent = TypedEvent<
  [string, string, string, number, BigNumber, BigNumber],
  VaultAccountCashLiquidationEventObject
>;

export type VaultAccountCashLiquidationEventFilter = TypedEventFilter<VaultAccountCashLiquidationEvent>;

export interface VaultBorrowCapacityChangeEventObject {
  vault: string;
  currencyId: number;
  totalUsedBorrowCapacity: BigNumber;
}
export type VaultBorrowCapacityChangeEvent = TypedEvent<
  [string, number, BigNumber],
  VaultBorrowCapacityChangeEventObject
>;

export type VaultBorrowCapacityChangeEventFilter = TypedEventFilter<VaultBorrowCapacityChangeEvent>;

export interface VaultDeleverageAccountEventObject {
  vault: string;
  account: string;
  currencyId: number;
  vaultSharesToLiquidator: BigNumber;
  depositAmountPrimeCash: BigNumber;
}
export type VaultDeleverageAccountEvent = TypedEvent<
  [string, string, number, BigNumber, BigNumber],
  VaultDeleverageAccountEventObject
>;

export type VaultDeleverageAccountEventFilter = TypedEventFilter<VaultDeleverageAccountEvent>;

export interface VaultDeleverageStatusEventObject {
  vaultAddress: string;
  disableDeleverage: boolean;
}
export type VaultDeleverageStatusEvent = TypedEvent<[string, boolean], VaultDeleverageStatusEventObject>;

export type VaultDeleverageStatusEventFilter = TypedEventFilter<VaultDeleverageStatusEvent>;

export interface VaultLiquidatorProfitEventObject {
  vault: string;
  account: string;
  liquidator: string;
  vaultSharesToLiquidator: BigNumber;
  transferSharesToLiquidator: boolean;
}
export type VaultLiquidatorProfitEvent = TypedEvent<
  [string, string, string, BigNumber, boolean],
  VaultLiquidatorProfitEventObject
>;

export type VaultLiquidatorProfitEventFilter = TypedEventFilter<VaultLiquidatorProfitEvent>;

export interface VaultPauseStatusEventObject {
  vault: string;
  enabled: boolean;
}
export type VaultPauseStatusEvent = TypedEvent<[string, boolean], VaultPauseStatusEventObject>;

export type VaultPauseStatusEventFilter = TypedEventFilter<VaultPauseStatusEvent>;

export interface VaultSecondaryTransactionEventObject {
  vault: string;
  account: string;
  currencyId: number;
  maturity: BigNumber;
  netUnderlyingDebt: BigNumber;
  netPrimeSupply: BigNumber;
}
export type VaultSecondaryTransactionEvent = TypedEvent<
  [string, string, number, BigNumber, BigNumber, BigNumber],
  VaultSecondaryTransactionEventObject
>;

export type VaultSecondaryTransactionEventFilter = TypedEventFilter<VaultSecondaryTransactionEvent>;

export interface VaultUpdateSecondaryBorrowCapacityEventObject {
  vault: string;
  currencyId: number;
  maxSecondaryBorrowCapacity: BigNumber;
}
export type VaultUpdateSecondaryBorrowCapacityEvent = TypedEvent<
  [string, number, BigNumber],
  VaultUpdateSecondaryBorrowCapacityEventObject
>;

export type VaultUpdateSecondaryBorrowCapacityEventFilter = TypedEventFilter<VaultUpdateSecondaryBorrowCapacityEvent>;

export interface VaultUpdatedEventObject {
  vault: string;
  enabled: boolean;
  maxPrimaryBorrowCapacity: BigNumber;
}
export type VaultUpdatedEvent = TypedEvent<[string, boolean, BigNumber], VaultUpdatedEventObject>;

export type VaultUpdatedEventFilter = TypedEventFilter<VaultUpdatedEvent>;

export interface NotionalView extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: NotionalViewInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    accruePrimeInterest(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    balanceOf(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    balanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<[BigNumber[]]>;

    batchBalanceAction(
      account: PromiseOrValue<string>,
      actions: BalanceActionStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    batchBalanceAndTradeAction(
      account: PromiseOrValue<string>,
      actions: BalanceActionWithTradesStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    batchBalanceAndTradeActionWithCallback(
      account: PromiseOrValue<string>,
      actions: BalanceActionWithTradesStruct[],
      callbackData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    batchLend(
      account: PromiseOrValue<string>,
      actions: BatchLendStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    borrowSecondaryCurrencyToVault(
      account: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      underlyingToBorrow: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      maxBorrowRate: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      minRollLendRate: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    calculateCollateralCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      collateralCurrency: PromiseOrValue<BigNumberish>,
      maxCollateralLiquidation: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    calculateDepositAmountInDeleverage(
      currencyIndex: PromiseOrValue<BigNumberish>,
      vaultAccount: VaultAccountStruct,
      vaultConfig: VaultConfigStruct,
      vaultState: VaultStateStruct,
      depositUnderlyingInternal: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    calculateLocalCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    calculateNTokensToMint(
      currencyId: PromiseOrValue<BigNumberish>,
      amountToDepositExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    calculatefCashCrossCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    calculatefCashLocalLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    checkVaultAccountCollateralRatio(
      vault: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    claimCOMPAndTransfer(
      ctokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    claimOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    convertCashBalanceToExternal(
      currencyId: PromiseOrValue<BigNumberish>,
      cashBalanceInternal: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    convertNTokenToUnderlying(
      currencyId: PromiseOrValue<BigNumberish>,
      nTokenBalance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    convertSettledfCash(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      fCashBalance: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { signedPrimeSupplyValue: BigNumber }>;

    convertUnderlyingToPrimeCash(
      currencyId: PromiseOrValue<BigNumberish>,
      underlyingExternal: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    decodeERC1155Id(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [number, BigNumber, BigNumber, string, boolean] & {
        currencyId: number;
        maturity: BigNumber;
        assetType: BigNumber;
        vaultAddress: string;
        isfCashDebt: boolean;
      }
    >;

    decodeToAssets(
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<[PortfolioAssetStructOutput[]]>;

    deleverageAccount(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      liquidator: PromiseOrValue<string>,
      currencyIndex: PromiseOrValue<BigNumberish>,
      depositUnderlyingInternal: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    depositAssetToken(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      amountExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    depositUnderlyingToken(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      amountExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    enableBitmapCurrency(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    enableCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      cashGroup: CashGroupSettingsStruct,
      underlyingName: PromiseOrValue<string>,
      underlyingSymbol: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    enablePrimeBorrow(
      allowPrimeBorrow: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    enablePrimeDebt(
      currencyId: PromiseOrValue<BigNumberish>,
      underlyingName: PromiseOrValue<string>,
      underlyingSymbol: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    encode(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultAddress: PromiseOrValue<string>,
      isfCashDebt: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    encodeToId(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { id: BigNumber }>;

    enterVault(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      fCash: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      vaultData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    exitVault(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      vaultSharesToRedeem: PromiseOrValue<BigNumberish>,
      fCashToLend: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      exitVaultData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    getAccount(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [AccountContextStructOutput, AccountBalanceStructOutput[], PortfolioAssetStructOutput[]] & {
        accountContext: AccountContextStructOutput;
        accountBalances: AccountBalanceStructOutput[];
        portfolio: PortfolioAssetStructOutput[];
      }
    >;

    getAccountBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        cashBalance: BigNumber;
        nTokenBalance: BigNumber;
        lastClaimTime: BigNumber;
      }
    >;

    getAccountContext(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[AccountContextStructOutput]>;

    getAccountPortfolio(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[PortfolioAssetStructOutput[]]>;

    getAccountPrimeDebtBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { debtBalance: BigNumber }>;

    getActiveMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[MarketParametersStructOutput[]]>;

    getActiveMarketsAtBlockTime(
      currencyId: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[MarketParametersStructOutput[]]>;

    getAssetsBitmap(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string]>;

    getAuthorizedCallbackContractStatus(
      callback: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean] & { isAuthorized: boolean }>;

    getBalanceOfPrimeCash(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { cashBalance: BigNumber }>;

    getBorrowCapacity(
      vault: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        currentPrimeDebtUnderlying: BigNumber;
        totalfCashDebt: BigNumber;
        maxBorrowCapacity: BigNumber;
      }
    >;

    getCashAmountGivenfCashAmount(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashAmount: PromiseOrValue<BigNumberish>,
      marketIndex: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber]>;

    getCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[CashGroupSettingsStructOutput]>;

    getCashGroupAndAssetRate(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [CashGroupSettingsStructOutput, Deprecated_AssetRateParametersStructOutput] & {
        cashGroup: CashGroupSettingsStructOutput;
        assetRate: Deprecated_AssetRateParametersStructOutput;
      }
    >;

    getCurrency(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [TokenStructOutput, TokenStructOutput] & {
        assetToken: TokenStructOutput;
        underlyingToken: TokenStructOutput;
      }
    >;

    getCurrencyAndRates(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [TokenStructOutput, TokenStructOutput, ETHRateStructOutput, Deprecated_AssetRateParametersStructOutput] & {
        assetToken: TokenStructOutput;
        underlyingToken: TokenStructOutput;
        ethRate: ETHRateStructOutput;
        assetRate: Deprecated_AssetRateParametersStructOutput;
      }
    >;

    getCurrencyId(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[number] & { currencyId: number }>;

    getDepositFromfCashLend(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashAmount: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, number, string] & {
        depositAmountUnderlying: BigNumber;
        depositAmountAsset: BigNumber;
        marketIndex: number;
        encodedTrade: string;
      }
    >;

    getDepositParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber[], BigNumber[]] & {
        depositShares: BigNumber[];
        leverageThresholds: BigNumber[];
      }
    >;

    getFreeCollateral(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber, BigNumber[]]>;

    getGlobalTransferOperatorStatus(
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean] & { isAuthorized: boolean }>;

    getImplementation(overrides?: CallOverrides): Promise<[string]>;

    getInitializationParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber[], BigNumber[]] & {
        annualizedAnchorRates: BigNumber[];
        proportions: BigNumber[];
      }
    >;

    getInterestRateCurve(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [InterestRateParametersStructOutput[], InterestRateParametersStructOutput[]] & {
        nextInterestRateCurve: InterestRateParametersStructOutput[];
        activeInterestRateCurve: InterestRateParametersStructOutput[];
      }
    >;

    getMarket(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      settlementDate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[MarketParametersStructOutput]>;

    getMarketIndex(
      maturity: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[number] & { marketIndex: number }>;

    getMaxCurrencyId(overrides?: CallOverrides): Promise<[number]>;

    getNTokenAccount(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [number, BigNumber, BigNumber, BigNumber, string, BigNumber, BigNumber, BigNumber] & {
        currencyId: number;
        totalSupply: BigNumber;
        incentiveAnnualEmissionRate: BigNumber;
        lastInitializedTime: BigNumber;
        nTokenParameters: string;
        cashBalance: BigNumber;
        accumulatedNOTEPerNToken: BigNumber;
        lastAccumulatedTime: BigNumber;
      }
    >;

    getNTokenPortfolio(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [PortfolioAssetStructOutput[], PortfolioAssetStructOutput[]] & {
        liquidityTokens: PortfolioAssetStructOutput[];
        netfCashAssets: PortfolioAssetStructOutput[];
      }
    >;

    getNoteToken(overrides?: CallOverrides): Promise<[string]>;

    getOwnershipStatus(overrides?: CallOverrides): Promise<[string, string] & { owner: string; pendingOwner: string }>;

    getPresentfCashValue(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      notional: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      riskAdjusted: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { presentValue: BigNumber }>;

    getPrimeCashHoldingsOracle(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    getPrimeFactors(
      currencyId: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [PrimeRateStructOutput, PrimeCashFactorsStructOutput, BigNumber, BigNumber] & {
        primeRate: PrimeRateStructOutput;
        factors: PrimeCashFactorsStructOutput;
        maxUnderlyingSupply: BigNumber;
        totalUnderlyingSupply: BigNumber;
      }
    >;

    getPrimeFactorsStored(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[PrimeCashFactorsStructOutput]>;

    getPrimeInterestRate(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        annualDebtRatePreFee: BigNumber;
        annualDebtRatePostFee: BigNumber;
        annualSupplyRate: BigNumber;
      }
    >;

    getPrimeInterestRateCurve(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[InterestRateParametersStructOutput]>;

    getPrincipalFromfCashBorrow(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashBorrow: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, number, string] & {
        borrowAmountUnderlying: BigNumber;
        borrowAmountAsset: BigNumber;
        marketIndex: number;
        encodedTrade: string;
      }
    >;

    getRateStorage(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [ETHRateStorageStructOutput, AssetRateStorageStructOutput] & {
        ethRate: ETHRateStorageStructOutput;
        assetRate: AssetRateStorageStructOutput;
      }
    >;

    getRebalancingCooldown(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[number]>;

    getRebalancingTarget(
      currencyId: PromiseOrValue<BigNumberish>,
      holding: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[number]>;

    getReserveBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { reserveBalance: BigNumber }>;

    getReserveBuffer(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    getSecondaryBorrow(
      vault: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { totalDebt: BigNumber }>;

    getSecondaryIncentiveRewarder(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string] & { incentiveRewarder: string }>;

    getSettlementRate(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[PrimeRateStructOutput]>;

    getStoredTokenBalances(
      tokens: PromiseOrValue<string>[],
      overrides?: CallOverrides,
    ): Promise<[BigNumber[]] & { balances: BigNumber[] }>;

    getTotalfCashDebtOutstanding(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        totalfCashDebt: BigNumber;
        fCashDebtHeldInSettlementReserve: BigNumber;
        primeCashHeldInSettlementReserve: BigNumber;
      }
    >;

    getTreasuryManager(overrides?: CallOverrides): Promise<[string]>;

    getVaultAccount(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[VaultAccountStructOutput]>;

    getVaultAccountHealthFactors(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [VaultAccountHealthFactorsStructOutput, [BigNumber, BigNumber, BigNumber], [BigNumber, BigNumber, BigNumber]] & {
        h: VaultAccountHealthFactorsStructOutput;
        maxLiquidatorDepositUnderlying: [BigNumber, BigNumber, BigNumber];
        vaultSharesToLiquidator: [BigNumber, BigNumber, BigNumber];
      }
    >;

    getVaultAccountSecondaryDebt(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, [BigNumber, BigNumber], [BigNumber, BigNumber]] & {
        maturity: BigNumber;
        accountSecondaryDebt: [BigNumber, BigNumber];
        accountSecondaryCashHeld: [BigNumber, BigNumber];
      }
    >;

    getVaultAccountWithFeeAccrual(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [VaultAccountStructOutput, BigNumber] & {
        accruedPrimeVaultFeeInUnderlying: BigNumber;
      }
    >;

    getVaultConfig(
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[VaultConfigStructOutput] & { vaultConfig: VaultConfigStructOutput }>;

    getVaultState(
      vault: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[VaultStateStructOutput] & { vaultState: VaultStateStructOutput }>;

    getfCashAmountGivenCashAmount(
      currencyId: PromiseOrValue<BigNumberish>,
      netCashToAccount: PromiseOrValue<BigNumberish>,
      marketIndex: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    getfCashBorrowFromPrincipal(
      currencyId: PromiseOrValue<BigNumberish>,
      borrowedAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, number, string] & {
        fCashDebt: BigNumber;
        marketIndex: number;
        encodedTrade: string;
      }
    >;

    getfCashLendFromDeposit(
      currencyId: PromiseOrValue<BigNumberish>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, number, string] & {
        fCashAmount: BigNumber;
        marketIndex: number;
        encodedTrade: string;
      }
    >;

    getfCashNotional(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    getfCashRequiredToLiquidateCash(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      vaultAccountCashBalance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        fCashRequired: BigNumber;
        discountFactor: BigNumber;
      }
    >;

    initializeMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      isFirstInit: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    isApprovedForAll(
      account: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    liquidateCollateralCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      collateralCurrency: PromiseOrValue<BigNumberish>,
      maxCollateralLiquidation: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      withdrawCollateral: PromiseOrValue<boolean>,
      redeemToUnderlying: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    liquidateExcessVaultCash(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      liquidator: PromiseOrValue<string>,
      excessCashIndex: PromiseOrValue<BigNumberish>,
      debtIndex: PromiseOrValue<BigNumberish>,
      _depositUnderlyingInternal: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    liquidateLocalCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    liquidateVaultCashBalance(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      liquidator: PromiseOrValue<string>,
      currencyIndex: PromiseOrValue<BigNumberish>,
      fCashDeposit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    liquidatefCashCrossCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    liquidatefCashLocal(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    listCurrency(
      underlyingToken: TokenStorageStruct,
      ethRate: ETHRateStorageStruct,
      primeDebtCurve: InterestRateCurveSettingsStruct,
      primeCashHoldingsOracle: PromiseOrValue<string>,
      allowPrimeCashDebt: PromiseOrValue<boolean>,
      rateOracleTimeWindow5Min: PromiseOrValue<BigNumberish>,
      underlyingName: PromiseOrValue<string>,
      underlyingSymbol: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    nTokenAddress(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    nTokenBalanceOf(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    nTokenClaimIncentives(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    nTokenGetClaimableIncentives(
      account: PromiseOrValue<string>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    nTokenPresentValueAssetDenominated(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    nTokenPresentValueUnderlyingDenominated(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    nTokenRedeem(
      redeemer: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      tokensToRedeem_: PromiseOrValue<BigNumberish>,
      sellTokenAssets: PromiseOrValue<boolean>,
      acceptResidualAssets: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    nTokenTotalSupply(nTokenAddress: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    nTokenTransfer(
      currencyId: PromiseOrValue<BigNumberish>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    nTokenTransferAllowance(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    nTokenTransferApprove(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    nTokenTransferApproveAll(
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    nTokenTransferFrom(
      currencyId: PromiseOrValue<BigNumberish>,
      spender: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pCashAddress(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    pCashTransfer(
      currencyId: PromiseOrValue<BigNumberish>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    pCashTransferAllowance(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    pCashTransferApprove(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    pCashTransferFrom(
      currencyId: PromiseOrValue<BigNumberish>,
      spender: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    pDebtAddress(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    pauseGuardian(overrides?: CallOverrides): Promise<[string]>;

    pauseRouter(overrides?: CallOverrides): Promise<[string]>;

    rebalance(
      currencyId: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    repaySecondaryCurrencyFromVault(
      account: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      underlyingToRepay: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      minLendRate: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    rollVaultPosition(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      fCashToBorrow: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      enterVaultData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    safeBatchTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    safeTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setMaxBorrowCapacity(
      vaultAddress: PromiseOrValue<string>,
      maxVaultBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setMaxUnderlyingSupply(
      currencyId: PromiseOrValue<BigNumberish>,
      maxUnderlyingSupply: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setPauseRouterAndGuardian(
      pauseRouter_: PromiseOrValue<string>,
      pauseGuardian_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setRebalancingCooldown(
      currencyId: PromiseOrValue<BigNumberish>,
      cooldownTimeInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setRebalancingTargets(
      currencyId: PromiseOrValue<BigNumberish>,
      targets: NotionalTreasury.RebalancingTargetConfigStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setReserveBuffer(
      currencyId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setReserveCashBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      reserveBalance: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setTreasuryManager(
      manager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setVaultDeleverageStatus(
      vaultAddress: PromiseOrValue<string>,
      disableDeleverage: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setVaultPauseStatus(
      vaultAddress: PromiseOrValue<string>,
      enable: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    settleAccount(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    settleSecondaryBorrowForAccount(
      vault: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    settleVaultAccount(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    signedBalanceOf(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    signedBalanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<[BigNumber[]]>;

    signedBalanceOfVaultTokenId(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    supportsInterface(interfaceId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[boolean]>;

    sweepCashIntoMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      direct: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    transferReserveToTreasury(
      currencies: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateAuthorizedCallbackContract(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      cashGroup: CashGroupSettingsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateDepositParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      depositShares: PromiseOrValue<BigNumberish>[],
      leverageThresholds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateETHRate(
      currencyId: PromiseOrValue<BigNumberish>,
      rateOracle: PromiseOrValue<string>,
      mustInvert: PromiseOrValue<boolean>,
      buffer: PromiseOrValue<BigNumberish>,
      haircut: PromiseOrValue<BigNumberish>,
      liquidationDiscount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateIncentiveEmissionRate(
      currencyId: PromiseOrValue<BigNumberish>,
      newEmissionRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateInitializationParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      annualizedAnchorRates: PromiseOrValue<BigNumberish>[],
      proportions: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateInterestRateCurve(
      currencyId: PromiseOrValue<BigNumberish>,
      marketIndices: PromiseOrValue<BigNumberish>[],
      settings: InterestRateCurveSettingsStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updatePrimeCashCurve(
      currencyId: PromiseOrValue<BigNumberish>,
      primeDebtCurve: InterestRateCurveSettingsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updatePrimeCashHoldingsOracle(
      currencyId: PromiseOrValue<BigNumberish>,
      primeCashHoldingsOracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateSecondaryBorrowCapacity(
      vaultAddress: PromiseOrValue<string>,
      secondaryCurrencyId: PromiseOrValue<BigNumberish>,
      maxBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateTokenCollateralParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      residualPurchaseIncentive10BPS: PromiseOrValue<BigNumberish>,
      pvHaircutPercentage: PromiseOrValue<BigNumberish>,
      residualPurchaseTimeBufferHours: PromiseOrValue<BigNumberish>,
      cashWithholdingBuffer10BPS: PromiseOrValue<BigNumberish>,
      liquidationHaircutPercentage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateVault(
      vaultAddress: PromiseOrValue<string>,
      vaultConfig: VaultConfigParamsStruct,
      maxPrimaryBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    upgradeBeacon(
      proxy: PromiseOrValue<BigNumberish>,
      newBeacon: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    withdraw(
      currencyId: PromiseOrValue<BigNumberish>,
      amountInternalPrecision: PromiseOrValue<BigNumberish>,
      redeemToUnderlying: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;
  };

  accruePrimeInterest(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  balanceOf(
    account: PromiseOrValue<string>,
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  balanceOfBatch(
    accounts: PromiseOrValue<string>[],
    ids: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides,
  ): Promise<BigNumber[]>;

  batchBalanceAction(
    account: PromiseOrValue<string>,
    actions: BalanceActionStruct[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  batchBalanceAndTradeAction(
    account: PromiseOrValue<string>,
    actions: BalanceActionWithTradesStruct[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  batchBalanceAndTradeActionWithCallback(
    account: PromiseOrValue<string>,
    actions: BalanceActionWithTradesStruct[],
    callbackData: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  batchLend(
    account: PromiseOrValue<string>,
    actions: BatchLendStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  borrowSecondaryCurrencyToVault(
    account: PromiseOrValue<string>,
    maturity: PromiseOrValue<BigNumberish>,
    underlyingToBorrow: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    maxBorrowRate: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    minRollLendRate: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  calculateCollateralCurrencyLiquidation(
    liquidateAccount: PromiseOrValue<string>,
    localCurrency: PromiseOrValue<BigNumberish>,
    collateralCurrency: PromiseOrValue<BigNumberish>,
    maxCollateralLiquidation: PromiseOrValue<BigNumberish>,
    maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  calculateDepositAmountInDeleverage(
    currencyIndex: PromiseOrValue<BigNumberish>,
    vaultAccount: VaultAccountStruct,
    vaultConfig: VaultConfigStruct,
    vaultState: VaultStateStruct,
    depositUnderlyingInternal: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  calculateLocalCurrencyLiquidation(
    liquidateAccount: PromiseOrValue<string>,
    localCurrency: PromiseOrValue<BigNumberish>,
    maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  calculateNTokensToMint(
    currencyId: PromiseOrValue<BigNumberish>,
    amountToDepositExternalPrecision: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  calculatefCashCrossCurrencyLiquidation(
    liquidateAccount: PromiseOrValue<string>,
    localCurrency: PromiseOrValue<BigNumberish>,
    fCashCurrency: PromiseOrValue<BigNumberish>,
    fCashMaturities: PromiseOrValue<BigNumberish>[],
    maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  calculatefCashLocalLiquidation(
    liquidateAccount: PromiseOrValue<string>,
    localCurrency: PromiseOrValue<BigNumberish>,
    fCashMaturities: PromiseOrValue<BigNumberish>[],
    maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  checkVaultAccountCollateralRatio(
    vault: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  claimCOMPAndTransfer(
    ctokens: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  claimOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  convertCashBalanceToExternal(
    currencyId: PromiseOrValue<BigNumberish>,
    cashBalanceInternal: PromiseOrValue<BigNumberish>,
    useUnderlying: PromiseOrValue<boolean>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  convertNTokenToUnderlying(
    currencyId: PromiseOrValue<BigNumberish>,
    nTokenBalance: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  convertSettledfCash(
    currencyId: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    fCashBalance: PromiseOrValue<BigNumberish>,
    blockTime: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  convertUnderlyingToPrimeCash(
    currencyId: PromiseOrValue<BigNumberish>,
    underlyingExternal: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  decodeERC1155Id(
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [number, BigNumber, BigNumber, string, boolean] & {
      currencyId: number;
      maturity: BigNumber;
      assetType: BigNumber;
      vaultAddress: string;
      isfCashDebt: boolean;
    }
  >;

  decodeToAssets(
    ids: PromiseOrValue<BigNumberish>[],
    amounts: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides,
  ): Promise<PortfolioAssetStructOutput[]>;

  deleverageAccount(
    account: PromiseOrValue<string>,
    vault: PromiseOrValue<string>,
    liquidator: PromiseOrValue<string>,
    currencyIndex: PromiseOrValue<BigNumberish>,
    depositUnderlyingInternal: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  depositAssetToken(
    account: PromiseOrValue<string>,
    currencyId: PromiseOrValue<BigNumberish>,
    amountExternalPrecision: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  depositUnderlyingToken(
    account: PromiseOrValue<string>,
    currencyId: PromiseOrValue<BigNumberish>,
    amountExternalPrecision: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  enableBitmapCurrency(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  enableCashGroup(
    currencyId: PromiseOrValue<BigNumberish>,
    cashGroup: CashGroupSettingsStruct,
    underlyingName: PromiseOrValue<string>,
    underlyingSymbol: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  enablePrimeBorrow(
    allowPrimeBorrow: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  enablePrimeDebt(
    currencyId: PromiseOrValue<BigNumberish>,
    underlyingName: PromiseOrValue<string>,
    underlyingSymbol: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  encode(
    currencyId: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    assetType: PromiseOrValue<BigNumberish>,
    vaultAddress: PromiseOrValue<string>,
    isfCashDebt: PromiseOrValue<boolean>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  encodeToId(
    currencyId: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    assetType: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  enterVault(
    account: PromiseOrValue<string>,
    vault: PromiseOrValue<string>,
    depositAmountExternal: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    fCash: PromiseOrValue<BigNumberish>,
    maxBorrowRate: PromiseOrValue<BigNumberish>,
    vaultData: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  exitVault(
    account: PromiseOrValue<string>,
    vault: PromiseOrValue<string>,
    receiver: PromiseOrValue<string>,
    vaultSharesToRedeem: PromiseOrValue<BigNumberish>,
    fCashToLend: PromiseOrValue<BigNumberish>,
    minLendRate: PromiseOrValue<BigNumberish>,
    exitVaultData: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  getAccount(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [AccountContextStructOutput, AccountBalanceStructOutput[], PortfolioAssetStructOutput[]] & {
      accountContext: AccountContextStructOutput;
      accountBalances: AccountBalanceStructOutput[];
      portfolio: PortfolioAssetStructOutput[];
    }
  >;

  getAccountBalance(
    currencyId: PromiseOrValue<BigNumberish>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      cashBalance: BigNumber;
      nTokenBalance: BigNumber;
      lastClaimTime: BigNumber;
    }
  >;

  getAccountContext(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<AccountContextStructOutput>;

  getAccountPortfolio(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<PortfolioAssetStructOutput[]>;

  getAccountPrimeDebtBalance(
    currencyId: PromiseOrValue<BigNumberish>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  getActiveMarkets(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<MarketParametersStructOutput[]>;

  getActiveMarketsAtBlockTime(
    currencyId: PromiseOrValue<BigNumberish>,
    blockTime: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<MarketParametersStructOutput[]>;

  getAssetsBitmap(
    account: PromiseOrValue<string>,
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<string>;

  getAuthorizedCallbackContractStatus(callback: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  getBalanceOfPrimeCash(
    currencyId: PromiseOrValue<BigNumberish>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  getBorrowCapacity(
    vault: PromiseOrValue<string>,
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      currentPrimeDebtUnderlying: BigNumber;
      totalfCashDebt: BigNumber;
      maxBorrowCapacity: BigNumber;
    }
  >;

  getCashAmountGivenfCashAmount(
    currencyId: PromiseOrValue<BigNumberish>,
    fCashAmount: PromiseOrValue<BigNumberish>,
    marketIndex: PromiseOrValue<BigNumberish>,
    blockTime: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, BigNumber]>;

  getCashGroup(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<CashGroupSettingsStructOutput>;

  getCashGroupAndAssetRate(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [CashGroupSettingsStructOutput, Deprecated_AssetRateParametersStructOutput] & {
      cashGroup: CashGroupSettingsStructOutput;
      assetRate: Deprecated_AssetRateParametersStructOutput;
    }
  >;

  getCurrency(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [TokenStructOutput, TokenStructOutput] & {
      assetToken: TokenStructOutput;
      underlyingToken: TokenStructOutput;
    }
  >;

  getCurrencyAndRates(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [TokenStructOutput, TokenStructOutput, ETHRateStructOutput, Deprecated_AssetRateParametersStructOutput] & {
      assetToken: TokenStructOutput;
      underlyingToken: TokenStructOutput;
      ethRate: ETHRateStructOutput;
      assetRate: Deprecated_AssetRateParametersStructOutput;
    }
  >;

  getCurrencyId(tokenAddress: PromiseOrValue<string>, overrides?: CallOverrides): Promise<number>;

  getDepositFromfCashLend(
    currencyId: PromiseOrValue<BigNumberish>,
    fCashAmount: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    minLendRate: PromiseOrValue<BigNumberish>,
    blockTime: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, number, string] & {
      depositAmountUnderlying: BigNumber;
      depositAmountAsset: BigNumber;
      marketIndex: number;
      encodedTrade: string;
    }
  >;

  getDepositParameters(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber[], BigNumber[]] & {
      depositShares: BigNumber[];
      leverageThresholds: BigNumber[];
    }
  >;

  getFreeCollateral(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber, BigNumber[]]>;

  getGlobalTransferOperatorStatus(operator: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  getImplementation(overrides?: CallOverrides): Promise<string>;

  getInitializationParameters(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber[], BigNumber[]] & {
      annualizedAnchorRates: BigNumber[];
      proportions: BigNumber[];
    }
  >;

  getInterestRateCurve(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [InterestRateParametersStructOutput[], InterestRateParametersStructOutput[]] & {
      nextInterestRateCurve: InterestRateParametersStructOutput[];
      activeInterestRateCurve: InterestRateParametersStructOutput[];
    }
  >;

  getMarket(
    currencyId: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    settlementDate: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<MarketParametersStructOutput>;

  getMarketIndex(
    maturity: PromiseOrValue<BigNumberish>,
    blockTime: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<number>;

  getMaxCurrencyId(overrides?: CallOverrides): Promise<number>;

  getNTokenAccount(
    tokenAddress: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [number, BigNumber, BigNumber, BigNumber, string, BigNumber, BigNumber, BigNumber] & {
      currencyId: number;
      totalSupply: BigNumber;
      incentiveAnnualEmissionRate: BigNumber;
      lastInitializedTime: BigNumber;
      nTokenParameters: string;
      cashBalance: BigNumber;
      accumulatedNOTEPerNToken: BigNumber;
      lastAccumulatedTime: BigNumber;
    }
  >;

  getNTokenPortfolio(
    tokenAddress: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [PortfolioAssetStructOutput[], PortfolioAssetStructOutput[]] & {
      liquidityTokens: PortfolioAssetStructOutput[];
      netfCashAssets: PortfolioAssetStructOutput[];
    }
  >;

  getNoteToken(overrides?: CallOverrides): Promise<string>;

  getOwnershipStatus(overrides?: CallOverrides): Promise<[string, string] & { owner: string; pendingOwner: string }>;

  getPresentfCashValue(
    currencyId: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    notional: PromiseOrValue<BigNumberish>,
    blockTime: PromiseOrValue<BigNumberish>,
    riskAdjusted: PromiseOrValue<boolean>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  getPrimeCashHoldingsOracle(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  getPrimeFactors(
    currencyId: PromiseOrValue<BigNumberish>,
    blockTime: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [PrimeRateStructOutput, PrimeCashFactorsStructOutput, BigNumber, BigNumber] & {
      primeRate: PrimeRateStructOutput;
      factors: PrimeCashFactorsStructOutput;
      maxUnderlyingSupply: BigNumber;
      totalUnderlyingSupply: BigNumber;
    }
  >;

  getPrimeFactorsStored(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<PrimeCashFactorsStructOutput>;

  getPrimeInterestRate(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      annualDebtRatePreFee: BigNumber;
      annualDebtRatePostFee: BigNumber;
      annualSupplyRate: BigNumber;
    }
  >;

  getPrimeInterestRateCurve(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<InterestRateParametersStructOutput>;

  getPrincipalFromfCashBorrow(
    currencyId: PromiseOrValue<BigNumberish>,
    fCashBorrow: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    maxBorrowRate: PromiseOrValue<BigNumberish>,
    blockTime: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, number, string] & {
      borrowAmountUnderlying: BigNumber;
      borrowAmountAsset: BigNumber;
      marketIndex: number;
      encodedTrade: string;
    }
  >;

  getRateStorage(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [ETHRateStorageStructOutput, AssetRateStorageStructOutput] & {
      ethRate: ETHRateStorageStructOutput;
      assetRate: AssetRateStorageStructOutput;
    }
  >;

  getRebalancingCooldown(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<number>;

  getRebalancingTarget(
    currencyId: PromiseOrValue<BigNumberish>,
    holding: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<number>;

  getReserveBalance(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  getReserveBuffer(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  getSecondaryBorrow(
    vault: PromiseOrValue<string>,
    currencyId: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  getSecondaryIncentiveRewarder(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  getSettlementRate(
    currencyId: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<PrimeRateStructOutput>;

  getStoredTokenBalances(tokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber[]>;

  getTotalfCashDebtOutstanding(
    currencyId: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      totalfCashDebt: BigNumber;
      fCashDebtHeldInSettlementReserve: BigNumber;
      primeCashHeldInSettlementReserve: BigNumber;
    }
  >;

  getTreasuryManager(overrides?: CallOverrides): Promise<string>;

  getVaultAccount(
    account: PromiseOrValue<string>,
    vault: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<VaultAccountStructOutput>;

  getVaultAccountHealthFactors(
    account: PromiseOrValue<string>,
    vault: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [VaultAccountHealthFactorsStructOutput, [BigNumber, BigNumber, BigNumber], [BigNumber, BigNumber, BigNumber]] & {
      h: VaultAccountHealthFactorsStructOutput;
      maxLiquidatorDepositUnderlying: [BigNumber, BigNumber, BigNumber];
      vaultSharesToLiquidator: [BigNumber, BigNumber, BigNumber];
    }
  >;

  getVaultAccountSecondaryDebt(
    account: PromiseOrValue<string>,
    vault: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, [BigNumber, BigNumber], [BigNumber, BigNumber]] & {
      maturity: BigNumber;
      accountSecondaryDebt: [BigNumber, BigNumber];
      accountSecondaryCashHeld: [BigNumber, BigNumber];
    }
  >;

  getVaultAccountWithFeeAccrual(
    account: PromiseOrValue<string>,
    vault: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [VaultAccountStructOutput, BigNumber] & {
      accruedPrimeVaultFeeInUnderlying: BigNumber;
    }
  >;

  getVaultConfig(vault: PromiseOrValue<string>, overrides?: CallOverrides): Promise<VaultConfigStructOutput>;

  getVaultState(
    vault: PromiseOrValue<string>,
    maturity: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<VaultStateStructOutput>;

  getfCashAmountGivenCashAmount(
    currencyId: PromiseOrValue<BigNumberish>,
    netCashToAccount: PromiseOrValue<BigNumberish>,
    marketIndex: PromiseOrValue<BigNumberish>,
    blockTime: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  getfCashBorrowFromPrincipal(
    currencyId: PromiseOrValue<BigNumberish>,
    borrowedAmountExternal: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    maxBorrowRate: PromiseOrValue<BigNumberish>,
    blockTime: PromiseOrValue<BigNumberish>,
    useUnderlying: PromiseOrValue<boolean>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, number, string] & {
      fCashDebt: BigNumber;
      marketIndex: number;
      encodedTrade: string;
    }
  >;

  getfCashLendFromDeposit(
    currencyId: PromiseOrValue<BigNumberish>,
    depositAmountExternal: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    minLendRate: PromiseOrValue<BigNumberish>,
    blockTime: PromiseOrValue<BigNumberish>,
    useUnderlying: PromiseOrValue<boolean>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, number, string] & {
      fCashAmount: BigNumber;
      marketIndex: number;
      encodedTrade: string;
    }
  >;

  getfCashNotional(
    account: PromiseOrValue<string>,
    currencyId: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  getfCashRequiredToLiquidateCash(
    currencyId: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    vaultAccountCashBalance: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber] & {
      fCashRequired: BigNumber;
      discountFactor: BigNumber;
    }
  >;

  initializeMarkets(
    currencyId: PromiseOrValue<BigNumberish>,
    isFirstInit: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  isApprovedForAll(
    account: PromiseOrValue<string>,
    operator: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  liquidateCollateralCurrency(
    liquidateAccount: PromiseOrValue<string>,
    localCurrency: PromiseOrValue<BigNumberish>,
    collateralCurrency: PromiseOrValue<BigNumberish>,
    maxCollateralLiquidation: PromiseOrValue<BigNumberish>,
    maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
    withdrawCollateral: PromiseOrValue<boolean>,
    redeemToUnderlying: PromiseOrValue<boolean>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  liquidateExcessVaultCash(
    account: PromiseOrValue<string>,
    vault: PromiseOrValue<string>,
    liquidator: PromiseOrValue<string>,
    excessCashIndex: PromiseOrValue<BigNumberish>,
    debtIndex: PromiseOrValue<BigNumberish>,
    _depositUnderlyingInternal: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  liquidateLocalCurrency(
    liquidateAccount: PromiseOrValue<string>,
    localCurrency: PromiseOrValue<BigNumberish>,
    maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  liquidateVaultCashBalance(
    account: PromiseOrValue<string>,
    vault: PromiseOrValue<string>,
    liquidator: PromiseOrValue<string>,
    currencyIndex: PromiseOrValue<BigNumberish>,
    fCashDeposit: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  liquidatefCashCrossCurrency(
    liquidateAccount: PromiseOrValue<string>,
    localCurrency: PromiseOrValue<BigNumberish>,
    fCashCurrency: PromiseOrValue<BigNumberish>,
    fCashMaturities: PromiseOrValue<BigNumberish>[],
    maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  liquidatefCashLocal(
    liquidateAccount: PromiseOrValue<string>,
    localCurrency: PromiseOrValue<BigNumberish>,
    fCashMaturities: PromiseOrValue<BigNumberish>[],
    maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  listCurrency(
    underlyingToken: TokenStorageStruct,
    ethRate: ETHRateStorageStruct,
    primeDebtCurve: InterestRateCurveSettingsStruct,
    primeCashHoldingsOracle: PromiseOrValue<string>,
    allowPrimeCashDebt: PromiseOrValue<boolean>,
    rateOracleTimeWindow5Min: PromiseOrValue<BigNumberish>,
    underlyingName: PromiseOrValue<string>,
    underlyingSymbol: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  nTokenAddress(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  nTokenBalanceOf(
    currencyId: PromiseOrValue<BigNumberish>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  nTokenClaimIncentives(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  nTokenGetClaimableIncentives(
    account: PromiseOrValue<string>,
    blockTime: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  nTokenPresentValueAssetDenominated(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  nTokenPresentValueUnderlyingDenominated(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  nTokenRedeem(
    redeemer: PromiseOrValue<string>,
    currencyId: PromiseOrValue<BigNumberish>,
    tokensToRedeem_: PromiseOrValue<BigNumberish>,
    sellTokenAssets: PromiseOrValue<boolean>,
    acceptResidualAssets: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  nTokenTotalSupply(nTokenAddress: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  nTokenTransfer(
    currencyId: PromiseOrValue<BigNumberish>,
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  nTokenTransferAllowance(
    currencyId: PromiseOrValue<BigNumberish>,
    owner: PromiseOrValue<string>,
    spender: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  nTokenTransferApprove(
    currencyId: PromiseOrValue<BigNumberish>,
    owner: PromiseOrValue<string>,
    spender: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  nTokenTransferApproveAll(
    spender: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  nTokenTransferFrom(
    currencyId: PromiseOrValue<BigNumberish>,
    spender: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  pCashAddress(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  pCashTransfer(
    currencyId: PromiseOrValue<BigNumberish>,
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  pCashTransferAllowance(
    currencyId: PromiseOrValue<BigNumberish>,
    owner: PromiseOrValue<string>,
    spender: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  pCashTransferApprove(
    currencyId: PromiseOrValue<BigNumberish>,
    owner: PromiseOrValue<string>,
    spender: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  pCashTransferFrom(
    currencyId: PromiseOrValue<BigNumberish>,
    spender: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  pDebtAddress(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  pauseGuardian(overrides?: CallOverrides): Promise<string>;

  pauseRouter(overrides?: CallOverrides): Promise<string>;

  rebalance(
    currencyId: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  repaySecondaryCurrencyFromVault(
    account: PromiseOrValue<string>,
    maturity: PromiseOrValue<BigNumberish>,
    underlyingToRepay: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    minLendRate: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  rollVaultPosition(
    account: PromiseOrValue<string>,
    vault: PromiseOrValue<string>,
    fCashToBorrow: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    depositAmountExternal: PromiseOrValue<BigNumberish>,
    minLendRate: PromiseOrValue<BigNumberish>,
    maxBorrowRate: PromiseOrValue<BigNumberish>,
    enterVaultData: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  safeBatchTransferFrom(
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    ids: PromiseOrValue<BigNumberish>[],
    amounts: PromiseOrValue<BigNumberish>[],
    data: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  safeTransferFrom(
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    id: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    data: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setApprovalForAll(
    operator: PromiseOrValue<string>,
    approved: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setMaxBorrowCapacity(
    vaultAddress: PromiseOrValue<string>,
    maxVaultBorrowCapacity: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setMaxUnderlyingSupply(
    currencyId: PromiseOrValue<BigNumberish>,
    maxUnderlyingSupply: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setPauseRouterAndGuardian(
    pauseRouter_: PromiseOrValue<string>,
    pauseGuardian_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setRebalancingCooldown(
    currencyId: PromiseOrValue<BigNumberish>,
    cooldownTimeInSeconds: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setRebalancingTargets(
    currencyId: PromiseOrValue<BigNumberish>,
    targets: NotionalTreasury.RebalancingTargetConfigStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setReserveBuffer(
    currencyId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setReserveCashBalance(
    currencyId: PromiseOrValue<BigNumberish>,
    reserveBalance: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setTreasuryManager(
    manager: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setVaultDeleverageStatus(
    vaultAddress: PromiseOrValue<string>,
    disableDeleverage: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setVaultPauseStatus(
    vaultAddress: PromiseOrValue<string>,
    enable: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  settleAccount(
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  settleSecondaryBorrowForAccount(
    vault: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  settleVaultAccount(
    account: PromiseOrValue<string>,
    vault: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  signedBalanceOf(
    account: PromiseOrValue<string>,
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  signedBalanceOfBatch(
    accounts: PromiseOrValue<string>[],
    ids: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides,
  ): Promise<BigNumber[]>;

  signedBalanceOfVaultTokenId(
    account: PromiseOrValue<string>,
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  supportsInterface(interfaceId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;

  sweepCashIntoMarkets(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    direct: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  transferReserveToTreasury(
    currencies: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateAuthorizedCallbackContract(
    operator: PromiseOrValue<string>,
    approved: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateCashGroup(
    currencyId: PromiseOrValue<BigNumberish>,
    cashGroup: CashGroupSettingsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateDepositParameters(
    currencyId: PromiseOrValue<BigNumberish>,
    depositShares: PromiseOrValue<BigNumberish>[],
    leverageThresholds: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateETHRate(
    currencyId: PromiseOrValue<BigNumberish>,
    rateOracle: PromiseOrValue<string>,
    mustInvert: PromiseOrValue<boolean>,
    buffer: PromiseOrValue<BigNumberish>,
    haircut: PromiseOrValue<BigNumberish>,
    liquidationDiscount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateIncentiveEmissionRate(
    currencyId: PromiseOrValue<BigNumberish>,
    newEmissionRate: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateInitializationParameters(
    currencyId: PromiseOrValue<BigNumberish>,
    annualizedAnchorRates: PromiseOrValue<BigNumberish>[],
    proportions: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateInterestRateCurve(
    currencyId: PromiseOrValue<BigNumberish>,
    marketIndices: PromiseOrValue<BigNumberish>[],
    settings: InterestRateCurveSettingsStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updatePrimeCashCurve(
    currencyId: PromiseOrValue<BigNumberish>,
    primeDebtCurve: InterestRateCurveSettingsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updatePrimeCashHoldingsOracle(
    currencyId: PromiseOrValue<BigNumberish>,
    primeCashHoldingsOracle: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateSecondaryBorrowCapacity(
    vaultAddress: PromiseOrValue<string>,
    secondaryCurrencyId: PromiseOrValue<BigNumberish>,
    maxBorrowCapacity: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateTokenCollateralParameters(
    currencyId: PromiseOrValue<BigNumberish>,
    residualPurchaseIncentive10BPS: PromiseOrValue<BigNumberish>,
    pvHaircutPercentage: PromiseOrValue<BigNumberish>,
    residualPurchaseTimeBufferHours: PromiseOrValue<BigNumberish>,
    cashWithholdingBuffer10BPS: PromiseOrValue<BigNumberish>,
    liquidationHaircutPercentage: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateVault(
    vaultAddress: PromiseOrValue<string>,
    vaultConfig: VaultConfigParamsStruct,
    maxPrimaryBorrowCapacity: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  upgradeBeacon(
    proxy: PromiseOrValue<BigNumberish>,
    newBeacon: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  upgradeTo(
    newImplementation: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  upgradeToAndCall(
    newImplementation: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  withdraw(
    currencyId: PromiseOrValue<BigNumberish>,
    amountInternalPrecision: PromiseOrValue<BigNumberish>,
    redeemToUnderlying: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    accruePrimeInterest(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [PrimeRateStructOutput, PrimeCashFactorsStructOutput] & {
        pr: PrimeRateStructOutput;
      }
    >;

    balanceOf(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    balanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<BigNumber[]>;

    batchBalanceAction(
      account: PromiseOrValue<string>,
      actions: BalanceActionStruct[],
      overrides?: CallOverrides,
    ): Promise<void>;

    batchBalanceAndTradeAction(
      account: PromiseOrValue<string>,
      actions: BalanceActionWithTradesStruct[],
      overrides?: CallOverrides,
    ): Promise<void>;

    batchBalanceAndTradeActionWithCallback(
      account: PromiseOrValue<string>,
      actions: BalanceActionWithTradesStruct[],
      callbackData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    batchLend(account: PromiseOrValue<string>, actions: BatchLendStruct[], overrides?: CallOverrides): Promise<void>;

    borrowSecondaryCurrencyToVault(
      account: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      underlyingToBorrow: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      maxBorrowRate: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      minRollLendRate: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber]>;

    calculateCollateralCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      collateralCurrency: PromiseOrValue<BigNumberish>,
      maxCollateralLiquidation: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber, BigNumber]>;

    calculateDepositAmountInDeleverage(
      currencyIndex: PromiseOrValue<BigNumberish>,
      vaultAccount: VaultAccountStruct,
      vaultConfig: VaultConfigStruct,
      vaultState: VaultStateStruct,
      depositUnderlyingInternal: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, PrimeRateStructOutput] & {
        depositInternal: BigNumber;
        vaultSharesToLiquidator: BigNumber;
      }
    >;

    calculateLocalCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber]>;

    calculateNTokensToMint(
      currencyId: PromiseOrValue<BigNumberish>,
      amountToDepositExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    calculatefCashCrossCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<[BigNumber[], BigNumber]>;

    calculatefCashLocalLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<[BigNumber[], BigNumber]>;

    checkVaultAccountCollateralRatio(
      vault: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    claimCOMPAndTransfer(ctokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber>;

    claimOwnership(overrides?: CallOverrides): Promise<void>;

    convertCashBalanceToExternal(
      currencyId: PromiseOrValue<BigNumberish>,
      cashBalanceInternal: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    convertNTokenToUnderlying(
      currencyId: PromiseOrValue<BigNumberish>,
      nTokenBalance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    convertSettledfCash(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      fCashBalance: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    convertUnderlyingToPrimeCash(
      currencyId: PromiseOrValue<BigNumberish>,
      underlyingExternal: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    decodeERC1155Id(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [number, BigNumber, BigNumber, string, boolean] & {
        currencyId: number;
        maturity: BigNumber;
        assetType: BigNumber;
        vaultAddress: string;
        isfCashDebt: boolean;
      }
    >;

    decodeToAssets(
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<PortfolioAssetStructOutput[]>;

    deleverageAccount(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      liquidator: PromiseOrValue<string>,
      currencyIndex: PromiseOrValue<BigNumberish>,
      depositUnderlyingInternal: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        vaultSharesFromLiquidation: BigNumber;
        depositAmountPrimeCash: BigNumber;
      }
    >;

    depositAssetToken(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      amountExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    depositUnderlyingToken(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      amountExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    enableBitmapCurrency(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    enableCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      cashGroup: CashGroupSettingsStruct,
      underlyingName: PromiseOrValue<string>,
      underlyingSymbol: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    enablePrimeBorrow(allowPrimeBorrow: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;

    enablePrimeDebt(
      currencyId: PromiseOrValue<BigNumberish>,
      underlyingName: PromiseOrValue<string>,
      underlyingSymbol: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    encode(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultAddress: PromiseOrValue<string>,
      isfCashDebt: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    encodeToId(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    enterVault(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      fCash: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      vaultData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    exitVault(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      vaultSharesToRedeem: PromiseOrValue<BigNumberish>,
      fCashToLend: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      exitVaultData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getAccount(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [AccountContextStructOutput, AccountBalanceStructOutput[], PortfolioAssetStructOutput[]] & {
        accountContext: AccountContextStructOutput;
        accountBalances: AccountBalanceStructOutput[];
        portfolio: PortfolioAssetStructOutput[];
      }
    >;

    getAccountBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        cashBalance: BigNumber;
        nTokenBalance: BigNumber;
        lastClaimTime: BigNumber;
      }
    >;

    getAccountContext(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<AccountContextStructOutput>;

    getAccountPortfolio(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PortfolioAssetStructOutput[]>;

    getAccountPrimeDebtBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getActiveMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<MarketParametersStructOutput[]>;

    getActiveMarketsAtBlockTime(
      currencyId: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<MarketParametersStructOutput[]>;

    getAssetsBitmap(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<string>;

    getAuthorizedCallbackContractStatus(callback: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    getBalanceOfPrimeCash(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getBorrowCapacity(
      vault: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        currentPrimeDebtUnderlying: BigNumber;
        totalfCashDebt: BigNumber;
        maxBorrowCapacity: BigNumber;
      }
    >;

    getCashAmountGivenfCashAmount(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashAmount: PromiseOrValue<BigNumberish>,
      marketIndex: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber]>;

    getCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<CashGroupSettingsStructOutput>;

    getCashGroupAndAssetRate(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [CashGroupSettingsStructOutput, Deprecated_AssetRateParametersStructOutput] & {
        cashGroup: CashGroupSettingsStructOutput;
        assetRate: Deprecated_AssetRateParametersStructOutput;
      }
    >;

    getCurrency(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [TokenStructOutput, TokenStructOutput] & {
        assetToken: TokenStructOutput;
        underlyingToken: TokenStructOutput;
      }
    >;

    getCurrencyAndRates(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [TokenStructOutput, TokenStructOutput, ETHRateStructOutput, Deprecated_AssetRateParametersStructOutput] & {
        assetToken: TokenStructOutput;
        underlyingToken: TokenStructOutput;
        ethRate: ETHRateStructOutput;
        assetRate: Deprecated_AssetRateParametersStructOutput;
      }
    >;

    getCurrencyId(tokenAddress: PromiseOrValue<string>, overrides?: CallOverrides): Promise<number>;

    getDepositFromfCashLend(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashAmount: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, number, string] & {
        depositAmountUnderlying: BigNumber;
        depositAmountAsset: BigNumber;
        marketIndex: number;
        encodedTrade: string;
      }
    >;

    getDepositParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber[], BigNumber[]] & {
        depositShares: BigNumber[];
        leverageThresholds: BigNumber[];
      }
    >;

    getFreeCollateral(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber, BigNumber[]]>;

    getGlobalTransferOperatorStatus(operator: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    getImplementation(overrides?: CallOverrides): Promise<string>;

    getInitializationParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber[], BigNumber[]] & {
        annualizedAnchorRates: BigNumber[];
        proportions: BigNumber[];
      }
    >;

    getInterestRateCurve(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [InterestRateParametersStructOutput[], InterestRateParametersStructOutput[]] & {
        nextInterestRateCurve: InterestRateParametersStructOutput[];
        activeInterestRateCurve: InterestRateParametersStructOutput[];
      }
    >;

    getMarket(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      settlementDate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<MarketParametersStructOutput>;

    getMarketIndex(
      maturity: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<number>;

    getMaxCurrencyId(overrides?: CallOverrides): Promise<number>;

    getNTokenAccount(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [number, BigNumber, BigNumber, BigNumber, string, BigNumber, BigNumber, BigNumber] & {
        currencyId: number;
        totalSupply: BigNumber;
        incentiveAnnualEmissionRate: BigNumber;
        lastInitializedTime: BigNumber;
        nTokenParameters: string;
        cashBalance: BigNumber;
        accumulatedNOTEPerNToken: BigNumber;
        lastAccumulatedTime: BigNumber;
      }
    >;

    getNTokenPortfolio(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [PortfolioAssetStructOutput[], PortfolioAssetStructOutput[]] & {
        liquidityTokens: PortfolioAssetStructOutput[];
        netfCashAssets: PortfolioAssetStructOutput[];
      }
    >;

    getNoteToken(overrides?: CallOverrides): Promise<string>;

    getOwnershipStatus(overrides?: CallOverrides): Promise<[string, string] & { owner: string; pendingOwner: string }>;

    getPresentfCashValue(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      notional: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      riskAdjusted: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getPrimeCashHoldingsOracle(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    getPrimeFactors(
      currencyId: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [PrimeRateStructOutput, PrimeCashFactorsStructOutput, BigNumber, BigNumber] & {
        primeRate: PrimeRateStructOutput;
        factors: PrimeCashFactorsStructOutput;
        maxUnderlyingSupply: BigNumber;
        totalUnderlyingSupply: BigNumber;
      }
    >;

    getPrimeFactorsStored(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PrimeCashFactorsStructOutput>;

    getPrimeInterestRate(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        annualDebtRatePreFee: BigNumber;
        annualDebtRatePostFee: BigNumber;
        annualSupplyRate: BigNumber;
      }
    >;

    getPrimeInterestRateCurve(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<InterestRateParametersStructOutput>;

    getPrincipalFromfCashBorrow(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashBorrow: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, number, string] & {
        borrowAmountUnderlying: BigNumber;
        borrowAmountAsset: BigNumber;
        marketIndex: number;
        encodedTrade: string;
      }
    >;

    getRateStorage(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [ETHRateStorageStructOutput, AssetRateStorageStructOutput] & {
        ethRate: ETHRateStorageStructOutput;
        assetRate: AssetRateStorageStructOutput;
      }
    >;

    getRebalancingCooldown(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<number>;

    getRebalancingTarget(
      currencyId: PromiseOrValue<BigNumberish>,
      holding: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<number>;

    getReserveBalance(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getReserveBuffer(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getSecondaryBorrow(
      vault: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getSecondaryIncentiveRewarder(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    getSettlementRate(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PrimeRateStructOutput>;

    getStoredTokenBalances(tokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber[]>;

    getTotalfCashDebtOutstanding(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        totalfCashDebt: BigNumber;
        fCashDebtHeldInSettlementReserve: BigNumber;
        primeCashHeldInSettlementReserve: BigNumber;
      }
    >;

    getTreasuryManager(overrides?: CallOverrides): Promise<string>;

    getVaultAccount(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<VaultAccountStructOutput>;

    getVaultAccountHealthFactors(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [VaultAccountHealthFactorsStructOutput, [BigNumber, BigNumber, BigNumber], [BigNumber, BigNumber, BigNumber]] & {
        h: VaultAccountHealthFactorsStructOutput;
        maxLiquidatorDepositUnderlying: [BigNumber, BigNumber, BigNumber];
        vaultSharesToLiquidator: [BigNumber, BigNumber, BigNumber];
      }
    >;

    getVaultAccountSecondaryDebt(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, [BigNumber, BigNumber], [BigNumber, BigNumber]] & {
        maturity: BigNumber;
        accountSecondaryDebt: [BigNumber, BigNumber];
        accountSecondaryCashHeld: [BigNumber, BigNumber];
      }
    >;

    getVaultAccountWithFeeAccrual(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [VaultAccountStructOutput, BigNumber] & {
        accruedPrimeVaultFeeInUnderlying: BigNumber;
      }
    >;

    getVaultConfig(vault: PromiseOrValue<string>, overrides?: CallOverrides): Promise<VaultConfigStructOutput>;

    getVaultState(
      vault: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<VaultStateStructOutput>;

    getfCashAmountGivenCashAmount(
      currencyId: PromiseOrValue<BigNumberish>,
      netCashToAccount: PromiseOrValue<BigNumberish>,
      marketIndex: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getfCashBorrowFromPrincipal(
      currencyId: PromiseOrValue<BigNumberish>,
      borrowedAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, number, string] & {
        fCashDebt: BigNumber;
        marketIndex: number;
        encodedTrade: string;
      }
    >;

    getfCashLendFromDeposit(
      currencyId: PromiseOrValue<BigNumberish>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, number, string] & {
        fCashAmount: BigNumber;
        marketIndex: number;
        encodedTrade: string;
      }
    >;

    getfCashNotional(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getfCashRequiredToLiquidateCash(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      vaultAccountCashBalance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        fCashRequired: BigNumber;
        discountFactor: BigNumber;
      }
    >;

    initializeMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      isFirstInit: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    isApprovedForAll(
      account: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    liquidateCollateralCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      collateralCurrency: PromiseOrValue<BigNumberish>,
      maxCollateralLiquidation: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      withdrawCollateral: PromiseOrValue<boolean>,
      redeemToUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber, BigNumber]>;

    liquidateExcessVaultCash(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      liquidator: PromiseOrValue<string>,
      excessCashIndex: PromiseOrValue<BigNumberish>,
      debtIndex: PromiseOrValue<BigNumberish>,
      _depositUnderlyingInternal: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    liquidateLocalCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber]>;

    liquidateVaultCashBalance(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      liquidator: PromiseOrValue<string>,
      currencyIndex: PromiseOrValue<BigNumberish>,
      fCashDeposit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    liquidatefCashCrossCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<[BigNumber[], BigNumber]>;

    liquidatefCashLocal(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<[BigNumber[], BigNumber]>;

    listCurrency(
      underlyingToken: TokenStorageStruct,
      ethRate: ETHRateStorageStruct,
      primeDebtCurve: InterestRateCurveSettingsStruct,
      primeCashHoldingsOracle: PromiseOrValue<string>,
      allowPrimeCashDebt: PromiseOrValue<boolean>,
      rateOracleTimeWindow5Min: PromiseOrValue<BigNumberish>,
      underlyingName: PromiseOrValue<string>,
      underlyingSymbol: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<number>;

    nTokenAddress(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    nTokenBalanceOf(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    nTokenClaimIncentives(overrides?: CallOverrides): Promise<BigNumber>;

    nTokenGetClaimableIncentives(
      account: PromiseOrValue<string>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    nTokenPresentValueAssetDenominated(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    nTokenPresentValueUnderlyingDenominated(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    nTokenRedeem(
      redeemer: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      tokensToRedeem_: PromiseOrValue<BigNumberish>,
      sellTokenAssets: PromiseOrValue<boolean>,
      acceptResidualAssets: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    nTokenTotalSupply(nTokenAddress: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    nTokenTransfer(
      currencyId: PromiseOrValue<BigNumberish>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    nTokenTransferAllowance(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    nTokenTransferApprove(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    nTokenTransferApproveAll(
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    nTokenTransferFrom(
      currencyId: PromiseOrValue<BigNumberish>,
      spender: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    owner(overrides?: CallOverrides): Promise<string>;

    pCashAddress(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    pCashTransfer(
      currencyId: PromiseOrValue<BigNumberish>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    pCashTransferAllowance(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    pCashTransferApprove(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    pCashTransferFrom(
      currencyId: PromiseOrValue<BigNumberish>,
      spender: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    pDebtAddress(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    pauseGuardian(overrides?: CallOverrides): Promise<string>;

    pauseRouter(overrides?: CallOverrides): Promise<string>;

    rebalance(currencyId: PromiseOrValue<BigNumberish>[], overrides?: CallOverrides): Promise<void>;

    repaySecondaryCurrencyFromVault(
      account: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      underlyingToRepay: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      minLendRate: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber]>;

    rollVaultPosition(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      fCashToBorrow: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      enterVaultData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    safeBatchTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    safeTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setMaxBorrowCapacity(
      vaultAddress: PromiseOrValue<string>,
      maxVaultBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setMaxUnderlyingSupply(
      currencyId: PromiseOrValue<BigNumberish>,
      maxUnderlyingSupply: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setPauseRouterAndGuardian(
      pauseRouter_: PromiseOrValue<string>,
      pauseGuardian_: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setRebalancingCooldown(
      currencyId: PromiseOrValue<BigNumberish>,
      cooldownTimeInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setRebalancingTargets(
      currencyId: PromiseOrValue<BigNumberish>,
      targets: NotionalTreasury.RebalancingTargetConfigStruct[],
      overrides?: CallOverrides,
    ): Promise<void>;

    setReserveBuffer(
      currencyId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setReserveCashBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      reserveBalance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setTreasuryManager(manager: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setVaultDeleverageStatus(
      vaultAddress: PromiseOrValue<string>,
      disableDeleverage: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setVaultPauseStatus(
      vaultAddress: PromiseOrValue<string>,
      enable: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    settleAccount(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    settleSecondaryBorrowForAccount(
      vault: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    settleVaultAccount(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    signedBalanceOf(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    signedBalanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<BigNumber[]>;

    signedBalanceOfVaultTokenId(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    supportsInterface(interfaceId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;

    sweepCashIntoMarkets(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      direct: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    transferReserveToTreasury(
      currencies: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<BigNumber[]>;

    updateAuthorizedCallbackContract(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    updateCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      cashGroup: CashGroupSettingsStruct,
      overrides?: CallOverrides,
    ): Promise<void>;

    updateDepositParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      depositShares: PromiseOrValue<BigNumberish>[],
      leverageThresholds: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<void>;

    updateETHRate(
      currencyId: PromiseOrValue<BigNumberish>,
      rateOracle: PromiseOrValue<string>,
      mustInvert: PromiseOrValue<boolean>,
      buffer: PromiseOrValue<BigNumberish>,
      haircut: PromiseOrValue<BigNumberish>,
      liquidationDiscount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    updateIncentiveEmissionRate(
      currencyId: PromiseOrValue<BigNumberish>,
      newEmissionRate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    updateInitializationParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      annualizedAnchorRates: PromiseOrValue<BigNumberish>[],
      proportions: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<void>;

    updateInterestRateCurve(
      currencyId: PromiseOrValue<BigNumberish>,
      marketIndices: PromiseOrValue<BigNumberish>[],
      settings: InterestRateCurveSettingsStruct[],
      overrides?: CallOverrides,
    ): Promise<void>;

    updatePrimeCashCurve(
      currencyId: PromiseOrValue<BigNumberish>,
      primeDebtCurve: InterestRateCurveSettingsStruct,
      overrides?: CallOverrides,
    ): Promise<void>;

    updatePrimeCashHoldingsOracle(
      currencyId: PromiseOrValue<BigNumberish>,
      primeCashHoldingsOracle: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    updateSecondaryBorrowCapacity(
      vaultAddress: PromiseOrValue<string>,
      secondaryCurrencyId: PromiseOrValue<BigNumberish>,
      maxBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    updateTokenCollateralParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      residualPurchaseIncentive10BPS: PromiseOrValue<BigNumberish>,
      pvHaircutPercentage: PromiseOrValue<BigNumberish>,
      residualPurchaseTimeBufferHours: PromiseOrValue<BigNumberish>,
      cashWithholdingBuffer10BPS: PromiseOrValue<BigNumberish>,
      liquidationHaircutPercentage: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    updateVault(
      vaultAddress: PromiseOrValue<string>,
      vaultConfig: VaultConfigParamsStruct,
      maxPrimaryBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    upgradeBeacon(
      proxy: PromiseOrValue<BigNumberish>,
      newBeacon: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    upgradeTo(newImplementation: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    withdraw(
      currencyId: PromiseOrValue<BigNumberish>,
      amountInternalPrecision: PromiseOrValue<BigNumberish>,
      redeemToUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;
  };

  filters: {
    'AccountContextUpdate(address)'(account?: PromiseOrValue<string> | null): AccountContextUpdateEventFilter;
    AccountContextUpdate(account?: PromiseOrValue<string> | null): AccountContextUpdateEventFilter;

    'AccountSettled(address)'(account?: PromiseOrValue<string> | null): AccountSettledEventFilter;
    AccountSettled(account?: PromiseOrValue<string> | null): AccountSettledEventFilter;

    'Approval(address,address,uint256)'(
      owner?: PromiseOrValue<string> | null,
      spender?: PromiseOrValue<string> | null,
      amount?: null,
    ): ApprovalEventFilter;
    Approval(
      owner?: PromiseOrValue<string> | null,
      spender?: PromiseOrValue<string> | null,
      amount?: null,
    ): ApprovalEventFilter;

    'ApprovalForAll(address,address,bool)'(
      account?: PromiseOrValue<string> | null,
      operator?: PromiseOrValue<string> | null,
      approved?: null,
    ): ApprovalForAllEventFilter;
    ApprovalForAll(
      account?: PromiseOrValue<string> | null,
      operator?: PromiseOrValue<string> | null,
      approved?: null,
    ): ApprovalForAllEventFilter;

    'CurrencyRebalanced(uint16,uint256,uint256)'(
      currencyId?: null,
      supplyFactor?: null,
      annualizedInterestRate?: null,
    ): CurrencyRebalancedEventFilter;
    CurrencyRebalanced(
      currencyId?: null,
      supplyFactor?: null,
      annualizedInterestRate?: null,
    ): CurrencyRebalancedEventFilter;

    'DeployNToken(uint16,address)'(currencyId?: null, nTokenAddress?: null): DeployNTokenEventFilter;
    DeployNToken(currencyId?: null, nTokenAddress?: null): DeployNTokenEventFilter;

    'ExcessReserveBalanceHarvested(uint16,int256)'(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      harvestAmount?: null,
    ): ExcessReserveBalanceHarvestedEventFilter;
    ExcessReserveBalanceHarvested(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      harvestAmount?: null,
    ): ExcessReserveBalanceHarvestedEventFilter;

    'IncentivesMigrated(uint16,uint256,uint256,uint256)'(
      currencyId?: null,
      migrationEmissionRate?: null,
      finalIntegralTotalSupply?: null,
      migrationTime?: null,
    ): IncentivesMigratedEventFilter;
    IncentivesMigrated(
      currencyId?: null,
      migrationEmissionRate?: null,
      finalIntegralTotalSupply?: null,
      migrationTime?: null,
    ): IncentivesMigratedEventFilter;

    'LiquidateCollateralCurrency(address,address,uint16,uint16,int256,int256,int256)'(
      liquidated?: PromiseOrValue<string> | null,
      liquidator?: PromiseOrValue<string> | null,
      localCurrencyId?: null,
      collateralCurrencyId?: null,
      netLocalFromLiquidator?: null,
      netCollateralTransfer?: null,
      netNTokenTransfer?: null,
    ): LiquidateCollateralCurrencyEventFilter;
    LiquidateCollateralCurrency(
      liquidated?: PromiseOrValue<string> | null,
      liquidator?: PromiseOrValue<string> | null,
      localCurrencyId?: null,
      collateralCurrencyId?: null,
      netLocalFromLiquidator?: null,
      netCollateralTransfer?: null,
      netNTokenTransfer?: null,
    ): LiquidateCollateralCurrencyEventFilter;

    'LiquidateLocalCurrency(address,address,uint16,int256)'(
      liquidated?: PromiseOrValue<string> | null,
      liquidator?: PromiseOrValue<string> | null,
      localCurrencyId?: null,
      netLocalFromLiquidator?: null,
    ): LiquidateLocalCurrencyEventFilter;
    LiquidateLocalCurrency(
      liquidated?: PromiseOrValue<string> | null,
      liquidator?: PromiseOrValue<string> | null,
      localCurrencyId?: null,
      netLocalFromLiquidator?: null,
    ): LiquidateLocalCurrencyEventFilter;

    'LiquidatefCashEvent(address,address,uint16,uint16,int256,uint256[],int256[])'(
      liquidated?: PromiseOrValue<string> | null,
      liquidator?: PromiseOrValue<string> | null,
      localCurrencyId?: null,
      fCashCurrency?: null,
      netLocalFromLiquidator?: null,
      fCashMaturities?: null,
      fCashNotionalTransfer?: null,
    ): LiquidatefCashEventEventFilter;
    LiquidatefCashEvent(
      liquidated?: PromiseOrValue<string> | null,
      liquidator?: PromiseOrValue<string> | null,
      localCurrencyId?: null,
      fCashCurrency?: null,
      netLocalFromLiquidator?: null,
      fCashMaturities?: null,
      fCashNotionalTransfer?: null,
    ): LiquidatefCashEventEventFilter;

    'ListCurrency(uint16)'(newCurrencyId?: null): ListCurrencyEventFilter;
    ListCurrency(newCurrencyId?: null): ListCurrencyEventFilter;

    'MarketsInitialized(uint16)'(currencyId?: null): MarketsInitializedEventFilter;
    MarketsInitialized(currencyId?: null): MarketsInitializedEventFilter;

    'OwnershipTransferred(address,address)'(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;

    'PauseRouterAndGuardianUpdated(address,address)'(
      pauseRouter?: PromiseOrValue<string> | null,
      pauseGuardian?: PromiseOrValue<string> | null,
    ): PauseRouterAndGuardianUpdatedEventFilter;
    PauseRouterAndGuardianUpdated(
      pauseRouter?: PromiseOrValue<string> | null,
      pauseGuardian?: PromiseOrValue<string> | null,
    ): PauseRouterAndGuardianUpdatedEventFilter;

    'PrimeCashCurveChanged(uint16)'(currencyId?: PromiseOrValue<BigNumberish> | null): PrimeCashCurveChangedEventFilter;
    PrimeCashCurveChanged(currencyId?: PromiseOrValue<BigNumberish> | null): PrimeCashCurveChangedEventFilter;

    'PrimeCashHoldingsOracleUpdated(uint16,address)'(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      oracle?: null,
    ): PrimeCashHoldingsOracleUpdatedEventFilter;
    PrimeCashHoldingsOracleUpdated(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      oracle?: null,
    ): PrimeCashHoldingsOracleUpdatedEventFilter;

    'PrimeCashInterestAccrued(uint16,uint256,uint256,uint256)'(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      underlyingScalar?: null,
      supplyScalar?: null,
      debtScalar?: null,
    ): PrimeCashInterestAccruedEventFilter;
    PrimeCashInterestAccrued(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      underlyingScalar?: null,
      supplyScalar?: null,
      debtScalar?: null,
    ): PrimeCashInterestAccruedEventFilter;

    'PrimeProxyDeployed(uint16,address,bool)'(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      proxy?: null,
      isCashProxy?: null,
    ): PrimeProxyDeployedEventFilter;
    PrimeProxyDeployed(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      proxy?: null,
      isCashProxy?: null,
    ): PrimeProxyDeployedEventFilter;

    'RebalancingCooldownUpdated(uint16,uint40)'(
      currencyId?: null,
      cooldownTimeInSeconds?: null,
    ): RebalancingCooldownUpdatedEventFilter;
    RebalancingCooldownUpdated(currencyId?: null, cooldownTimeInSeconds?: null): RebalancingCooldownUpdatedEventFilter;

    'RebalancingTargetsUpdated(uint16,tuple[])'(
      currencyId?: null,
      targets?: null,
    ): RebalancingTargetsUpdatedEventFilter;
    RebalancingTargetsUpdated(currencyId?: null, targets?: null): RebalancingTargetsUpdatedEventFilter;

    'ReserveBalanceUpdated(uint16,int256)'(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      newBalance?: null,
    ): ReserveBalanceUpdatedEventFilter;
    ReserveBalanceUpdated(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      newBalance?: null,
    ): ReserveBalanceUpdatedEventFilter;

    'ReserveBufferUpdated(uint16,uint256)'(currencyId?: null, bufferAmount?: null): ReserveBufferUpdatedEventFilter;
    ReserveBufferUpdated(currencyId?: null, bufferAmount?: null): ReserveBufferUpdatedEventFilter;

    'SetPrimeSettlementRate(uint256,uint256,int256,int256)'(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      supplyFactor?: null,
      debtFactor?: null,
    ): SetPrimeSettlementRateEventFilter;
    SetPrimeSettlementRate(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      supplyFactor?: null,
      debtFactor?: null,
    ): SetPrimeSettlementRateEventFilter;

    'SweepCashIntoMarkets(uint16,int256)'(currencyId?: null, cashIntoMarkets?: null): SweepCashIntoMarketsEventFilter;
    SweepCashIntoMarkets(currencyId?: null, cashIntoMarkets?: null): SweepCashIntoMarketsEventFilter;

    'TokenMigrated(uint16)'(currencyId?: null): TokenMigratedEventFilter;
    TokenMigrated(currencyId?: null): TokenMigratedEventFilter;

    'Transfer(address,address,uint256)'(
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      amount?: null,
    ): TransferEventFilter;
    Transfer(
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      amount?: null,
    ): TransferEventFilter;

    'TransferBatch(address,address,address,uint256[],uint256[])'(
      operator?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      ids?: null,
      values?: null,
    ): TransferBatchEventFilter;
    TransferBatch(
      operator?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      ids?: null,
      values?: null,
    ): TransferBatchEventFilter;

    'TransferSingle(address,address,address,uint256,uint256)'(
      operator?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      id?: null,
      value?: null,
    ): TransferSingleEventFilter;
    TransferSingle(
      operator?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      id?: null,
      value?: null,
    ): TransferSingleEventFilter;

    'TreasuryManagerChanged(address,address)'(
      previousManager?: PromiseOrValue<string> | null,
      newManager?: PromiseOrValue<string> | null,
    ): TreasuryManagerChangedEventFilter;
    TreasuryManagerChanged(
      previousManager?: PromiseOrValue<string> | null,
      newManager?: PromiseOrValue<string> | null,
    ): TreasuryManagerChangedEventFilter;

    'URI(string,uint256)'(value?: null, id?: PromiseOrValue<BigNumberish> | null): URIEventFilter;
    URI(value?: null, id?: PromiseOrValue<BigNumberish> | null): URIEventFilter;

    'UpdateAssetRate(uint16)'(currencyId?: null): UpdateAssetRateEventFilter;
    UpdateAssetRate(currencyId?: null): UpdateAssetRateEventFilter;

    'UpdateAuthorizedCallbackContract(address,bool)'(
      operator?: null,
      approved?: null,
    ): UpdateAuthorizedCallbackContractEventFilter;
    UpdateAuthorizedCallbackContract(operator?: null, approved?: null): UpdateAuthorizedCallbackContractEventFilter;

    'UpdateCashGroup(uint16)'(currencyId?: null): UpdateCashGroupEventFilter;
    UpdateCashGroup(currencyId?: null): UpdateCashGroupEventFilter;

    'UpdateDepositParameters(uint16)'(currencyId?: null): UpdateDepositParametersEventFilter;
    UpdateDepositParameters(currencyId?: null): UpdateDepositParametersEventFilter;

    'UpdateETHRate(uint16)'(currencyId?: null): UpdateETHRateEventFilter;
    UpdateETHRate(currencyId?: null): UpdateETHRateEventFilter;

    'UpdateGlobalTransferOperator(address,bool)'(
      operator?: null,
      approved?: null,
    ): UpdateGlobalTransferOperatorEventFilter;
    UpdateGlobalTransferOperator(operator?: null, approved?: null): UpdateGlobalTransferOperatorEventFilter;

    'UpdateIncentiveEmissionRate(uint16,uint32)'(
      currencyId?: null,
      newEmissionRate?: null,
    ): UpdateIncentiveEmissionRateEventFilter;
    UpdateIncentiveEmissionRate(currencyId?: null, newEmissionRate?: null): UpdateIncentiveEmissionRateEventFilter;

    'UpdateInitializationParameters(uint16)'(currencyId?: null): UpdateInitializationParametersEventFilter;
    UpdateInitializationParameters(currencyId?: null): UpdateInitializationParametersEventFilter;

    'UpdateInterestRateCurve(uint16,uint8)'(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      marketIndex?: PromiseOrValue<BigNumberish> | null,
    ): UpdateInterestRateCurveEventFilter;
    UpdateInterestRateCurve(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      marketIndex?: PromiseOrValue<BigNumberish> | null,
    ): UpdateInterestRateCurveEventFilter;

    'UpdateMaxUnderlyingSupply(uint16,uint256)'(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maxUnderlyingSupply?: null,
    ): UpdateMaxUnderlyingSupplyEventFilter;
    UpdateMaxUnderlyingSupply(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maxUnderlyingSupply?: null,
    ): UpdateMaxUnderlyingSupplyEventFilter;

    'UpdateSecondaryIncentiveRewarder(uint16,address)'(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      rewarder?: null,
    ): UpdateSecondaryIncentiveRewarderEventFilter;
    UpdateSecondaryIncentiveRewarder(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      rewarder?: null,
    ): UpdateSecondaryIncentiveRewarderEventFilter;

    'UpdateTokenCollateralParameters(uint16)'(currencyId?: null): UpdateTokenCollateralParametersEventFilter;
    UpdateTokenCollateralParameters(currencyId?: null): UpdateTokenCollateralParametersEventFilter;

    'VaultAccountCashLiquidation(address,address,address,uint16,int256,int256)'(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      liquidator?: PromiseOrValue<string> | null,
      currencyId?: null,
      fCashDeposit?: null,
      cashToLiquidator?: null,
    ): VaultAccountCashLiquidationEventFilter;
    VaultAccountCashLiquidation(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      liquidator?: PromiseOrValue<string> | null,
      currencyId?: null,
      fCashDeposit?: null,
      cashToLiquidator?: null,
    ): VaultAccountCashLiquidationEventFilter;

    'VaultBorrowCapacityChange(address,uint16,uint256)'(
      vault?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      totalUsedBorrowCapacity?: null,
    ): VaultBorrowCapacityChangeEventFilter;
    VaultBorrowCapacityChange(
      vault?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      totalUsedBorrowCapacity?: null,
    ): VaultBorrowCapacityChangeEventFilter;

    'VaultDeleverageAccount(address,address,uint16,uint256,int256)'(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      currencyId?: null,
      vaultSharesToLiquidator?: null,
      depositAmountPrimeCash?: null,
    ): VaultDeleverageAccountEventFilter;
    VaultDeleverageAccount(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      currencyId?: null,
      vaultSharesToLiquidator?: null,
      depositAmountPrimeCash?: null,
    ): VaultDeleverageAccountEventFilter;

    'VaultDeleverageStatus(address,bool)'(
      vaultAddress?: PromiseOrValue<string> | null,
      disableDeleverage?: null,
    ): VaultDeleverageStatusEventFilter;
    VaultDeleverageStatus(
      vaultAddress?: PromiseOrValue<string> | null,
      disableDeleverage?: null,
    ): VaultDeleverageStatusEventFilter;

    'VaultLiquidatorProfit(address,address,address,uint256,bool)'(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      liquidator?: PromiseOrValue<string> | null,
      vaultSharesToLiquidator?: null,
      transferSharesToLiquidator?: null,
    ): VaultLiquidatorProfitEventFilter;
    VaultLiquidatorProfit(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      liquidator?: PromiseOrValue<string> | null,
      vaultSharesToLiquidator?: null,
      transferSharesToLiquidator?: null,
    ): VaultLiquidatorProfitEventFilter;

    'VaultPauseStatus(address,bool)'(
      vault?: PromiseOrValue<string> | null,
      enabled?: null,
    ): VaultPauseStatusEventFilter;
    VaultPauseStatus(vault?: PromiseOrValue<string> | null, enabled?: null): VaultPauseStatusEventFilter;

    'VaultSecondaryTransaction(address,address,uint16,uint256,int256,int256)'(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: null,
      netUnderlyingDebt?: null,
      netPrimeSupply?: null,
    ): VaultSecondaryTransactionEventFilter;
    VaultSecondaryTransaction(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: null,
      netUnderlyingDebt?: null,
      netPrimeSupply?: null,
    ): VaultSecondaryTransactionEventFilter;

    'VaultUpdateSecondaryBorrowCapacity(address,uint16,uint80)'(
      vault?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maxSecondaryBorrowCapacity?: null,
    ): VaultUpdateSecondaryBorrowCapacityEventFilter;
    VaultUpdateSecondaryBorrowCapacity(
      vault?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maxSecondaryBorrowCapacity?: null,
    ): VaultUpdateSecondaryBorrowCapacityEventFilter;

    'VaultUpdated(address,bool,uint80)'(
      vault?: PromiseOrValue<string> | null,
      enabled?: null,
      maxPrimaryBorrowCapacity?: null,
    ): VaultUpdatedEventFilter;
    VaultUpdated(
      vault?: PromiseOrValue<string> | null,
      enabled?: null,
      maxPrimaryBorrowCapacity?: null,
    ): VaultUpdatedEventFilter;
  };

  estimateGas: {
    accruePrimeInterest(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    balanceOf(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    balanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    batchBalanceAction(
      account: PromiseOrValue<string>,
      actions: BalanceActionStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    batchBalanceAndTradeAction(
      account: PromiseOrValue<string>,
      actions: BalanceActionWithTradesStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    batchBalanceAndTradeActionWithCallback(
      account: PromiseOrValue<string>,
      actions: BalanceActionWithTradesStruct[],
      callbackData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    batchLend(
      account: PromiseOrValue<string>,
      actions: BatchLendStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    borrowSecondaryCurrencyToVault(
      account: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      underlyingToBorrow: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      maxBorrowRate: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      minRollLendRate: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    calculateCollateralCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      collateralCurrency: PromiseOrValue<BigNumberish>,
      maxCollateralLiquidation: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    calculateDepositAmountInDeleverage(
      currencyIndex: PromiseOrValue<BigNumberish>,
      vaultAccount: VaultAccountStruct,
      vaultConfig: VaultConfigStruct,
      vaultState: VaultStateStruct,
      depositUnderlyingInternal: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    calculateLocalCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    calculateNTokensToMint(
      currencyId: PromiseOrValue<BigNumberish>,
      amountToDepositExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    calculatefCashCrossCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    calculatefCashLocalLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    checkVaultAccountCollateralRatio(
      vault: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    claimCOMPAndTransfer(
      ctokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    claimOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    convertCashBalanceToExternal(
      currencyId: PromiseOrValue<BigNumberish>,
      cashBalanceInternal: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    convertNTokenToUnderlying(
      currencyId: PromiseOrValue<BigNumberish>,
      nTokenBalance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    convertSettledfCash(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      fCashBalance: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    convertUnderlyingToPrimeCash(
      currencyId: PromiseOrValue<BigNumberish>,
      underlyingExternal: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    decodeERC1155Id(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    decodeToAssets(
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    deleverageAccount(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      liquidator: PromiseOrValue<string>,
      currencyIndex: PromiseOrValue<BigNumberish>,
      depositUnderlyingInternal: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    depositAssetToken(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      amountExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    depositUnderlyingToken(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      amountExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    enableBitmapCurrency(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    enableCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      cashGroup: CashGroupSettingsStruct,
      underlyingName: PromiseOrValue<string>,
      underlyingSymbol: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    enablePrimeBorrow(
      allowPrimeBorrow: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    enablePrimeDebt(
      currencyId: PromiseOrValue<BigNumberish>,
      underlyingName: PromiseOrValue<string>,
      underlyingSymbol: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    encode(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultAddress: PromiseOrValue<string>,
      isfCashDebt: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    encodeToId(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    enterVault(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      fCash: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      vaultData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    exitVault(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      vaultSharesToRedeem: PromiseOrValue<BigNumberish>,
      fCashToLend: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      exitVaultData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    getAccount(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getAccountBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getAccountContext(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getAccountPortfolio(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getAccountPrimeDebtBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getActiveMarkets(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getActiveMarketsAtBlockTime(
      currencyId: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getAssetsBitmap(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getAuthorizedCallbackContractStatus(
      callback: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getBalanceOfPrimeCash(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getBorrowCapacity(
      vault: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getCashAmountGivenfCashAmount(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashAmount: PromiseOrValue<BigNumberish>,
      marketIndex: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getCashGroup(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getCashGroupAndAssetRate(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getCurrency(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getCurrencyAndRates(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getCurrencyId(tokenAddress: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getDepositFromfCashLend(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashAmount: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getDepositParameters(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getFreeCollateral(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getGlobalTransferOperatorStatus(operator: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getImplementation(overrides?: CallOverrides): Promise<BigNumber>;

    getInitializationParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getInterestRateCurve(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getMarket(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      settlementDate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getMarketIndex(
      maturity: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getMaxCurrencyId(overrides?: CallOverrides): Promise<BigNumber>;

    getNTokenAccount(tokenAddress: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getNTokenPortfolio(tokenAddress: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getNoteToken(overrides?: CallOverrides): Promise<BigNumber>;

    getOwnershipStatus(overrides?: CallOverrides): Promise<BigNumber>;

    getPresentfCashValue(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      notional: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      riskAdjusted: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getPrimeCashHoldingsOracle(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getPrimeFactors(
      currencyId: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getPrimeFactorsStored(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getPrimeInterestRate(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getPrimeInterestRateCurve(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getPrincipalFromfCashBorrow(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashBorrow: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getRateStorage(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getRebalancingCooldown(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getRebalancingTarget(
      currencyId: PromiseOrValue<BigNumberish>,
      holding: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getReserveBalance(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getReserveBuffer(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getSecondaryBorrow(
      vault: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getSecondaryIncentiveRewarder(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getSettlementRate(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getStoredTokenBalances(tokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber>;

    getTotalfCashDebtOutstanding(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getTreasuryManager(overrides?: CallOverrides): Promise<BigNumber>;

    getVaultAccount(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getVaultAccountHealthFactors(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getVaultAccountSecondaryDebt(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getVaultAccountWithFeeAccrual(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getVaultConfig(vault: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getVaultState(
      vault: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getfCashAmountGivenCashAmount(
      currencyId: PromiseOrValue<BigNumberish>,
      netCashToAccount: PromiseOrValue<BigNumberish>,
      marketIndex: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getfCashBorrowFromPrincipal(
      currencyId: PromiseOrValue<BigNumberish>,
      borrowedAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getfCashLendFromDeposit(
      currencyId: PromiseOrValue<BigNumberish>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getfCashNotional(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getfCashRequiredToLiquidateCash(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      vaultAccountCashBalance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    initializeMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      isFirstInit: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    isApprovedForAll(
      account: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    liquidateCollateralCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      collateralCurrency: PromiseOrValue<BigNumberish>,
      maxCollateralLiquidation: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      withdrawCollateral: PromiseOrValue<boolean>,
      redeemToUnderlying: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    liquidateExcessVaultCash(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      liquidator: PromiseOrValue<string>,
      excessCashIndex: PromiseOrValue<BigNumberish>,
      debtIndex: PromiseOrValue<BigNumberish>,
      _depositUnderlyingInternal: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    liquidateLocalCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    liquidateVaultCashBalance(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      liquidator: PromiseOrValue<string>,
      currencyIndex: PromiseOrValue<BigNumberish>,
      fCashDeposit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    liquidatefCashCrossCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    liquidatefCashLocal(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    listCurrency(
      underlyingToken: TokenStorageStruct,
      ethRate: ETHRateStorageStruct,
      primeDebtCurve: InterestRateCurveSettingsStruct,
      primeCashHoldingsOracle: PromiseOrValue<string>,
      allowPrimeCashDebt: PromiseOrValue<boolean>,
      rateOracleTimeWindow5Min: PromiseOrValue<BigNumberish>,
      underlyingName: PromiseOrValue<string>,
      underlyingSymbol: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    nTokenAddress(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    nTokenBalanceOf(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    nTokenClaimIncentives(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    nTokenGetClaimableIncentives(
      account: PromiseOrValue<string>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    nTokenPresentValueAssetDenominated(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    nTokenPresentValueUnderlyingDenominated(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    nTokenRedeem(
      redeemer: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      tokensToRedeem_: PromiseOrValue<BigNumberish>,
      sellTokenAssets: PromiseOrValue<boolean>,
      acceptResidualAssets: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    nTokenTotalSupply(nTokenAddress: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    nTokenTransfer(
      currencyId: PromiseOrValue<BigNumberish>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    nTokenTransferAllowance(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    nTokenTransferApprove(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    nTokenTransferApproveAll(
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    nTokenTransferFrom(
      currencyId: PromiseOrValue<BigNumberish>,
      spender: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pCashAddress(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    pCashTransfer(
      currencyId: PromiseOrValue<BigNumberish>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    pCashTransferAllowance(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    pCashTransferApprove(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    pCashTransferFrom(
      currencyId: PromiseOrValue<BigNumberish>,
      spender: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    pDebtAddress(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    pauseGuardian(overrides?: CallOverrides): Promise<BigNumber>;

    pauseRouter(overrides?: CallOverrides): Promise<BigNumber>;

    rebalance(
      currencyId: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    repaySecondaryCurrencyFromVault(
      account: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      underlyingToRepay: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      minLendRate: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    rollVaultPosition(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      fCashToBorrow: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      enterVaultData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    safeBatchTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    safeTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setMaxBorrowCapacity(
      vaultAddress: PromiseOrValue<string>,
      maxVaultBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setMaxUnderlyingSupply(
      currencyId: PromiseOrValue<BigNumberish>,
      maxUnderlyingSupply: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setPauseRouterAndGuardian(
      pauseRouter_: PromiseOrValue<string>,
      pauseGuardian_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setRebalancingCooldown(
      currencyId: PromiseOrValue<BigNumberish>,
      cooldownTimeInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setRebalancingTargets(
      currencyId: PromiseOrValue<BigNumberish>,
      targets: NotionalTreasury.RebalancingTargetConfigStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setReserveBuffer(
      currencyId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setReserveCashBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      reserveBalance: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setTreasuryManager(
      manager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setVaultDeleverageStatus(
      vaultAddress: PromiseOrValue<string>,
      disableDeleverage: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setVaultPauseStatus(
      vaultAddress: PromiseOrValue<string>,
      enable: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    settleAccount(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    settleSecondaryBorrowForAccount(
      vault: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    settleVaultAccount(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    signedBalanceOf(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    signedBalanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    signedBalanceOfVaultTokenId(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    supportsInterface(interfaceId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    sweepCashIntoMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      direct: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    transferReserveToTreasury(
      currencies: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateAuthorizedCallbackContract(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      cashGroup: CashGroupSettingsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateDepositParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      depositShares: PromiseOrValue<BigNumberish>[],
      leverageThresholds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateETHRate(
      currencyId: PromiseOrValue<BigNumberish>,
      rateOracle: PromiseOrValue<string>,
      mustInvert: PromiseOrValue<boolean>,
      buffer: PromiseOrValue<BigNumberish>,
      haircut: PromiseOrValue<BigNumberish>,
      liquidationDiscount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateIncentiveEmissionRate(
      currencyId: PromiseOrValue<BigNumberish>,
      newEmissionRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateInitializationParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      annualizedAnchorRates: PromiseOrValue<BigNumberish>[],
      proportions: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateInterestRateCurve(
      currencyId: PromiseOrValue<BigNumberish>,
      marketIndices: PromiseOrValue<BigNumberish>[],
      settings: InterestRateCurveSettingsStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updatePrimeCashCurve(
      currencyId: PromiseOrValue<BigNumberish>,
      primeDebtCurve: InterestRateCurveSettingsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updatePrimeCashHoldingsOracle(
      currencyId: PromiseOrValue<BigNumberish>,
      primeCashHoldingsOracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateSecondaryBorrowCapacity(
      vaultAddress: PromiseOrValue<string>,
      secondaryCurrencyId: PromiseOrValue<BigNumberish>,
      maxBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateTokenCollateralParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      residualPurchaseIncentive10BPS: PromiseOrValue<BigNumberish>,
      pvHaircutPercentage: PromiseOrValue<BigNumberish>,
      residualPurchaseTimeBufferHours: PromiseOrValue<BigNumberish>,
      cashWithholdingBuffer10BPS: PromiseOrValue<BigNumberish>,
      liquidationHaircutPercentage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateVault(
      vaultAddress: PromiseOrValue<string>,
      vaultConfig: VaultConfigParamsStruct,
      maxPrimaryBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    upgradeBeacon(
      proxy: PromiseOrValue<BigNumberish>,
      newBeacon: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    withdraw(
      currencyId: PromiseOrValue<BigNumberish>,
      amountInternalPrecision: PromiseOrValue<BigNumberish>,
      redeemToUnderlying: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    accruePrimeInterest(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    balanceOf(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    balanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    batchBalanceAction(
      account: PromiseOrValue<string>,
      actions: BalanceActionStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    batchBalanceAndTradeAction(
      account: PromiseOrValue<string>,
      actions: BalanceActionWithTradesStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    batchBalanceAndTradeActionWithCallback(
      account: PromiseOrValue<string>,
      actions: BalanceActionWithTradesStruct[],
      callbackData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    batchLend(
      account: PromiseOrValue<string>,
      actions: BatchLendStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    borrowSecondaryCurrencyToVault(
      account: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      underlyingToBorrow: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      maxBorrowRate: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      minRollLendRate: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    calculateCollateralCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      collateralCurrency: PromiseOrValue<BigNumberish>,
      maxCollateralLiquidation: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    calculateDepositAmountInDeleverage(
      currencyIndex: PromiseOrValue<BigNumberish>,
      vaultAccount: VaultAccountStruct,
      vaultConfig: VaultConfigStruct,
      vaultState: VaultStateStruct,
      depositUnderlyingInternal: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    calculateLocalCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    calculateNTokensToMint(
      currencyId: PromiseOrValue<BigNumberish>,
      amountToDepositExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    calculatefCashCrossCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    calculatefCashLocalLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    checkVaultAccountCollateralRatio(
      vault: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    claimCOMPAndTransfer(
      ctokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    claimOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    convertCashBalanceToExternal(
      currencyId: PromiseOrValue<BigNumberish>,
      cashBalanceInternal: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    convertNTokenToUnderlying(
      currencyId: PromiseOrValue<BigNumberish>,
      nTokenBalance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    convertSettledfCash(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      fCashBalance: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    convertUnderlyingToPrimeCash(
      currencyId: PromiseOrValue<BigNumberish>,
      underlyingExternal: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    decodeERC1155Id(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    decodeToAssets(
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    deleverageAccount(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      liquidator: PromiseOrValue<string>,
      currencyIndex: PromiseOrValue<BigNumberish>,
      depositUnderlyingInternal: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    depositAssetToken(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      amountExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    depositUnderlyingToken(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      amountExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    enableBitmapCurrency(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    enableCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      cashGroup: CashGroupSettingsStruct,
      underlyingName: PromiseOrValue<string>,
      underlyingSymbol: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    enablePrimeBorrow(
      allowPrimeBorrow: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    enablePrimeDebt(
      currencyId: PromiseOrValue<BigNumberish>,
      underlyingName: PromiseOrValue<string>,
      underlyingSymbol: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    encode(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultAddress: PromiseOrValue<string>,
      isfCashDebt: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    encodeToId(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    enterVault(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      fCash: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      vaultData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    exitVault(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      vaultSharesToRedeem: PromiseOrValue<BigNumberish>,
      fCashToLend: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      exitVaultData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    getAccount(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getAccountBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getAccountContext(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getAccountPortfolio(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getAccountPrimeDebtBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getActiveMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getActiveMarketsAtBlockTime(
      currencyId: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getAssetsBitmap(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getAuthorizedCallbackContractStatus(
      callback: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getBalanceOfPrimeCash(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getBorrowCapacity(
      vault: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getCashAmountGivenfCashAmount(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashAmount: PromiseOrValue<BigNumberish>,
      marketIndex: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getCashGroup(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getCashGroupAndAssetRate(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getCurrency(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getCurrencyAndRates(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getCurrencyId(tokenAddress: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getDepositFromfCashLend(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashAmount: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getDepositParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getFreeCollateral(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getGlobalTransferOperatorStatus(
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getImplementation(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getInitializationParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getInterestRateCurve(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getMarket(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      settlementDate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getMarketIndex(
      maturity: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getMaxCurrencyId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getNTokenAccount(tokenAddress: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getNTokenPortfolio(tokenAddress: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getNoteToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getOwnershipStatus(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getPresentfCashValue(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      notional: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      riskAdjusted: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getPrimeCashHoldingsOracle(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getPrimeFactors(
      currencyId: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getPrimeFactorsStored(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getPrimeInterestRate(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getPrimeInterestRateCurve(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getPrincipalFromfCashBorrow(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashBorrow: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getRateStorage(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getRebalancingCooldown(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getRebalancingTarget(
      currencyId: PromiseOrValue<BigNumberish>,
      holding: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getReserveBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getReserveBuffer(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getSecondaryBorrow(
      vault: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getSecondaryIncentiveRewarder(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getSettlementRate(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getStoredTokenBalances(tokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getTotalfCashDebtOutstanding(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getTreasuryManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getVaultAccount(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getVaultAccountHealthFactors(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getVaultAccountSecondaryDebt(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getVaultAccountWithFeeAccrual(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getVaultConfig(vault: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getVaultState(
      vault: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getfCashAmountGivenCashAmount(
      currencyId: PromiseOrValue<BigNumberish>,
      netCashToAccount: PromiseOrValue<BigNumberish>,
      marketIndex: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getfCashBorrowFromPrincipal(
      currencyId: PromiseOrValue<BigNumberish>,
      borrowedAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getfCashLendFromDeposit(
      currencyId: PromiseOrValue<BigNumberish>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getfCashNotional(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getfCashRequiredToLiquidateCash(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      vaultAccountCashBalance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    initializeMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      isFirstInit: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    isApprovedForAll(
      account: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    liquidateCollateralCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      collateralCurrency: PromiseOrValue<BigNumberish>,
      maxCollateralLiquidation: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      withdrawCollateral: PromiseOrValue<boolean>,
      redeemToUnderlying: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    liquidateExcessVaultCash(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      liquidator: PromiseOrValue<string>,
      excessCashIndex: PromiseOrValue<BigNumberish>,
      debtIndex: PromiseOrValue<BigNumberish>,
      _depositUnderlyingInternal: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    liquidateLocalCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    liquidateVaultCashBalance(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      liquidator: PromiseOrValue<string>,
      currencyIndex: PromiseOrValue<BigNumberish>,
      fCashDeposit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    liquidatefCashCrossCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    liquidatefCashLocal(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    listCurrency(
      underlyingToken: TokenStorageStruct,
      ethRate: ETHRateStorageStruct,
      primeDebtCurve: InterestRateCurveSettingsStruct,
      primeCashHoldingsOracle: PromiseOrValue<string>,
      allowPrimeCashDebt: PromiseOrValue<boolean>,
      rateOracleTimeWindow5Min: PromiseOrValue<BigNumberish>,
      underlyingName: PromiseOrValue<string>,
      underlyingSymbol: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    nTokenAddress(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nTokenBalanceOf(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    nTokenClaimIncentives(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    nTokenGetClaimableIncentives(
      account: PromiseOrValue<string>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    nTokenPresentValueAssetDenominated(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    nTokenPresentValueUnderlyingDenominated(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    nTokenRedeem(
      redeemer: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      tokensToRedeem_: PromiseOrValue<BigNumberish>,
      sellTokenAssets: PromiseOrValue<boolean>,
      acceptResidualAssets: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    nTokenTotalSupply(nTokenAddress: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nTokenTransfer(
      currencyId: PromiseOrValue<BigNumberish>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    nTokenTransferAllowance(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    nTokenTransferApprove(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    nTokenTransferApproveAll(
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    nTokenTransferFrom(
      currencyId: PromiseOrValue<BigNumberish>,
      spender: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pCashAddress(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pCashTransfer(
      currencyId: PromiseOrValue<BigNumberish>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    pCashTransferAllowance(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    pCashTransferApprove(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    pCashTransferFrom(
      currencyId: PromiseOrValue<BigNumberish>,
      spender: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    pDebtAddress(currencyId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pauseGuardian(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pauseRouter(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rebalance(
      currencyId: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    repaySecondaryCurrencyFromVault(
      account: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      underlyingToRepay: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      minLendRate: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    rollVaultPosition(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      fCashToBorrow: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      enterVaultData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    safeBatchTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    safeTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setMaxBorrowCapacity(
      vaultAddress: PromiseOrValue<string>,
      maxVaultBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setMaxUnderlyingSupply(
      currencyId: PromiseOrValue<BigNumberish>,
      maxUnderlyingSupply: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setPauseRouterAndGuardian(
      pauseRouter_: PromiseOrValue<string>,
      pauseGuardian_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setRebalancingCooldown(
      currencyId: PromiseOrValue<BigNumberish>,
      cooldownTimeInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setRebalancingTargets(
      currencyId: PromiseOrValue<BigNumberish>,
      targets: NotionalTreasury.RebalancingTargetConfigStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setReserveBuffer(
      currencyId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setReserveCashBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      reserveBalance: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setTreasuryManager(
      manager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setVaultDeleverageStatus(
      vaultAddress: PromiseOrValue<string>,
      disableDeleverage: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setVaultPauseStatus(
      vaultAddress: PromiseOrValue<string>,
      enable: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    settleAccount(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    settleSecondaryBorrowForAccount(
      vault: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    settleVaultAccount(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    signedBalanceOf(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    signedBalanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    signedBalanceOfVaultTokenId(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    supportsInterface(interfaceId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    sweepCashIntoMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      direct: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    transferReserveToTreasury(
      currencies: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateAuthorizedCallbackContract(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      cashGroup: CashGroupSettingsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateDepositParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      depositShares: PromiseOrValue<BigNumberish>[],
      leverageThresholds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateETHRate(
      currencyId: PromiseOrValue<BigNumberish>,
      rateOracle: PromiseOrValue<string>,
      mustInvert: PromiseOrValue<boolean>,
      buffer: PromiseOrValue<BigNumberish>,
      haircut: PromiseOrValue<BigNumberish>,
      liquidationDiscount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateIncentiveEmissionRate(
      currencyId: PromiseOrValue<BigNumberish>,
      newEmissionRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateInitializationParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      annualizedAnchorRates: PromiseOrValue<BigNumberish>[],
      proportions: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateInterestRateCurve(
      currencyId: PromiseOrValue<BigNumberish>,
      marketIndices: PromiseOrValue<BigNumberish>[],
      settings: InterestRateCurveSettingsStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updatePrimeCashCurve(
      currencyId: PromiseOrValue<BigNumberish>,
      primeDebtCurve: InterestRateCurveSettingsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updatePrimeCashHoldingsOracle(
      currencyId: PromiseOrValue<BigNumberish>,
      primeCashHoldingsOracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateSecondaryBorrowCapacity(
      vaultAddress: PromiseOrValue<string>,
      secondaryCurrencyId: PromiseOrValue<BigNumberish>,
      maxBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateTokenCollateralParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      residualPurchaseIncentive10BPS: PromiseOrValue<BigNumberish>,
      pvHaircutPercentage: PromiseOrValue<BigNumberish>,
      residualPurchaseTimeBufferHours: PromiseOrValue<BigNumberish>,
      cashWithholdingBuffer10BPS: PromiseOrValue<BigNumberish>,
      liquidationHaircutPercentage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateVault(
      vaultAddress: PromiseOrValue<string>,
      vaultConfig: VaultConfigParamsStruct,
      maxPrimaryBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    upgradeBeacon(
      proxy: PromiseOrValue<BigNumberish>,
      newBeacon: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    withdraw(
      currencyId: PromiseOrValue<BigNumberish>,
      amountInternalPrecision: PromiseOrValue<BigNumberish>,
      redeemToUnderlying: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;
  };
}

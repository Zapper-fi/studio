/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export declare namespace IV3SwapRouter {
  export type ExactInputParamsStruct = {
    path: PromiseOrValue<BytesLike>;
    recipient: PromiseOrValue<string>;
    amountIn: PromiseOrValue<BigNumberish>;
    amountOutMinimum: PromiseOrValue<BigNumberish>;
  };

  export type ExactInputParamsStructOutput = [string, string, BigNumber, BigNumber] & {
    path: string;
    recipient: string;
    amountIn: BigNumber;
    amountOutMinimum: BigNumber;
  };

  export type ExactInputSingleParamsStruct = {
    tokenIn: PromiseOrValue<string>;
    tokenOut: PromiseOrValue<string>;
    fee: PromiseOrValue<BigNumberish>;
    recipient: PromiseOrValue<string>;
    amountIn: PromiseOrValue<BigNumberish>;
    amountOutMinimum: PromiseOrValue<BigNumberish>;
    sqrtPriceLimitX96: PromiseOrValue<BigNumberish>;
  };

  export type ExactInputSingleParamsStructOutput = [string, string, number, string, BigNumber, BigNumber, BigNumber] & {
    tokenIn: string;
    tokenOut: string;
    fee: number;
    recipient: string;
    amountIn: BigNumber;
    amountOutMinimum: BigNumber;
    sqrtPriceLimitX96: BigNumber;
  };

  export type ExactOutputParamsStruct = {
    path: PromiseOrValue<BytesLike>;
    recipient: PromiseOrValue<string>;
    amountOut: PromiseOrValue<BigNumberish>;
    amountInMaximum: PromiseOrValue<BigNumberish>;
  };

  export type ExactOutputParamsStructOutput = [string, string, BigNumber, BigNumber] & {
    path: string;
    recipient: string;
    amountOut: BigNumber;
    amountInMaximum: BigNumber;
  };

  export type ExactOutputSingleParamsStruct = {
    tokenIn: PromiseOrValue<string>;
    tokenOut: PromiseOrValue<string>;
    fee: PromiseOrValue<BigNumberish>;
    recipient: PromiseOrValue<string>;
    amountOut: PromiseOrValue<BigNumberish>;
    amountInMaximum: PromiseOrValue<BigNumberish>;
    sqrtPriceLimitX96: PromiseOrValue<BigNumberish>;
  };

  export type ExactOutputSingleParamsStructOutput = [
    string,
    string,
    number,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
  ] & {
    tokenIn: string;
    tokenOut: string;
    fee: number;
    recipient: string;
    amountOut: BigNumber;
    amountInMaximum: BigNumber;
    sqrtPriceLimitX96: BigNumber;
  };
}

export declare namespace IApproveAndCall {
  export type IncreaseLiquidityParamsStruct = {
    token0: PromiseOrValue<string>;
    token1: PromiseOrValue<string>;
    tokenId: PromiseOrValue<BigNumberish>;
    amount0Min: PromiseOrValue<BigNumberish>;
    amount1Min: PromiseOrValue<BigNumberish>;
  };

  export type IncreaseLiquidityParamsStructOutput = [string, string, BigNumber, BigNumber, BigNumber] & {
    token0: string;
    token1: string;
    tokenId: BigNumber;
    amount0Min: BigNumber;
    amount1Min: BigNumber;
  };

  export type MintParamsStruct = {
    token0: PromiseOrValue<string>;
    token1: PromiseOrValue<string>;
    fee: PromiseOrValue<BigNumberish>;
    tickLower: PromiseOrValue<BigNumberish>;
    tickUpper: PromiseOrValue<BigNumberish>;
    amount0Min: PromiseOrValue<BigNumberish>;
    amount1Min: PromiseOrValue<BigNumberish>;
    recipient: PromiseOrValue<string>;
  };

  export type MintParamsStructOutput = [string, string, number, number, number, BigNumber, BigNumber, string] & {
    token0: string;
    token1: string;
    fee: number;
    tickLower: number;
    tickUpper: number;
    amount0Min: BigNumber;
    amount1Min: BigNumber;
    recipient: string;
  };
}

export interface PancakeswapSmartRouterInterface extends utils.Interface {
  functions: {
    'WETH9()': FunctionFragment;
    'approveMax(address)': FunctionFragment;
    'approveMaxMinusOne(address)': FunctionFragment;
    'approveZeroThenMax(address)': FunctionFragment;
    'approveZeroThenMaxMinusOne(address)': FunctionFragment;
    'callPositionManager(bytes)': FunctionFragment;
    'checkOracleSlippage(bytes[],uint128[],uint24,uint32)': FunctionFragment;
    'checkOracleSlippage(bytes,uint24,uint32)': FunctionFragment;
    'deployer()': FunctionFragment;
    'exactInput((bytes,address,uint256,uint256))': FunctionFragment;
    'exactInputSingle((address,address,uint24,address,uint256,uint256,uint160))': FunctionFragment;
    'exactInputStableSwap(address[],uint256[],uint256,uint256,address)': FunctionFragment;
    'exactOutput((bytes,address,uint256,uint256))': FunctionFragment;
    'exactOutputSingle((address,address,uint24,address,uint256,uint256,uint160))': FunctionFragment;
    'exactOutputStableSwap(address[],uint256[],uint256,uint256,address)': FunctionFragment;
    'factory()': FunctionFragment;
    'factoryV2()': FunctionFragment;
    'getApprovalType(address,uint256)': FunctionFragment;
    'increaseLiquidity((address,address,uint256,uint256,uint256))': FunctionFragment;
    'mint((address,address,uint24,int24,int24,uint256,uint256,address))': FunctionFragment;
    'multicall(bytes32,bytes[])': FunctionFragment;
    'multicall(uint256,bytes[])': FunctionFragment;
    'multicall(bytes[])': FunctionFragment;
    'owner()': FunctionFragment;
    'pancakeV3SwapCallback(int256,int256,bytes)': FunctionFragment;
    'positionManager()': FunctionFragment;
    'pull(address,uint256)': FunctionFragment;
    'refundETH()': FunctionFragment;
    'renounceOwnership()': FunctionFragment;
    'selfPermit(address,uint256,uint256,uint8,bytes32,bytes32)': FunctionFragment;
    'selfPermitAllowed(address,uint256,uint256,uint8,bytes32,bytes32)': FunctionFragment;
    'selfPermitAllowedIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)': FunctionFragment;
    'selfPermitIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)': FunctionFragment;
    'setStableSwap(address,address)': FunctionFragment;
    'stableSwapFactory()': FunctionFragment;
    'stableSwapInfo()': FunctionFragment;
    'swapExactTokensForTokens(uint256,uint256,address[],address)': FunctionFragment;
    'swapTokensForExactTokens(uint256,uint256,address[],address)': FunctionFragment;
    'sweepToken(address,uint256,address)': FunctionFragment;
    'sweepToken(address,uint256)': FunctionFragment;
    'sweepTokenWithFee(address,uint256,uint256,address)': FunctionFragment;
    'sweepTokenWithFee(address,uint256,address,uint256,address)': FunctionFragment;
    'transferOwnership(address)': FunctionFragment;
    'unwrapWETH9(uint256,address)': FunctionFragment;
    'unwrapWETH9WithFee(uint256,address,uint256,address)': FunctionFragment;
    'unwrapWETH9WithFee(uint256,uint256,address)': FunctionFragment;
    'wrapETH(uint256)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'WETH9'
      | 'approveMax'
      | 'approveMaxMinusOne'
      | 'approveZeroThenMax'
      | 'approveZeroThenMaxMinusOne'
      | 'callPositionManager'
      | 'checkOracleSlippage(bytes[],uint128[],uint24,uint32)'
      | 'checkOracleSlippage(bytes,uint24,uint32)'
      | 'deployer'
      | 'exactInput'
      | 'exactInputSingle'
      | 'exactInputStableSwap'
      | 'exactOutput'
      | 'exactOutputSingle'
      | 'exactOutputStableSwap'
      | 'factory'
      | 'factoryV2'
      | 'getApprovalType'
      | 'increaseLiquidity'
      | 'mint'
      | 'multicall(bytes32,bytes[])'
      | 'multicall(uint256,bytes[])'
      | 'multicall(bytes[])'
      | 'owner'
      | 'pancakeV3SwapCallback'
      | 'positionManager'
      | 'pull'
      | 'refundETH'
      | 'renounceOwnership'
      | 'selfPermit'
      | 'selfPermitAllowed'
      | 'selfPermitAllowedIfNecessary'
      | 'selfPermitIfNecessary'
      | 'setStableSwap'
      | 'stableSwapFactory'
      | 'stableSwapInfo'
      | 'swapExactTokensForTokens'
      | 'swapTokensForExactTokens'
      | 'sweepToken(address,uint256,address)'
      | 'sweepToken(address,uint256)'
      | 'sweepTokenWithFee(address,uint256,uint256,address)'
      | 'sweepTokenWithFee(address,uint256,address,uint256,address)'
      | 'transferOwnership'
      | 'unwrapWETH9'
      | 'unwrapWETH9WithFee(uint256,address,uint256,address)'
      | 'unwrapWETH9WithFee(uint256,uint256,address)'
      | 'wrapETH',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'WETH9', values?: undefined): string;
  encodeFunctionData(functionFragment: 'approveMax', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'approveMaxMinusOne', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'approveZeroThenMax', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'approveZeroThenMaxMinusOne', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'callPositionManager', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(
    functionFragment: 'checkOracleSlippage(bytes[],uint128[],uint24,uint32)',
    values: [
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'checkOracleSlippage(bytes,uint24,uint32)',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'deployer', values?: undefined): string;
  encodeFunctionData(functionFragment: 'exactInput', values: [IV3SwapRouter.ExactInputParamsStruct]): string;
  encodeFunctionData(
    functionFragment: 'exactInputSingle',
    values: [IV3SwapRouter.ExactInputSingleParamsStruct],
  ): string;
  encodeFunctionData(
    functionFragment: 'exactInputStableSwap',
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'exactOutput', values: [IV3SwapRouter.ExactOutputParamsStruct]): string;
  encodeFunctionData(
    functionFragment: 'exactOutputSingle',
    values: [IV3SwapRouter.ExactOutputSingleParamsStruct],
  ): string;
  encodeFunctionData(
    functionFragment: 'exactOutputStableSwap',
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'factory', values?: undefined): string;
  encodeFunctionData(functionFragment: 'factoryV2', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'getApprovalType',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'increaseLiquidity',
    values: [IApproveAndCall.IncreaseLiquidityParamsStruct],
  ): string;
  encodeFunctionData(functionFragment: 'mint', values: [IApproveAndCall.MintParamsStruct]): string;
  encodeFunctionData(
    functionFragment: 'multicall(bytes32,bytes[])',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'multicall(uint256,bytes[])',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>[]],
  ): string;
  encodeFunctionData(functionFragment: 'multicall(bytes[])', values: [PromiseOrValue<BytesLike>[]]): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'pancakeV3SwapCallback',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(functionFragment: 'positionManager', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pull', values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'refundETH', values?: undefined): string;
  encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'selfPermit',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'selfPermitAllowed',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'selfPermitAllowedIfNecessary',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'selfPermitIfNecessary',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'setStableSwap',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'stableSwapFactory', values?: undefined): string;
  encodeFunctionData(functionFragment: 'stableSwapInfo', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'swapExactTokensForTokens',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>[],
      PromiseOrValue<string>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'swapTokensForExactTokens',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>[],
      PromiseOrValue<string>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'sweepToken(address,uint256,address)',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'sweepToken(address,uint256)',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'sweepTokenWithFee(address,uint256,uint256,address)',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'sweepTokenWithFee(address,uint256,address,uint256,address)',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'transferOwnership', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'unwrapWETH9',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'unwrapWETH9WithFee(uint256,address,uint256,address)',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'unwrapWETH9WithFee(uint256,uint256,address)',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'wrapETH', values: [PromiseOrValue<BigNumberish>]): string;

  decodeFunctionResult(functionFragment: 'WETH9', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'approveMax', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'approveMaxMinusOne', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'approveZeroThenMax', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'approveZeroThenMaxMinusOne', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'callPositionManager', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'checkOracleSlippage(bytes[],uint128[],uint24,uint32)',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'checkOracleSlippage(bytes,uint24,uint32)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deployer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exactInput', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exactInputSingle', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exactInputStableSwap', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exactOutput', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exactOutputSingle', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exactOutputStableSwap', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'factory', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'factoryV2', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getApprovalType', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'increaseLiquidity', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'mint', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'multicall(bytes32,bytes[])', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'multicall(uint256,bytes[])', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'multicall(bytes[])', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pancakeV3SwapCallback', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'positionManager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pull', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'refundETH', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'selfPermit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'selfPermitAllowed', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'selfPermitAllowedIfNecessary', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'selfPermitIfNecessary', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setStableSwap', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stableSwapFactory', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stableSwapInfo', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'swapExactTokensForTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'swapTokensForExactTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'sweepToken(address,uint256,address)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'sweepToken(address,uint256)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'sweepTokenWithFee(address,uint256,uint256,address)', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'sweepTokenWithFee(address,uint256,address,uint256,address)',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'unwrapWETH9', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'unwrapWETH9WithFee(uint256,address,uint256,address)',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'unwrapWETH9WithFee(uint256,uint256,address)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'wrapETH', data: BytesLike): Result;

  events: {
    'OwnershipTransferred(address,address)': EventFragment;
    'SetStableSwap(address,address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SetStableSwap'): EventFragment;
}

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<[string, string], OwnershipTransferredEventObject>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export interface SetStableSwapEventObject {
  factory: string;
  info: string;
}
export type SetStableSwapEvent = TypedEvent<[string, string], SetStableSwapEventObject>;

export type SetStableSwapEventFilter = TypedEventFilter<SetStableSwapEvent>;

export interface PancakeswapSmartRouter extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: PancakeswapSmartRouterInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    WETH9(overrides?: CallOverrides): Promise<[string]>;

    approveMax(
      token: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    approveMaxMinusOne(
      token: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    approveZeroThenMax(
      token: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    approveZeroThenMaxMinusOne(
      token: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    callPositionManager(
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'checkOracleSlippage(bytes[],uint128[],uint24,uint32)'(
      paths: PromiseOrValue<BytesLike>[],
      amounts: PromiseOrValue<BigNumberish>[],
      maximumTickDivergence: PromiseOrValue<BigNumberish>,
      secondsAgo: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[void]>;

    'checkOracleSlippage(bytes,uint24,uint32)'(
      path: PromiseOrValue<BytesLike>,
      maximumTickDivergence: PromiseOrValue<BigNumberish>,
      secondsAgo: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[void]>;

    deployer(overrides?: CallOverrides): Promise<[string]>;

    exactInput(
      params: IV3SwapRouter.ExactInputParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    exactInputSingle(
      params: IV3SwapRouter.ExactInputSingleParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    exactInputStableSwap(
      path: PromiseOrValue<string>[],
      flag: PromiseOrValue<BigNumberish>[],
      amountIn: PromiseOrValue<BigNumberish>,
      amountOutMin: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    exactOutput(
      params: IV3SwapRouter.ExactOutputParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    exactOutputSingle(
      params: IV3SwapRouter.ExactOutputSingleParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    exactOutputStableSwap(
      path: PromiseOrValue<string>[],
      flag: PromiseOrValue<BigNumberish>[],
      amountOut: PromiseOrValue<BigNumberish>,
      amountInMax: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    factory(overrides?: CallOverrides): Promise<[string]>;

    factoryV2(overrides?: CallOverrides): Promise<[string]>;

    getApprovalType(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    increaseLiquidity(
      params: IApproveAndCall.IncreaseLiquidityParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    mint(
      params: IApproveAndCall.MintParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'multicall(bytes32,bytes[])'(
      previousBlockhash: PromiseOrValue<BytesLike>,
      data: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'multicall(uint256,bytes[])'(
      deadline: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'multicall(bytes[])'(
      data: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pancakeV3SwapCallback(
      amount0Delta: PromiseOrValue<BigNumberish>,
      amount1Delta: PromiseOrValue<BigNumberish>,
      _data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    positionManager(overrides?: CallOverrides): Promise<[string]>;

    pull(
      token: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    refundETH(overrides?: PayableOverrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    selfPermit(
      token: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    selfPermitAllowed(
      token: PromiseOrValue<string>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    selfPermitAllowedIfNecessary(
      token: PromiseOrValue<string>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    selfPermitIfNecessary(
      token: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setStableSwap(
      _factory: PromiseOrValue<string>,
      _info: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    stableSwapFactory(overrides?: CallOverrides): Promise<[string]>;

    stableSwapInfo(overrides?: CallOverrides): Promise<[string]>;

    swapExactTokensForTokens(
      amountIn: PromiseOrValue<BigNumberish>,
      amountOutMin: PromiseOrValue<BigNumberish>,
      path: PromiseOrValue<string>[],
      to: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    swapTokensForExactTokens(
      amountOut: PromiseOrValue<BigNumberish>,
      amountInMax: PromiseOrValue<BigNumberish>,
      path: PromiseOrValue<string>[],
      to: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'sweepToken(address,uint256,address)'(
      token: PromiseOrValue<string>,
      amountMinimum: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'sweepToken(address,uint256)'(
      token: PromiseOrValue<string>,
      amountMinimum: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'sweepTokenWithFee(address,uint256,uint256,address)'(
      token: PromiseOrValue<string>,
      amountMinimum: PromiseOrValue<BigNumberish>,
      feeBips: PromiseOrValue<BigNumberish>,
      feeRecipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'sweepTokenWithFee(address,uint256,address,uint256,address)'(
      token: PromiseOrValue<string>,
      amountMinimum: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      feeBips: PromiseOrValue<BigNumberish>,
      feeRecipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    unwrapWETH9(
      amountMinimum: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'unwrapWETH9WithFee(uint256,address,uint256,address)'(
      amountMinimum: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      feeBips: PromiseOrValue<BigNumberish>,
      feeRecipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'unwrapWETH9WithFee(uint256,uint256,address)'(
      amountMinimum: PromiseOrValue<BigNumberish>,
      feeBips: PromiseOrValue<BigNumberish>,
      feeRecipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    wrapETH(
      value: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;
  };

  WETH9(overrides?: CallOverrides): Promise<string>;

  approveMax(
    token: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  approveMaxMinusOne(
    token: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  approveZeroThenMax(
    token: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  approveZeroThenMaxMinusOne(
    token: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callPositionManager(
    data: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'checkOracleSlippage(bytes[],uint128[],uint24,uint32)'(
    paths: PromiseOrValue<BytesLike>[],
    amounts: PromiseOrValue<BigNumberish>[],
    maximumTickDivergence: PromiseOrValue<BigNumberish>,
    secondsAgo: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<void>;

  'checkOracleSlippage(bytes,uint24,uint32)'(
    path: PromiseOrValue<BytesLike>,
    maximumTickDivergence: PromiseOrValue<BigNumberish>,
    secondsAgo: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<void>;

  deployer(overrides?: CallOverrides): Promise<string>;

  exactInput(
    params: IV3SwapRouter.ExactInputParamsStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  exactInputSingle(
    params: IV3SwapRouter.ExactInputSingleParamsStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  exactInputStableSwap(
    path: PromiseOrValue<string>[],
    flag: PromiseOrValue<BigNumberish>[],
    amountIn: PromiseOrValue<BigNumberish>,
    amountOutMin: PromiseOrValue<BigNumberish>,
    to: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  exactOutput(
    params: IV3SwapRouter.ExactOutputParamsStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  exactOutputSingle(
    params: IV3SwapRouter.ExactOutputSingleParamsStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  exactOutputStableSwap(
    path: PromiseOrValue<string>[],
    flag: PromiseOrValue<BigNumberish>[],
    amountOut: PromiseOrValue<BigNumberish>,
    amountInMax: PromiseOrValue<BigNumberish>,
    to: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  factory(overrides?: CallOverrides): Promise<string>;

  factoryV2(overrides?: CallOverrides): Promise<string>;

  getApprovalType(
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  increaseLiquidity(
    params: IApproveAndCall.IncreaseLiquidityParamsStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  mint(
    params: IApproveAndCall.MintParamsStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'multicall(bytes32,bytes[])'(
    previousBlockhash: PromiseOrValue<BytesLike>,
    data: PromiseOrValue<BytesLike>[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'multicall(uint256,bytes[])'(
    deadline: PromiseOrValue<BigNumberish>,
    data: PromiseOrValue<BytesLike>[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'multicall(bytes[])'(
    data: PromiseOrValue<BytesLike>[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  pancakeV3SwapCallback(
    amount0Delta: PromiseOrValue<BigNumberish>,
    amount1Delta: PromiseOrValue<BigNumberish>,
    _data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  positionManager(overrides?: CallOverrides): Promise<string>;

  pull(
    token: PromiseOrValue<string>,
    value: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  refundETH(overrides?: PayableOverrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  selfPermit(
    token: PromiseOrValue<string>,
    value: PromiseOrValue<BigNumberish>,
    deadline: PromiseOrValue<BigNumberish>,
    v: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    s: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  selfPermitAllowed(
    token: PromiseOrValue<string>,
    nonce: PromiseOrValue<BigNumberish>,
    expiry: PromiseOrValue<BigNumberish>,
    v: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    s: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  selfPermitAllowedIfNecessary(
    token: PromiseOrValue<string>,
    nonce: PromiseOrValue<BigNumberish>,
    expiry: PromiseOrValue<BigNumberish>,
    v: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    s: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  selfPermitIfNecessary(
    token: PromiseOrValue<string>,
    value: PromiseOrValue<BigNumberish>,
    deadline: PromiseOrValue<BigNumberish>,
    v: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    s: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setStableSwap(
    _factory: PromiseOrValue<string>,
    _info: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  stableSwapFactory(overrides?: CallOverrides): Promise<string>;

  stableSwapInfo(overrides?: CallOverrides): Promise<string>;

  swapExactTokensForTokens(
    amountIn: PromiseOrValue<BigNumberish>,
    amountOutMin: PromiseOrValue<BigNumberish>,
    path: PromiseOrValue<string>[],
    to: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  swapTokensForExactTokens(
    amountOut: PromiseOrValue<BigNumberish>,
    amountInMax: PromiseOrValue<BigNumberish>,
    path: PromiseOrValue<string>[],
    to: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'sweepToken(address,uint256,address)'(
    token: PromiseOrValue<string>,
    amountMinimum: PromiseOrValue<BigNumberish>,
    recipient: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'sweepToken(address,uint256)'(
    token: PromiseOrValue<string>,
    amountMinimum: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'sweepTokenWithFee(address,uint256,uint256,address)'(
    token: PromiseOrValue<string>,
    amountMinimum: PromiseOrValue<BigNumberish>,
    feeBips: PromiseOrValue<BigNumberish>,
    feeRecipient: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'sweepTokenWithFee(address,uint256,address,uint256,address)'(
    token: PromiseOrValue<string>,
    amountMinimum: PromiseOrValue<BigNumberish>,
    recipient: PromiseOrValue<string>,
    feeBips: PromiseOrValue<BigNumberish>,
    feeRecipient: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  unwrapWETH9(
    amountMinimum: PromiseOrValue<BigNumberish>,
    recipient: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'unwrapWETH9WithFee(uint256,address,uint256,address)'(
    amountMinimum: PromiseOrValue<BigNumberish>,
    recipient: PromiseOrValue<string>,
    feeBips: PromiseOrValue<BigNumberish>,
    feeRecipient: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'unwrapWETH9WithFee(uint256,uint256,address)'(
    amountMinimum: PromiseOrValue<BigNumberish>,
    feeBips: PromiseOrValue<BigNumberish>,
    feeRecipient: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  wrapETH(
    value: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    WETH9(overrides?: CallOverrides): Promise<string>;

    approveMax(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    approveMaxMinusOne(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    approveZeroThenMax(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    approveZeroThenMaxMinusOne(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    callPositionManager(data: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

    'checkOracleSlippage(bytes[],uint128[],uint24,uint32)'(
      paths: PromiseOrValue<BytesLike>[],
      amounts: PromiseOrValue<BigNumberish>[],
      maximumTickDivergence: PromiseOrValue<BigNumberish>,
      secondsAgo: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    'checkOracleSlippage(bytes,uint24,uint32)'(
      path: PromiseOrValue<BytesLike>,
      maximumTickDivergence: PromiseOrValue<BigNumberish>,
      secondsAgo: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    deployer(overrides?: CallOverrides): Promise<string>;

    exactInput(params: IV3SwapRouter.ExactInputParamsStruct, overrides?: CallOverrides): Promise<BigNumber>;

    exactInputSingle(params: IV3SwapRouter.ExactInputSingleParamsStruct, overrides?: CallOverrides): Promise<BigNumber>;

    exactInputStableSwap(
      path: PromiseOrValue<string>[],
      flag: PromiseOrValue<BigNumberish>[],
      amountIn: PromiseOrValue<BigNumberish>,
      amountOutMin: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    exactOutput(params: IV3SwapRouter.ExactOutputParamsStruct, overrides?: CallOverrides): Promise<BigNumber>;

    exactOutputSingle(
      params: IV3SwapRouter.ExactOutputSingleParamsStruct,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    exactOutputStableSwap(
      path: PromiseOrValue<string>[],
      flag: PromiseOrValue<BigNumberish>[],
      amountOut: PromiseOrValue<BigNumberish>,
      amountInMax: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    factory(overrides?: CallOverrides): Promise<string>;

    factoryV2(overrides?: CallOverrides): Promise<string>;

    getApprovalType(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<number>;

    increaseLiquidity(
      params: IApproveAndCall.IncreaseLiquidityParamsStruct,
      overrides?: CallOverrides,
    ): Promise<string>;

    mint(params: IApproveAndCall.MintParamsStruct, overrides?: CallOverrides): Promise<string>;

    'multicall(bytes32,bytes[])'(
      previousBlockhash: PromiseOrValue<BytesLike>,
      data: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides,
    ): Promise<string[]>;

    'multicall(uint256,bytes[])'(
      deadline: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides,
    ): Promise<string[]>;

    'multicall(bytes[])'(data: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<string[]>;

    owner(overrides?: CallOverrides): Promise<string>;

    pancakeV3SwapCallback(
      amount0Delta: PromiseOrValue<BigNumberish>,
      amount1Delta: PromiseOrValue<BigNumberish>,
      _data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    positionManager(overrides?: CallOverrides): Promise<string>;

    pull(token: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    refundETH(overrides?: CallOverrides): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    selfPermit(
      token: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    selfPermitAllowed(
      token: PromiseOrValue<string>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    selfPermitAllowedIfNecessary(
      token: PromiseOrValue<string>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    selfPermitIfNecessary(
      token: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setStableSwap(
      _factory: PromiseOrValue<string>,
      _info: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    stableSwapFactory(overrides?: CallOverrides): Promise<string>;

    stableSwapInfo(overrides?: CallOverrides): Promise<string>;

    swapExactTokensForTokens(
      amountIn: PromiseOrValue<BigNumberish>,
      amountOutMin: PromiseOrValue<BigNumberish>,
      path: PromiseOrValue<string>[],
      to: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    swapTokensForExactTokens(
      amountOut: PromiseOrValue<BigNumberish>,
      amountInMax: PromiseOrValue<BigNumberish>,
      path: PromiseOrValue<string>[],
      to: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    'sweepToken(address,uint256,address)'(
      token: PromiseOrValue<string>,
      amountMinimum: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    'sweepToken(address,uint256)'(
      token: PromiseOrValue<string>,
      amountMinimum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    'sweepTokenWithFee(address,uint256,uint256,address)'(
      token: PromiseOrValue<string>,
      amountMinimum: PromiseOrValue<BigNumberish>,
      feeBips: PromiseOrValue<BigNumberish>,
      feeRecipient: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    'sweepTokenWithFee(address,uint256,address,uint256,address)'(
      token: PromiseOrValue<string>,
      amountMinimum: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      feeBips: PromiseOrValue<BigNumberish>,
      feeRecipient: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    transferOwnership(newOwner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    unwrapWETH9(
      amountMinimum: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    'unwrapWETH9WithFee(uint256,address,uint256,address)'(
      amountMinimum: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      feeBips: PromiseOrValue<BigNumberish>,
      feeRecipient: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    'unwrapWETH9WithFee(uint256,uint256,address)'(
      amountMinimum: PromiseOrValue<BigNumberish>,
      feeBips: PromiseOrValue<BigNumberish>,
      feeRecipient: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    wrapETH(value: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
  };

  filters: {
    'OwnershipTransferred(address,address)'(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;

    'SetStableSwap(address,address)'(
      factory?: PromiseOrValue<string> | null,
      info?: PromiseOrValue<string> | null,
    ): SetStableSwapEventFilter;
    SetStableSwap(
      factory?: PromiseOrValue<string> | null,
      info?: PromiseOrValue<string> | null,
    ): SetStableSwapEventFilter;
  };

  estimateGas: {
    WETH9(overrides?: CallOverrides): Promise<BigNumber>;

    approveMax(
      token: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    approveMaxMinusOne(
      token: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    approveZeroThenMax(
      token: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    approveZeroThenMaxMinusOne(
      token: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    callPositionManager(
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'checkOracleSlippage(bytes[],uint128[],uint24,uint32)'(
      paths: PromiseOrValue<BytesLike>[],
      amounts: PromiseOrValue<BigNumberish>[],
      maximumTickDivergence: PromiseOrValue<BigNumberish>,
      secondsAgo: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    'checkOracleSlippage(bytes,uint24,uint32)'(
      path: PromiseOrValue<BytesLike>,
      maximumTickDivergence: PromiseOrValue<BigNumberish>,
      secondsAgo: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    deployer(overrides?: CallOverrides): Promise<BigNumber>;

    exactInput(
      params: IV3SwapRouter.ExactInputParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    exactInputSingle(
      params: IV3SwapRouter.ExactInputSingleParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    exactInputStableSwap(
      path: PromiseOrValue<string>[],
      flag: PromiseOrValue<BigNumberish>[],
      amountIn: PromiseOrValue<BigNumberish>,
      amountOutMin: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    exactOutput(
      params: IV3SwapRouter.ExactOutputParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    exactOutputSingle(
      params: IV3SwapRouter.ExactOutputSingleParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    exactOutputStableSwap(
      path: PromiseOrValue<string>[],
      flag: PromiseOrValue<BigNumberish>[],
      amountOut: PromiseOrValue<BigNumberish>,
      amountInMax: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    factory(overrides?: CallOverrides): Promise<BigNumber>;

    factoryV2(overrides?: CallOverrides): Promise<BigNumber>;

    getApprovalType(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    increaseLiquidity(
      params: IApproveAndCall.IncreaseLiquidityParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    mint(
      params: IApproveAndCall.MintParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'multicall(bytes32,bytes[])'(
      previousBlockhash: PromiseOrValue<BytesLike>,
      data: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'multicall(uint256,bytes[])'(
      deadline: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'multicall(bytes[])'(
      data: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pancakeV3SwapCallback(
      amount0Delta: PromiseOrValue<BigNumberish>,
      amount1Delta: PromiseOrValue<BigNumberish>,
      _data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    positionManager(overrides?: CallOverrides): Promise<BigNumber>;

    pull(
      token: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    refundETH(overrides?: PayableOverrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    selfPermit(
      token: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    selfPermitAllowed(
      token: PromiseOrValue<string>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    selfPermitAllowedIfNecessary(
      token: PromiseOrValue<string>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    selfPermitIfNecessary(
      token: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setStableSwap(
      _factory: PromiseOrValue<string>,
      _info: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    stableSwapFactory(overrides?: CallOverrides): Promise<BigNumber>;

    stableSwapInfo(overrides?: CallOverrides): Promise<BigNumber>;

    swapExactTokensForTokens(
      amountIn: PromiseOrValue<BigNumberish>,
      amountOutMin: PromiseOrValue<BigNumberish>,
      path: PromiseOrValue<string>[],
      to: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    swapTokensForExactTokens(
      amountOut: PromiseOrValue<BigNumberish>,
      amountInMax: PromiseOrValue<BigNumberish>,
      path: PromiseOrValue<string>[],
      to: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'sweepToken(address,uint256,address)'(
      token: PromiseOrValue<string>,
      amountMinimum: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'sweepToken(address,uint256)'(
      token: PromiseOrValue<string>,
      amountMinimum: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'sweepTokenWithFee(address,uint256,uint256,address)'(
      token: PromiseOrValue<string>,
      amountMinimum: PromiseOrValue<BigNumberish>,
      feeBips: PromiseOrValue<BigNumberish>,
      feeRecipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'sweepTokenWithFee(address,uint256,address,uint256,address)'(
      token: PromiseOrValue<string>,
      amountMinimum: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      feeBips: PromiseOrValue<BigNumberish>,
      feeRecipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    unwrapWETH9(
      amountMinimum: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'unwrapWETH9WithFee(uint256,address,uint256,address)'(
      amountMinimum: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      feeBips: PromiseOrValue<BigNumberish>,
      feeRecipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'unwrapWETH9WithFee(uint256,uint256,address)'(
      amountMinimum: PromiseOrValue<BigNumberish>,
      feeBips: PromiseOrValue<BigNumberish>,
      feeRecipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    wrapETH(
      value: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    WETH9(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    approveMax(
      token: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    approveMaxMinusOne(
      token: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    approveZeroThenMax(
      token: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    approveZeroThenMaxMinusOne(
      token: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    callPositionManager(
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'checkOracleSlippage(bytes[],uint128[],uint24,uint32)'(
      paths: PromiseOrValue<BytesLike>[],
      amounts: PromiseOrValue<BigNumberish>[],
      maximumTickDivergence: PromiseOrValue<BigNumberish>,
      secondsAgo: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    'checkOracleSlippage(bytes,uint24,uint32)'(
      path: PromiseOrValue<BytesLike>,
      maximumTickDivergence: PromiseOrValue<BigNumberish>,
      secondsAgo: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    deployer(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    exactInput(
      params: IV3SwapRouter.ExactInputParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    exactInputSingle(
      params: IV3SwapRouter.ExactInputSingleParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    exactInputStableSwap(
      path: PromiseOrValue<string>[],
      flag: PromiseOrValue<BigNumberish>[],
      amountIn: PromiseOrValue<BigNumberish>,
      amountOutMin: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    exactOutput(
      params: IV3SwapRouter.ExactOutputParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    exactOutputSingle(
      params: IV3SwapRouter.ExactOutputSingleParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    exactOutputStableSwap(
      path: PromiseOrValue<string>[],
      flag: PromiseOrValue<BigNumberish>[],
      amountOut: PromiseOrValue<BigNumberish>,
      amountInMax: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    factory(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    factoryV2(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getApprovalType(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    increaseLiquidity(
      params: IApproveAndCall.IncreaseLiquidityParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    mint(
      params: IApproveAndCall.MintParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'multicall(bytes32,bytes[])'(
      previousBlockhash: PromiseOrValue<BytesLike>,
      data: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'multicall(uint256,bytes[])'(
      deadline: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'multicall(bytes[])'(
      data: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pancakeV3SwapCallback(
      amount0Delta: PromiseOrValue<BigNumberish>,
      amount1Delta: PromiseOrValue<BigNumberish>,
      _data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    positionManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pull(
      token: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    refundETH(overrides?: PayableOverrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    selfPermit(
      token: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    selfPermitAllowed(
      token: PromiseOrValue<string>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    selfPermitAllowedIfNecessary(
      token: PromiseOrValue<string>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    selfPermitIfNecessary(
      token: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setStableSwap(
      _factory: PromiseOrValue<string>,
      _info: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    stableSwapFactory(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    stableSwapInfo(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    swapExactTokensForTokens(
      amountIn: PromiseOrValue<BigNumberish>,
      amountOutMin: PromiseOrValue<BigNumberish>,
      path: PromiseOrValue<string>[],
      to: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    swapTokensForExactTokens(
      amountOut: PromiseOrValue<BigNumberish>,
      amountInMax: PromiseOrValue<BigNumberish>,
      path: PromiseOrValue<string>[],
      to: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'sweepToken(address,uint256,address)'(
      token: PromiseOrValue<string>,
      amountMinimum: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'sweepToken(address,uint256)'(
      token: PromiseOrValue<string>,
      amountMinimum: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'sweepTokenWithFee(address,uint256,uint256,address)'(
      token: PromiseOrValue<string>,
      amountMinimum: PromiseOrValue<BigNumberish>,
      feeBips: PromiseOrValue<BigNumberish>,
      feeRecipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'sweepTokenWithFee(address,uint256,address,uint256,address)'(
      token: PromiseOrValue<string>,
      amountMinimum: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      feeBips: PromiseOrValue<BigNumberish>,
      feeRecipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    unwrapWETH9(
      amountMinimum: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'unwrapWETH9WithFee(uint256,address,uint256,address)'(
      amountMinimum: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      feeBips: PromiseOrValue<BigNumberish>,
      feeRecipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'unwrapWETH9WithFee(uint256,uint256,address)'(
      amountMinimum: PromiseOrValue<BigNumberish>,
      feeBips: PromiseOrValue<BigNumberish>,
      feeRecipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    wrapETH(
      value: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;
  };
}

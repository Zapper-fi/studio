/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export interface ReflexerUniswapV2SafeSaviorInterface extends utils.Interface {
  functions: {
    'HUNDRED()': FunctionFragment;
    'MAX_UINT()': FunctionFragment;
    'ONE()': FunctionFragment;
    'RAY()': FunctionFragment;
    'THOUSAND()': FunctionFragment;
    'WAD()': FunctionFragment;
    'WAD_COMPLEMENT()': FunctionFragment;
    'addAuthorization(address)': FunctionFragment;
    'allowUser(address)': FunctionFragment;
    'allowedUsers(address)': FunctionFragment;
    'authorizedAccounts(address)': FunctionFragment;
    'cRatioSetter()': FunctionFragment;
    'canSave(bytes32,address)': FunctionFragment;
    'coinJoin()': FunctionFragment;
    'collateralJoin()': FunctionFragment;
    'collateralToken()': FunctionFragment;
    'debtBelowFloor(bytes32,uint256)': FunctionFragment;
    'deposit(uint256,uint256)': FunctionFragment;
    'disallowUser(address)': FunctionFragment;
    'getAccumulatedRate(bytes32)': FunctionFragment;
    'getCollateralPrice()': FunctionFragment;
    'getKeeperPayoutTokens(address,uint256,uint256,uint256)': FunctionFragment;
    'getKeeperPayoutValue()': FunctionFragment;
    'getLPUnderlying(address)': FunctionFragment;
    'getReserves(uint256,address)': FunctionFragment;
    'getSystemCoinMarketPrice()': FunctionFragment;
    'getTargetCRatio(address)': FunctionFragment;
    'getTokensForSaving(address,uint256)': FunctionFragment;
    'isSystemCoinToken0()': FunctionFragment;
    'keeperPayout()': FunctionFragment;
    'keeperPayoutExceedsMinValue()': FunctionFragment;
    'liquidationEngine()': FunctionFragment;
    'liquidityManager()': FunctionFragment;
    'lpToken()': FunctionFragment;
    'lpTokenCover(address)': FunctionFragment;
    'minKeeperPayoutValue()': FunctionFragment;
    'oracleRelayer()': FunctionFragment;
    'payoutToSAFESize()': FunctionFragment;
    'removeAuthorization(address)': FunctionFragment;
    'restrictUsage()': FunctionFragment;
    'safeEngine()': FunctionFragment;
    'safeManager()': FunctionFragment;
    'saveSAFE(address,bytes32,address)': FunctionFragment;
    'saviourRegistry()': FunctionFragment;
    'systemCoin()': FunctionFragment;
    'systemCoinOrcl()': FunctionFragment;
    'taxCollector()': FunctionFragment;
    'tokenAmountUsedToSave(bytes32,address)': FunctionFragment;
    'underlyingReserves(address)': FunctionFragment;
    'withdraw(uint256,uint256,address)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'HUNDRED'
      | 'MAX_UINT'
      | 'ONE'
      | 'RAY'
      | 'THOUSAND'
      | 'WAD'
      | 'WAD_COMPLEMENT'
      | 'addAuthorization'
      | 'allowUser'
      | 'allowedUsers'
      | 'authorizedAccounts'
      | 'cRatioSetter'
      | 'canSave'
      | 'coinJoin'
      | 'collateralJoin'
      | 'collateralToken'
      | 'debtBelowFloor'
      | 'deposit'
      | 'disallowUser'
      | 'getAccumulatedRate'
      | 'getCollateralPrice'
      | 'getKeeperPayoutTokens'
      | 'getKeeperPayoutValue'
      | 'getLPUnderlying'
      | 'getReserves'
      | 'getSystemCoinMarketPrice'
      | 'getTargetCRatio'
      | 'getTokensForSaving'
      | 'isSystemCoinToken0'
      | 'keeperPayout'
      | 'keeperPayoutExceedsMinValue'
      | 'liquidationEngine'
      | 'liquidityManager'
      | 'lpToken'
      | 'lpTokenCover'
      | 'minKeeperPayoutValue'
      | 'oracleRelayer'
      | 'payoutToSAFESize'
      | 'removeAuthorization'
      | 'restrictUsage'
      | 'safeEngine'
      | 'safeManager'
      | 'saveSAFE'
      | 'saviourRegistry'
      | 'systemCoin'
      | 'systemCoinOrcl'
      | 'taxCollector'
      | 'tokenAmountUsedToSave'
      | 'underlyingReserves'
      | 'withdraw',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'HUNDRED', values?: undefined): string;
  encodeFunctionData(functionFragment: 'MAX_UINT', values?: undefined): string;
  encodeFunctionData(functionFragment: 'ONE', values?: undefined): string;
  encodeFunctionData(functionFragment: 'RAY', values?: undefined): string;
  encodeFunctionData(functionFragment: 'THOUSAND', values?: undefined): string;
  encodeFunctionData(functionFragment: 'WAD', values?: undefined): string;
  encodeFunctionData(functionFragment: 'WAD_COMPLEMENT', values?: undefined): string;
  encodeFunctionData(functionFragment: 'addAuthorization', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'allowUser', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'allowedUsers', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'authorizedAccounts', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'cRatioSetter', values?: undefined): string;
  encodeFunctionData(functionFragment: 'canSave', values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'coinJoin', values?: undefined): string;
  encodeFunctionData(functionFragment: 'collateralJoin', values?: undefined): string;
  encodeFunctionData(functionFragment: 'collateralToken', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'debtBelowFloor',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'deposit',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'disallowUser', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getAccumulatedRate', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(functionFragment: 'getCollateralPrice', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'getKeeperPayoutTokens',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'getKeeperPayoutValue', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getLPUnderlying', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'getReserves',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'getSystemCoinMarketPrice', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getTargetCRatio', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'getTokensForSaving',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'isSystemCoinToken0', values?: undefined): string;
  encodeFunctionData(functionFragment: 'keeperPayout', values?: undefined): string;
  encodeFunctionData(functionFragment: 'keeperPayoutExceedsMinValue', values?: undefined): string;
  encodeFunctionData(functionFragment: 'liquidationEngine', values?: undefined): string;
  encodeFunctionData(functionFragment: 'liquidityManager', values?: undefined): string;
  encodeFunctionData(functionFragment: 'lpToken', values?: undefined): string;
  encodeFunctionData(functionFragment: 'lpTokenCover', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'minKeeperPayoutValue', values?: undefined): string;
  encodeFunctionData(functionFragment: 'oracleRelayer', values?: undefined): string;
  encodeFunctionData(functionFragment: 'payoutToSAFESize', values?: undefined): string;
  encodeFunctionData(functionFragment: 'removeAuthorization', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'restrictUsage', values?: undefined): string;
  encodeFunctionData(functionFragment: 'safeEngine', values?: undefined): string;
  encodeFunctionData(functionFragment: 'safeManager', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'saveSAFE',
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'saviourRegistry', values?: undefined): string;
  encodeFunctionData(functionFragment: 'systemCoin', values?: undefined): string;
  encodeFunctionData(functionFragment: 'systemCoinOrcl', values?: undefined): string;
  encodeFunctionData(functionFragment: 'taxCollector', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'tokenAmountUsedToSave',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'underlyingReserves', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'withdraw',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;

  decodeFunctionResult(functionFragment: 'HUNDRED', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'MAX_UINT', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'ONE', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'RAY', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'THOUSAND', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'WAD', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'WAD_COMPLEMENT', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addAuthorization', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allowUser', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allowedUsers', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'authorizedAccounts', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cRatioSetter', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'canSave', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'coinJoin', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'collateralJoin', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'collateralToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'debtBelowFloor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'disallowUser', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getAccumulatedRate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getCollateralPrice', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getKeeperPayoutTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getKeeperPayoutValue', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getLPUnderlying', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReserves', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getSystemCoinMarketPrice', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getTargetCRatio', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getTokensForSaving', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isSystemCoinToken0', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'keeperPayout', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'keeperPayoutExceedsMinValue', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidationEngine', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidityManager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lpToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lpTokenCover', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'minKeeperPayoutValue', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'oracleRelayer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'payoutToSAFESize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'removeAuthorization', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'restrictUsage', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'safeEngine', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'safeManager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'saveSAFE', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'saviourRegistry', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'systemCoin', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'systemCoinOrcl', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'taxCollector', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tokenAmountUsedToSave', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'underlyingReserves', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result;

  events: {
    'AddAuthorization(address)': EventFragment;
    'AllowUser(address)': EventFragment;
    'Deposit(address,address,uint256)': EventFragment;
    'DisallowUser(address)': EventFragment;
    'GetReserves(address,address,uint256,uint256,address)': EventFragment;
    'RemoveAuthorization(address)': EventFragment;
    'SaveSAFE(address,bytes32,address,uint256)': EventFragment;
    'Withdraw(address,address,address,uint256)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'AddAuthorization'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'AllowUser'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Deposit'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'DisallowUser'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'GetReserves'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RemoveAuthorization'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SaveSAFE'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Withdraw'): EventFragment;
}

export interface AddAuthorizationEventObject {
  account: string;
}
export type AddAuthorizationEvent = TypedEvent<[string], AddAuthorizationEventObject>;

export type AddAuthorizationEventFilter = TypedEventFilter<AddAuthorizationEvent>;

export interface AllowUserEventObject {
  usr: string;
}
export type AllowUserEvent = TypedEvent<[string], AllowUserEventObject>;

export type AllowUserEventFilter = TypedEventFilter<AllowUserEvent>;

export interface DepositEventObject {
  caller: string;
  safeHandler: string;
  lpTokenAmount: BigNumber;
}
export type DepositEvent = TypedEvent<[string, string, BigNumber], DepositEventObject>;

export type DepositEventFilter = TypedEventFilter<DepositEvent>;

export interface DisallowUserEventObject {
  usr: string;
}
export type DisallowUserEvent = TypedEvent<[string], DisallowUserEventObject>;

export type DisallowUserEventFilter = TypedEventFilter<DisallowUserEvent>;

export interface GetReservesEventObject {
  caller: string;
  safeHandler: string;
  systemCoinAmount: BigNumber;
  collateralAmount: BigNumber;
  dst: string;
}
export type GetReservesEvent = TypedEvent<[string, string, BigNumber, BigNumber, string], GetReservesEventObject>;

export type GetReservesEventFilter = TypedEventFilter<GetReservesEvent>;

export interface RemoveAuthorizationEventObject {
  account: string;
}
export type RemoveAuthorizationEvent = TypedEvent<[string], RemoveAuthorizationEventObject>;

export type RemoveAuthorizationEventFilter = TypedEventFilter<RemoveAuthorizationEvent>;

export interface SaveSAFEEventObject {
  keeper: string;
  collateralType: string;
  safeHandler: string;
  collateralAddedOrDebtRepaid: BigNumber;
}
export type SaveSAFEEvent = TypedEvent<[string, string, string, BigNumber], SaveSAFEEventObject>;

export type SaveSAFEEventFilter = TypedEventFilter<SaveSAFEEvent>;

export interface WithdrawEventObject {
  caller: string;
  safeHandler: string;
  dst: string;
  lpTokenAmount: BigNumber;
}
export type WithdrawEvent = TypedEvent<[string, string, string, BigNumber], WithdrawEventObject>;

export type WithdrawEventFilter = TypedEventFilter<WithdrawEvent>;

export interface ReflexerUniswapV2SafeSavior extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ReflexerUniswapV2SafeSaviorInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    HUNDRED(overrides?: CallOverrides): Promise<[BigNumber]>;

    MAX_UINT(overrides?: CallOverrides): Promise<[BigNumber]>;

    ONE(overrides?: CallOverrides): Promise<[BigNumber]>;

    RAY(overrides?: CallOverrides): Promise<[BigNumber]>;

    THOUSAND(overrides?: CallOverrides): Promise<[BigNumber]>;

    WAD(overrides?: CallOverrides): Promise<[BigNumber]>;

    WAD_COMPLEMENT(overrides?: CallOverrides): Promise<[BigNumber]>;

    addAuthorization(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    allowUser(
      usr: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    allowedUsers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    authorizedAccounts(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    cRatioSetter(overrides?: CallOverrides): Promise<[string]>;

    canSave(
      arg0: PromiseOrValue<BytesLike>,
      safeHandler: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    coinJoin(overrides?: CallOverrides): Promise<[string]>;

    collateralJoin(overrides?: CallOverrides): Promise<[string]>;

    collateralToken(overrides?: CallOverrides): Promise<[string]>;

    debtBelowFloor(
      collateralType: PromiseOrValue<BytesLike>,
      targetDebtAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    deposit(
      safeID: PromiseOrValue<BigNumberish>,
      lpTokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    disallowUser(
      usr: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    getAccumulatedRate(
      collateralType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { accumulatedRate: BigNumber }>;

    getCollateralPrice(overrides?: CallOverrides): Promise<[BigNumber]>;

    getKeeperPayoutTokens(
      safeHandler: PromiseOrValue<string>,
      redemptionPrice: PromiseOrValue<BigNumberish>,
      safeDebtRepaid: PromiseOrValue<BigNumberish>,
      safeCollateralAdded: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber]>;

    getKeeperPayoutValue(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    getLPUnderlying(safeHandler: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber, BigNumber]>;

    getReserves(
      safeID: PromiseOrValue<BigNumberish>,
      dst: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    getSystemCoinMarketPrice(overrides?: CallOverrides): Promise<[BigNumber]>;

    getTargetCRatio(safeHandler: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    getTokensForSaving(
      safeHandler: PromiseOrValue<string>,
      redemptionPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber]>;

    isSystemCoinToken0(overrides?: CallOverrides): Promise<[boolean]>;

    keeperPayout(overrides?: CallOverrides): Promise<[BigNumber]>;

    keeperPayoutExceedsMinValue(
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    liquidationEngine(overrides?: CallOverrides): Promise<[string]>;

    liquidityManager(overrides?: CallOverrides): Promise<[string]>;

    lpToken(overrides?: CallOverrides): Promise<[string]>;

    lpTokenCover(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    minKeeperPayoutValue(overrides?: CallOverrides): Promise<[BigNumber]>;

    oracleRelayer(overrides?: CallOverrides): Promise<[string]>;

    payoutToSAFESize(overrides?: CallOverrides): Promise<[BigNumber]>;

    removeAuthorization(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    restrictUsage(overrides?: CallOverrides): Promise<[BigNumber]>;

    safeEngine(overrides?: CallOverrides): Promise<[string]>;

    safeManager(overrides?: CallOverrides): Promise<[string]>;

    saveSAFE(
      keeper: PromiseOrValue<string>,
      collateralType: PromiseOrValue<BytesLike>,
      safeHandler: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    saviourRegistry(overrides?: CallOverrides): Promise<[string]>;

    systemCoin(overrides?: CallOverrides): Promise<[string]>;

    systemCoinOrcl(overrides?: CallOverrides): Promise<[string]>;

    taxCollector(overrides?: CallOverrides): Promise<[string]>;

    tokenAmountUsedToSave(
      arg0: PromiseOrValue<BytesLike>,
      safeHandler: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    underlyingReserves(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        systemCoins: BigNumber;
        collateralCoins: BigNumber;
      }
    >;

    withdraw(
      safeID: PromiseOrValue<BigNumberish>,
      lpTokenAmount: PromiseOrValue<BigNumberish>,
      dst: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;
  };

  HUNDRED(overrides?: CallOverrides): Promise<BigNumber>;

  MAX_UINT(overrides?: CallOverrides): Promise<BigNumber>;

  ONE(overrides?: CallOverrides): Promise<BigNumber>;

  RAY(overrides?: CallOverrides): Promise<BigNumber>;

  THOUSAND(overrides?: CallOverrides): Promise<BigNumber>;

  WAD(overrides?: CallOverrides): Promise<BigNumber>;

  WAD_COMPLEMENT(overrides?: CallOverrides): Promise<BigNumber>;

  addAuthorization(
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  allowUser(
    usr: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  allowedUsers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  authorizedAccounts(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  cRatioSetter(overrides?: CallOverrides): Promise<string>;

  canSave(
    arg0: PromiseOrValue<BytesLike>,
    safeHandler: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  coinJoin(overrides?: CallOverrides): Promise<string>;

  collateralJoin(overrides?: CallOverrides): Promise<string>;

  collateralToken(overrides?: CallOverrides): Promise<string>;

  debtBelowFloor(
    collateralType: PromiseOrValue<BytesLike>,
    targetDebtAmount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  deposit(
    safeID: PromiseOrValue<BigNumberish>,
    lpTokenAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  disallowUser(
    usr: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  getAccumulatedRate(collateralType: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

  getCollateralPrice(overrides?: CallOverrides): Promise<BigNumber>;

  getKeeperPayoutTokens(
    safeHandler: PromiseOrValue<string>,
    redemptionPrice: PromiseOrValue<BigNumberish>,
    safeDebtRepaid: PromiseOrValue<BigNumberish>,
    safeCollateralAdded: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, BigNumber]>;

  getKeeperPayoutValue(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  getLPUnderlying(safeHandler: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber, BigNumber]>;

  getReserves(
    safeID: PromiseOrValue<BigNumberish>,
    dst: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  getSystemCoinMarketPrice(overrides?: CallOverrides): Promise<BigNumber>;

  getTargetCRatio(safeHandler: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  getTokensForSaving(
    safeHandler: PromiseOrValue<string>,
    redemptionPrice: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, BigNumber]>;

  isSystemCoinToken0(overrides?: CallOverrides): Promise<boolean>;

  keeperPayout(overrides?: CallOverrides): Promise<BigNumber>;

  keeperPayoutExceedsMinValue(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  liquidationEngine(overrides?: CallOverrides): Promise<string>;

  liquidityManager(overrides?: CallOverrides): Promise<string>;

  lpToken(overrides?: CallOverrides): Promise<string>;

  lpTokenCover(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  minKeeperPayoutValue(overrides?: CallOverrides): Promise<BigNumber>;

  oracleRelayer(overrides?: CallOverrides): Promise<string>;

  payoutToSAFESize(overrides?: CallOverrides): Promise<BigNumber>;

  removeAuthorization(
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  restrictUsage(overrides?: CallOverrides): Promise<BigNumber>;

  safeEngine(overrides?: CallOverrides): Promise<string>;

  safeManager(overrides?: CallOverrides): Promise<string>;

  saveSAFE(
    keeper: PromiseOrValue<string>,
    collateralType: PromiseOrValue<BytesLike>,
    safeHandler: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  saviourRegistry(overrides?: CallOverrides): Promise<string>;

  systemCoin(overrides?: CallOverrides): Promise<string>;

  systemCoinOrcl(overrides?: CallOverrides): Promise<string>;

  taxCollector(overrides?: CallOverrides): Promise<string>;

  tokenAmountUsedToSave(
    arg0: PromiseOrValue<BytesLike>,
    safeHandler: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  underlyingReserves(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber] & {
      systemCoins: BigNumber;
      collateralCoins: BigNumber;
    }
  >;

  withdraw(
    safeID: PromiseOrValue<BigNumberish>,
    lpTokenAmount: PromiseOrValue<BigNumberish>,
    dst: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    HUNDRED(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_UINT(overrides?: CallOverrides): Promise<BigNumber>;

    ONE(overrides?: CallOverrides): Promise<BigNumber>;

    RAY(overrides?: CallOverrides): Promise<BigNumber>;

    THOUSAND(overrides?: CallOverrides): Promise<BigNumber>;

    WAD(overrides?: CallOverrides): Promise<BigNumber>;

    WAD_COMPLEMENT(overrides?: CallOverrides): Promise<BigNumber>;

    addAuthorization(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    allowUser(usr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    allowedUsers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    authorizedAccounts(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    cRatioSetter(overrides?: CallOverrides): Promise<string>;

    canSave(
      arg0: PromiseOrValue<BytesLike>,
      safeHandler: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    coinJoin(overrides?: CallOverrides): Promise<string>;

    collateralJoin(overrides?: CallOverrides): Promise<string>;

    collateralToken(overrides?: CallOverrides): Promise<string>;

    debtBelowFloor(
      collateralType: PromiseOrValue<BytesLike>,
      targetDebtAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    deposit(
      safeID: PromiseOrValue<BigNumberish>,
      lpTokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    disallowUser(usr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    getAccumulatedRate(collateralType: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    getCollateralPrice(overrides?: CallOverrides): Promise<BigNumber>;

    getKeeperPayoutTokens(
      safeHandler: PromiseOrValue<string>,
      redemptionPrice: PromiseOrValue<BigNumberish>,
      safeDebtRepaid: PromiseOrValue<BigNumberish>,
      safeCollateralAdded: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber]>;

    getKeeperPayoutValue(overrides?: CallOverrides): Promise<BigNumber>;

    getLPUnderlying(safeHandler: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber, BigNumber]>;

    getReserves(
      safeID: PromiseOrValue<BigNumberish>,
      dst: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    getSystemCoinMarketPrice(overrides?: CallOverrides): Promise<BigNumber>;

    getTargetCRatio(safeHandler: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getTokensForSaving(
      safeHandler: PromiseOrValue<string>,
      redemptionPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber]>;

    isSystemCoinToken0(overrides?: CallOverrides): Promise<boolean>;

    keeperPayout(overrides?: CallOverrides): Promise<BigNumber>;

    keeperPayoutExceedsMinValue(overrides?: CallOverrides): Promise<boolean>;

    liquidationEngine(overrides?: CallOverrides): Promise<string>;

    liquidityManager(overrides?: CallOverrides): Promise<string>;

    lpToken(overrides?: CallOverrides): Promise<string>;

    lpTokenCover(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    minKeeperPayoutValue(overrides?: CallOverrides): Promise<BigNumber>;

    oracleRelayer(overrides?: CallOverrides): Promise<string>;

    payoutToSAFESize(overrides?: CallOverrides): Promise<BigNumber>;

    removeAuthorization(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    restrictUsage(overrides?: CallOverrides): Promise<BigNumber>;

    safeEngine(overrides?: CallOverrides): Promise<string>;

    safeManager(overrides?: CallOverrides): Promise<string>;

    saveSAFE(
      keeper: PromiseOrValue<string>,
      collateralType: PromiseOrValue<BytesLike>,
      safeHandler: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean, BigNumber, BigNumber]>;

    saviourRegistry(overrides?: CallOverrides): Promise<string>;

    systemCoin(overrides?: CallOverrides): Promise<string>;

    systemCoinOrcl(overrides?: CallOverrides): Promise<string>;

    taxCollector(overrides?: CallOverrides): Promise<string>;

    tokenAmountUsedToSave(
      arg0: PromiseOrValue<BytesLike>,
      safeHandler: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    underlyingReserves(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        systemCoins: BigNumber;
        collateralCoins: BigNumber;
      }
    >;

    withdraw(
      safeID: PromiseOrValue<BigNumberish>,
      lpTokenAmount: PromiseOrValue<BigNumberish>,
      dst: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;
  };

  filters: {
    'AddAuthorization(address)'(account?: null): AddAuthorizationEventFilter;
    AddAuthorization(account?: null): AddAuthorizationEventFilter;

    'AllowUser(address)'(usr?: null): AllowUserEventFilter;
    AllowUser(usr?: null): AllowUserEventFilter;

    'Deposit(address,address,uint256)'(
      caller?: PromiseOrValue<string> | null,
      safeHandler?: PromiseOrValue<string> | null,
      lpTokenAmount?: null,
    ): DepositEventFilter;
    Deposit(
      caller?: PromiseOrValue<string> | null,
      safeHandler?: PromiseOrValue<string> | null,
      lpTokenAmount?: null,
    ): DepositEventFilter;

    'DisallowUser(address)'(usr?: null): DisallowUserEventFilter;
    DisallowUser(usr?: null): DisallowUserEventFilter;

    'GetReserves(address,address,uint256,uint256,address)'(
      caller?: PromiseOrValue<string> | null,
      safeHandler?: PromiseOrValue<string> | null,
      systemCoinAmount?: null,
      collateralAmount?: null,
      dst?: null,
    ): GetReservesEventFilter;
    GetReserves(
      caller?: PromiseOrValue<string> | null,
      safeHandler?: PromiseOrValue<string> | null,
      systemCoinAmount?: null,
      collateralAmount?: null,
      dst?: null,
    ): GetReservesEventFilter;

    'RemoveAuthorization(address)'(account?: null): RemoveAuthorizationEventFilter;
    RemoveAuthorization(account?: null): RemoveAuthorizationEventFilter;

    'SaveSAFE(address,bytes32,address,uint256)'(
      keeper?: PromiseOrValue<string> | null,
      collateralType?: PromiseOrValue<BytesLike> | null,
      safeHandler?: PromiseOrValue<string> | null,
      collateralAddedOrDebtRepaid?: null,
    ): SaveSAFEEventFilter;
    SaveSAFE(
      keeper?: PromiseOrValue<string> | null,
      collateralType?: PromiseOrValue<BytesLike> | null,
      safeHandler?: PromiseOrValue<string> | null,
      collateralAddedOrDebtRepaid?: null,
    ): SaveSAFEEventFilter;

    'Withdraw(address,address,address,uint256)'(
      caller?: PromiseOrValue<string> | null,
      safeHandler?: PromiseOrValue<string> | null,
      dst?: null,
      lpTokenAmount?: null,
    ): WithdrawEventFilter;
    Withdraw(
      caller?: PromiseOrValue<string> | null,
      safeHandler?: PromiseOrValue<string> | null,
      dst?: null,
      lpTokenAmount?: null,
    ): WithdrawEventFilter;
  };

  estimateGas: {
    HUNDRED(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_UINT(overrides?: CallOverrides): Promise<BigNumber>;

    ONE(overrides?: CallOverrides): Promise<BigNumber>;

    RAY(overrides?: CallOverrides): Promise<BigNumber>;

    THOUSAND(overrides?: CallOverrides): Promise<BigNumber>;

    WAD(overrides?: CallOverrides): Promise<BigNumber>;

    WAD_COMPLEMENT(overrides?: CallOverrides): Promise<BigNumber>;

    addAuthorization(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    allowUser(
      usr: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    allowedUsers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    authorizedAccounts(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    cRatioSetter(overrides?: CallOverrides): Promise<BigNumber>;

    canSave(
      arg0: PromiseOrValue<BytesLike>,
      safeHandler: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    coinJoin(overrides?: CallOverrides): Promise<BigNumber>;

    collateralJoin(overrides?: CallOverrides): Promise<BigNumber>;

    collateralToken(overrides?: CallOverrides): Promise<BigNumber>;

    debtBelowFloor(
      collateralType: PromiseOrValue<BytesLike>,
      targetDebtAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    deposit(
      safeID: PromiseOrValue<BigNumberish>,
      lpTokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    disallowUser(
      usr: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    getAccumulatedRate(collateralType: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    getCollateralPrice(overrides?: CallOverrides): Promise<BigNumber>;

    getKeeperPayoutTokens(
      safeHandler: PromiseOrValue<string>,
      redemptionPrice: PromiseOrValue<BigNumberish>,
      safeDebtRepaid: PromiseOrValue<BigNumberish>,
      safeCollateralAdded: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getKeeperPayoutValue(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    getLPUnderlying(safeHandler: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getReserves(
      safeID: PromiseOrValue<BigNumberish>,
      dst: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    getSystemCoinMarketPrice(overrides?: CallOverrides): Promise<BigNumber>;

    getTargetCRatio(safeHandler: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getTokensForSaving(
      safeHandler: PromiseOrValue<string>,
      redemptionPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    isSystemCoinToken0(overrides?: CallOverrides): Promise<BigNumber>;

    keeperPayout(overrides?: CallOverrides): Promise<BigNumber>;

    keeperPayoutExceedsMinValue(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    liquidationEngine(overrides?: CallOverrides): Promise<BigNumber>;

    liquidityManager(overrides?: CallOverrides): Promise<BigNumber>;

    lpToken(overrides?: CallOverrides): Promise<BigNumber>;

    lpTokenCover(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    minKeeperPayoutValue(overrides?: CallOverrides): Promise<BigNumber>;

    oracleRelayer(overrides?: CallOverrides): Promise<BigNumber>;

    payoutToSAFESize(overrides?: CallOverrides): Promise<BigNumber>;

    removeAuthorization(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    restrictUsage(overrides?: CallOverrides): Promise<BigNumber>;

    safeEngine(overrides?: CallOverrides): Promise<BigNumber>;

    safeManager(overrides?: CallOverrides): Promise<BigNumber>;

    saveSAFE(
      keeper: PromiseOrValue<string>,
      collateralType: PromiseOrValue<BytesLike>,
      safeHandler: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    saviourRegistry(overrides?: CallOverrides): Promise<BigNumber>;

    systemCoin(overrides?: CallOverrides): Promise<BigNumber>;

    systemCoinOrcl(overrides?: CallOverrides): Promise<BigNumber>;

    taxCollector(overrides?: CallOverrides): Promise<BigNumber>;

    tokenAmountUsedToSave(
      arg0: PromiseOrValue<BytesLike>,
      safeHandler: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    underlyingReserves(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    withdraw(
      safeID: PromiseOrValue<BigNumberish>,
      lpTokenAmount: PromiseOrValue<BigNumberish>,
      dst: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    HUNDRED(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAX_UINT(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ONE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    RAY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    THOUSAND(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    WAD(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    WAD_COMPLEMENT(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    addAuthorization(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    allowUser(
      usr: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    allowedUsers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    authorizedAccounts(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    cRatioSetter(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    canSave(
      arg0: PromiseOrValue<BytesLike>,
      safeHandler: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    coinJoin(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    collateralJoin(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    collateralToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    debtBelowFloor(
      collateralType: PromiseOrValue<BytesLike>,
      targetDebtAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    deposit(
      safeID: PromiseOrValue<BigNumberish>,
      lpTokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    disallowUser(
      usr: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    getAccumulatedRate(
      collateralType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getCollateralPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getKeeperPayoutTokens(
      safeHandler: PromiseOrValue<string>,
      redemptionPrice: PromiseOrValue<BigNumberish>,
      safeDebtRepaid: PromiseOrValue<BigNumberish>,
      safeCollateralAdded: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getKeeperPayoutValue(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    getLPUnderlying(safeHandler: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getReserves(
      safeID: PromiseOrValue<BigNumberish>,
      dst: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    getSystemCoinMarketPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getTargetCRatio(safeHandler: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getTokensForSaving(
      safeHandler: PromiseOrValue<string>,
      redemptionPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    isSystemCoinToken0(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    keeperPayout(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    keeperPayoutExceedsMinValue(
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    liquidationEngine(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    liquidityManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lpToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lpTokenCover(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minKeeperPayoutValue(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    oracleRelayer(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    payoutToSAFESize(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    removeAuthorization(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    restrictUsage(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    safeEngine(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    safeManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    saveSAFE(
      keeper: PromiseOrValue<string>,
      collateralType: PromiseOrValue<BytesLike>,
      safeHandler: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    saviourRegistry(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    systemCoin(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    systemCoinOrcl(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    taxCollector(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokenAmountUsedToSave(
      arg0: PromiseOrValue<BytesLike>,
      safeHandler: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    underlyingReserves(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdraw(
      safeID: PromiseOrValue<BigNumberish>,
      lpTokenAmount: PromiseOrValue<BigNumberish>,
      dst: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;
  };
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export interface HomoraBankInterface extends utils.Interface {
  functions: {
    'EXECUTOR()': FunctionFragment;
    'POSITION_ID()': FunctionFragment;
    'SPELL()': FunctionFragment;
    '_GENERAL_LOCK()': FunctionFragment;
    '_IN_EXEC_LOCK()': FunctionFragment;
    'acceptGovernor()': FunctionFragment;
    'accrue(address)': FunctionFragment;
    'accrueAll(address[])': FunctionFragment;
    'addBank(address,address)': FunctionFragment;
    'allBanks(uint256)': FunctionFragment;
    'allowBorrowStatus()': FunctionFragment;
    'allowContractCalls()': FunctionFragment;
    'allowRepayStatus()': FunctionFragment;
    'bankStatus()': FunctionFragment;
    'banks(address)': FunctionFragment;
    'borrow(address,uint256)': FunctionFragment;
    'borrowBalanceCurrent(uint256,address)': FunctionFragment;
    'borrowBalanceStored(uint256,address)': FunctionFragment;
    'cTokenInBank(address)': FunctionFragment;
    'caster()': FunctionFragment;
    'execute(uint256,address,bytes)': FunctionFragment;
    'feeBps()': FunctionFragment;
    'getBankInfo(address)': FunctionFragment;
    'getBorrowETHValue(uint256)': FunctionFragment;
    'getCollateralETHValue(uint256)': FunctionFragment;
    'getCurrentPositionInfo()': FunctionFragment;
    'getPositionDebtShareOf(uint256,address)': FunctionFragment;
    'getPositionDebts(uint256)': FunctionFragment;
    'getPositionInfo(uint256)': FunctionFragment;
    'governor()': FunctionFragment;
    'initialize(address,uint256)': FunctionFragment;
    'liquidate(uint256,address,uint256)': FunctionFragment;
    'nextPositionId()': FunctionFragment;
    'onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)': FunctionFragment;
    'onERC1155Received(address,address,uint256,uint256,bytes)': FunctionFragment;
    'oracle()': FunctionFragment;
    'pendingGovernor()': FunctionFragment;
    'positions(uint256)': FunctionFragment;
    'putCollateral(address,uint256,uint256)': FunctionFragment;
    'repay(address,uint256)': FunctionFragment;
    'setAllowContractCalls(bool)': FunctionFragment;
    'setBankStatus(uint256)': FunctionFragment;
    'setFeeBps(uint256)': FunctionFragment;
    'setOracle(address)': FunctionFragment;
    'setPendingGovernor(address)': FunctionFragment;
    'setWhitelistSpells(address[],bool[])': FunctionFragment;
    'setWhitelistTokens(address[],bool[])': FunctionFragment;
    'setWhitelistUsers(address[],bool[])': FunctionFragment;
    'support(address)': FunctionFragment;
    'supportsInterface(bytes4)': FunctionFragment;
    'takeCollateral(address,uint256,uint256)': FunctionFragment;
    'transmit(address,uint256)': FunctionFragment;
    'whitelistedSpells(address)': FunctionFragment;
    'whitelistedTokens(address)': FunctionFragment;
    'whitelistedUsers(address)': FunctionFragment;
    'withdrawReserve(address,uint256)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'EXECUTOR'
      | 'POSITION_ID'
      | 'SPELL'
      | '_GENERAL_LOCK'
      | '_IN_EXEC_LOCK'
      | 'acceptGovernor'
      | 'accrue'
      | 'accrueAll'
      | 'addBank'
      | 'allBanks'
      | 'allowBorrowStatus'
      | 'allowContractCalls'
      | 'allowRepayStatus'
      | 'bankStatus'
      | 'banks'
      | 'borrow'
      | 'borrowBalanceCurrent'
      | 'borrowBalanceStored'
      | 'cTokenInBank'
      | 'caster'
      | 'execute'
      | 'feeBps'
      | 'getBankInfo'
      | 'getBorrowETHValue'
      | 'getCollateralETHValue'
      | 'getCurrentPositionInfo'
      | 'getPositionDebtShareOf'
      | 'getPositionDebts'
      | 'getPositionInfo'
      | 'governor'
      | 'initialize'
      | 'liquidate'
      | 'nextPositionId'
      | 'onERC1155BatchReceived'
      | 'onERC1155Received'
      | 'oracle'
      | 'pendingGovernor'
      | 'positions'
      | 'putCollateral'
      | 'repay'
      | 'setAllowContractCalls'
      | 'setBankStatus'
      | 'setFeeBps'
      | 'setOracle'
      | 'setPendingGovernor'
      | 'setWhitelistSpells'
      | 'setWhitelistTokens'
      | 'setWhitelistUsers'
      | 'support'
      | 'supportsInterface'
      | 'takeCollateral'
      | 'transmit'
      | 'whitelistedSpells'
      | 'whitelistedTokens'
      | 'whitelistedUsers'
      | 'withdrawReserve',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'EXECUTOR', values?: undefined): string;
  encodeFunctionData(functionFragment: 'POSITION_ID', values?: undefined): string;
  encodeFunctionData(functionFragment: 'SPELL', values?: undefined): string;
  encodeFunctionData(functionFragment: '_GENERAL_LOCK', values?: undefined): string;
  encodeFunctionData(functionFragment: '_IN_EXEC_LOCK', values?: undefined): string;
  encodeFunctionData(functionFragment: 'acceptGovernor', values?: undefined): string;
  encodeFunctionData(functionFragment: 'accrue', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'accrueAll', values: [PromiseOrValue<string>[]]): string;
  encodeFunctionData(functionFragment: 'addBank', values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'allBanks', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'allowBorrowStatus', values?: undefined): string;
  encodeFunctionData(functionFragment: 'allowContractCalls', values?: undefined): string;
  encodeFunctionData(functionFragment: 'allowRepayStatus', values?: undefined): string;
  encodeFunctionData(functionFragment: 'bankStatus', values?: undefined): string;
  encodeFunctionData(functionFragment: 'banks', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'borrow',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'borrowBalanceCurrent',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'borrowBalanceStored',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'cTokenInBank', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'caster', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'execute',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>, PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(functionFragment: 'feeBps', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getBankInfo', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getBorrowETHValue', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getCollateralETHValue', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getCurrentPositionInfo', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'getPositionDebtShareOf',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'getPositionDebts', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getPositionInfo', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'governor', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'initialize',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'liquidate',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'nextPositionId', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'onERC1155BatchReceived',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'onERC1155Received',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'oracle', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pendingGovernor', values?: undefined): string;
  encodeFunctionData(functionFragment: 'positions', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'putCollateral',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'repay', values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setAllowContractCalls', values: [PromiseOrValue<boolean>]): string;
  encodeFunctionData(functionFragment: 'setBankStatus', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setFeeBps', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setOracle', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setPendingGovernor', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'setWhitelistSpells',
    values: [PromiseOrValue<string>[], PromiseOrValue<boolean>[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'setWhitelistTokens',
    values: [PromiseOrValue<string>[], PromiseOrValue<boolean>[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'setWhitelistUsers',
    values: [PromiseOrValue<string>[], PromiseOrValue<boolean>[]],
  ): string;
  encodeFunctionData(functionFragment: 'support', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'supportsInterface', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(
    functionFragment: 'takeCollateral',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'transmit',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'whitelistedSpells', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'whitelistedTokens', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'whitelistedUsers', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'withdrawReserve',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;

  decodeFunctionResult(functionFragment: 'EXECUTOR', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'POSITION_ID', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'SPELL', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: '_GENERAL_LOCK', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: '_IN_EXEC_LOCK', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'acceptGovernor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'accrue', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'accrueAll', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addBank', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allBanks', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allowBorrowStatus', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allowContractCalls', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allowRepayStatus', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'bankStatus', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'banks', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'borrow', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'borrowBalanceCurrent', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'borrowBalanceStored', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cTokenInBank', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'caster', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'execute', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'feeBps', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getBankInfo', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getBorrowETHValue', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getCollateralETHValue', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getCurrentPositionInfo', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPositionDebtShareOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPositionDebts', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPositionInfo', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'governor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nextPositionId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'onERC1155BatchReceived', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'onERC1155Received', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'oracle', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pendingGovernor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'positions', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'putCollateral', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'repay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setAllowContractCalls', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setBankStatus', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setFeeBps', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setOracle', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setPendingGovernor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setWhitelistSpells', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setWhitelistTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setWhitelistUsers', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'support', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'supportsInterface', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'takeCollateral', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transmit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'whitelistedSpells', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'whitelistedTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'whitelistedUsers', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawReserve', data: BytesLike): Result;

  events: {
    'AcceptGovernor(address)': EventFragment;
    'AddBank(address,address)': EventFragment;
    'Borrow(uint256,address,address,uint256,uint256)': EventFragment;
    'Liquidate(uint256,address,address,uint256,uint256,uint256)': EventFragment;
    'PutCollateral(uint256,address,address,uint256,uint256)': EventFragment;
    'Repay(uint256,address,address,uint256,uint256)': EventFragment;
    'SetFeeBps(uint256)': EventFragment;
    'SetGovernor(address)': EventFragment;
    'SetOracle(address)': EventFragment;
    'SetPendingGovernor(address)': EventFragment;
    'TakeCollateral(uint256,address,address,uint256,uint256)': EventFragment;
    'WithdrawReserve(address,address,uint256)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'AcceptGovernor'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'AddBank'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Borrow'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Liquidate'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'PutCollateral'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Repay'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SetFeeBps'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SetGovernor'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SetOracle'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SetPendingGovernor'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TakeCollateral'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'WithdrawReserve'): EventFragment;
}

export interface AcceptGovernorEventObject {
  governor: string;
}
export type AcceptGovernorEvent = TypedEvent<[string], AcceptGovernorEventObject>;

export type AcceptGovernorEventFilter = TypedEventFilter<AcceptGovernorEvent>;

export interface AddBankEventObject {
  token: string;
  cToken: string;
}
export type AddBankEvent = TypedEvent<[string, string], AddBankEventObject>;

export type AddBankEventFilter = TypedEventFilter<AddBankEvent>;

export interface BorrowEventObject {
  positionId: BigNumber;
  caller: string;
  token: string;
  amount: BigNumber;
  share: BigNumber;
}
export type BorrowEvent = TypedEvent<[BigNumber, string, string, BigNumber, BigNumber], BorrowEventObject>;

export type BorrowEventFilter = TypedEventFilter<BorrowEvent>;

export interface LiquidateEventObject {
  positionId: BigNumber;
  liquidator: string;
  debtToken: string;
  amount: BigNumber;
  share: BigNumber;
  bounty: BigNumber;
}
export type LiquidateEvent = TypedEvent<
  [BigNumber, string, string, BigNumber, BigNumber, BigNumber],
  LiquidateEventObject
>;

export type LiquidateEventFilter = TypedEventFilter<LiquidateEvent>;

export interface PutCollateralEventObject {
  positionId: BigNumber;
  caller: string;
  token: string;
  id: BigNumber;
  amount: BigNumber;
}
export type PutCollateralEvent = TypedEvent<
  [BigNumber, string, string, BigNumber, BigNumber],
  PutCollateralEventObject
>;

export type PutCollateralEventFilter = TypedEventFilter<PutCollateralEvent>;

export interface RepayEventObject {
  positionId: BigNumber;
  caller: string;
  token: string;
  amount: BigNumber;
  share: BigNumber;
}
export type RepayEvent = TypedEvent<[BigNumber, string, string, BigNumber, BigNumber], RepayEventObject>;

export type RepayEventFilter = TypedEventFilter<RepayEvent>;

export interface SetFeeBpsEventObject {
  feeBps: BigNumber;
}
export type SetFeeBpsEvent = TypedEvent<[BigNumber], SetFeeBpsEventObject>;

export type SetFeeBpsEventFilter = TypedEventFilter<SetFeeBpsEvent>;

export interface SetGovernorEventObject {
  governor: string;
}
export type SetGovernorEvent = TypedEvent<[string], SetGovernorEventObject>;

export type SetGovernorEventFilter = TypedEventFilter<SetGovernorEvent>;

export interface SetOracleEventObject {
  oracle: string;
}
export type SetOracleEvent = TypedEvent<[string], SetOracleEventObject>;

export type SetOracleEventFilter = TypedEventFilter<SetOracleEvent>;

export interface SetPendingGovernorEventObject {
  pendingGovernor: string;
}
export type SetPendingGovernorEvent = TypedEvent<[string], SetPendingGovernorEventObject>;

export type SetPendingGovernorEventFilter = TypedEventFilter<SetPendingGovernorEvent>;

export interface TakeCollateralEventObject {
  positionId: BigNumber;
  caller: string;
  token: string;
  id: BigNumber;
  amount: BigNumber;
}
export type TakeCollateralEvent = TypedEvent<
  [BigNumber, string, string, BigNumber, BigNumber],
  TakeCollateralEventObject
>;

export type TakeCollateralEventFilter = TypedEventFilter<TakeCollateralEvent>;

export interface WithdrawReserveEventObject {
  user: string;
  token: string;
  amount: BigNumber;
}
export type WithdrawReserveEvent = TypedEvent<[string, string, BigNumber], WithdrawReserveEventObject>;

export type WithdrawReserveEventFilter = TypedEventFilter<WithdrawReserveEvent>;

export interface HomoraBank extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: HomoraBankInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    EXECUTOR(overrides?: CallOverrides): Promise<[string]>;

    POSITION_ID(overrides?: CallOverrides): Promise<[BigNumber]>;

    SPELL(overrides?: CallOverrides): Promise<[string]>;

    _GENERAL_LOCK(overrides?: CallOverrides): Promise<[BigNumber]>;

    _IN_EXEC_LOCK(overrides?: CallOverrides): Promise<[BigNumber]>;

    acceptGovernor(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    accrue(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    accrueAll(
      tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    addBank(
      token: PromiseOrValue<string>,
      cToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    allBanks(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    allowBorrowStatus(overrides?: CallOverrides): Promise<[boolean]>;

    allowContractCalls(overrides?: CallOverrides): Promise<[boolean]>;

    allowRepayStatus(overrides?: CallOverrides): Promise<[boolean]>;

    bankStatus(overrides?: CallOverrides): Promise<[BigNumber]>;

    banks(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [boolean, number, string, BigNumber, BigNumber, BigNumber] & {
        isListed: boolean;
        index: number;
        cToken: string;
        reserve: BigNumber;
        totalDebt: BigNumber;
        totalShare: BigNumber;
      }
    >;

    borrow(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    borrowBalanceCurrent(
      positionId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    borrowBalanceStored(
      positionId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    cTokenInBank(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    caster(overrides?: CallOverrides): Promise<[string]>;

    execute(
      positionId: PromiseOrValue<BigNumberish>,
      spell: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    feeBps(overrides?: CallOverrides): Promise<[BigNumber]>;

    getBankInfo(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [boolean, string, BigNumber, BigNumber, BigNumber] & {
        isListed: boolean;
        cToken: string;
        reserve: BigNumber;
        totalDebt: BigNumber;
        totalShare: BigNumber;
      }
    >;

    getBorrowETHValue(positionId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    getCollateralETHValue(positionId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    getCurrentPositionInfo(overrides?: CallOverrides): Promise<
      [string, string, BigNumber, BigNumber] & {
        owner: string;
        collToken: string;
        collId: BigNumber;
        collateralSize: BigNumber;
      }
    >;

    getPositionDebtShareOf(
      positionId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    getPositionDebts(
      positionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string[], BigNumber[]] & { tokens: string[]; debts: BigNumber[] }>;

    getPositionInfo(
      positionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [string, string, BigNumber, BigNumber] & {
        owner: string;
        collToken: string;
        collId: BigNumber;
        collateralSize: BigNumber;
      }
    >;

    governor(overrides?: CallOverrides): Promise<[string]>;

    initialize(
      _oracle: PromiseOrValue<string>,
      _feeBps: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    liquidate(
      positionId: PromiseOrValue<BigNumberish>,
      debtToken: PromiseOrValue<string>,
      amountCall: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    nextPositionId(overrides?: CallOverrides): Promise<[BigNumber]>;

    onERC1155BatchReceived(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>[],
      arg3: PromiseOrValue<BigNumberish>[],
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    onERC1155Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    oracle(overrides?: CallOverrides): Promise<[string]>;

    pendingGovernor(overrides?: CallOverrides): Promise<[string]>;

    positions(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [string, string, BigNumber, BigNumber, BigNumber] & {
        owner: string;
        collToken: string;
        collId: BigNumber;
        collateralSize: BigNumber;
        debtMap: BigNumber;
      }
    >;

    putCollateral(
      collToken: PromiseOrValue<string>,
      collId: PromiseOrValue<BigNumberish>,
      amountCall: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    repay(
      token: PromiseOrValue<string>,
      amountCall: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setAllowContractCalls(
      ok: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setBankStatus(
      _bankStatus: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setFeeBps(
      _feeBps: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setOracle(
      _oracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setPendingGovernor(
      _pendingGovernor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setWhitelistSpells(
      spells: PromiseOrValue<string>[],
      statuses: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setWhitelistTokens(
      tokens: PromiseOrValue<string>[],
      statuses: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setWhitelistUsers(
      users: PromiseOrValue<string>[],
      statuses: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    support(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    supportsInterface(interfaceId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[boolean]>;

    takeCollateral(
      collToken: PromiseOrValue<string>,
      collId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    transmit(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    whitelistedSpells(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    whitelistedTokens(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    whitelistedUsers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    withdrawReserve(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;
  };

  EXECUTOR(overrides?: CallOverrides): Promise<string>;

  POSITION_ID(overrides?: CallOverrides): Promise<BigNumber>;

  SPELL(overrides?: CallOverrides): Promise<string>;

  _GENERAL_LOCK(overrides?: CallOverrides): Promise<BigNumber>;

  _IN_EXEC_LOCK(overrides?: CallOverrides): Promise<BigNumber>;

  acceptGovernor(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  accrue(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  accrueAll(
    tokens: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  addBank(
    token: PromiseOrValue<string>,
    cToken: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  allBanks(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  allowBorrowStatus(overrides?: CallOverrides): Promise<boolean>;

  allowContractCalls(overrides?: CallOverrides): Promise<boolean>;

  allowRepayStatus(overrides?: CallOverrides): Promise<boolean>;

  bankStatus(overrides?: CallOverrides): Promise<BigNumber>;

  banks(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [boolean, number, string, BigNumber, BigNumber, BigNumber] & {
      isListed: boolean;
      index: number;
      cToken: string;
      reserve: BigNumber;
      totalDebt: BigNumber;
      totalShare: BigNumber;
    }
  >;

  borrow(
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  borrowBalanceCurrent(
    positionId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  borrowBalanceStored(
    positionId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  cTokenInBank(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  caster(overrides?: CallOverrides): Promise<string>;

  execute(
    positionId: PromiseOrValue<BigNumberish>,
    spell: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  feeBps(overrides?: CallOverrides): Promise<BigNumber>;

  getBankInfo(
    token: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [boolean, string, BigNumber, BigNumber, BigNumber] & {
      isListed: boolean;
      cToken: string;
      reserve: BigNumber;
      totalDebt: BigNumber;
      totalShare: BigNumber;
    }
  >;

  getBorrowETHValue(positionId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  getCollateralETHValue(positionId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  getCurrentPositionInfo(overrides?: CallOverrides): Promise<
    [string, string, BigNumber, BigNumber] & {
      owner: string;
      collToken: string;
      collId: BigNumber;
      collateralSize: BigNumber;
    }
  >;

  getPositionDebtShareOf(
    positionId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  getPositionDebts(
    positionId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<[string[], BigNumber[]] & { tokens: string[]; debts: BigNumber[] }>;

  getPositionInfo(
    positionId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [string, string, BigNumber, BigNumber] & {
      owner: string;
      collToken: string;
      collId: BigNumber;
      collateralSize: BigNumber;
    }
  >;

  governor(overrides?: CallOverrides): Promise<string>;

  initialize(
    _oracle: PromiseOrValue<string>,
    _feeBps: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  liquidate(
    positionId: PromiseOrValue<BigNumberish>,
    debtToken: PromiseOrValue<string>,
    amountCall: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  nextPositionId(overrides?: CallOverrides): Promise<BigNumber>;

  onERC1155BatchReceived(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    arg2: PromiseOrValue<BigNumberish>[],
    arg3: PromiseOrValue<BigNumberish>[],
    arg4: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  onERC1155Received(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    arg2: PromiseOrValue<BigNumberish>,
    arg3: PromiseOrValue<BigNumberish>,
    arg4: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  oracle(overrides?: CallOverrides): Promise<string>;

  pendingGovernor(overrides?: CallOverrides): Promise<string>;

  positions(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [string, string, BigNumber, BigNumber, BigNumber] & {
      owner: string;
      collToken: string;
      collId: BigNumber;
      collateralSize: BigNumber;
      debtMap: BigNumber;
    }
  >;

  putCollateral(
    collToken: PromiseOrValue<string>,
    collId: PromiseOrValue<BigNumberish>,
    amountCall: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  repay(
    token: PromiseOrValue<string>,
    amountCall: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setAllowContractCalls(
    ok: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setBankStatus(
    _bankStatus: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setFeeBps(
    _feeBps: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setOracle(
    _oracle: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setPendingGovernor(
    _pendingGovernor: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setWhitelistSpells(
    spells: PromiseOrValue<string>[],
    statuses: PromiseOrValue<boolean>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setWhitelistTokens(
    tokens: PromiseOrValue<string>[],
    statuses: PromiseOrValue<boolean>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setWhitelistUsers(
    users: PromiseOrValue<string>[],
    statuses: PromiseOrValue<boolean>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  support(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  supportsInterface(interfaceId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;

  takeCollateral(
    collToken: PromiseOrValue<string>,
    collId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  transmit(
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  whitelistedSpells(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  whitelistedTokens(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  whitelistedUsers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  withdrawReserve(
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    EXECUTOR(overrides?: CallOverrides): Promise<string>;

    POSITION_ID(overrides?: CallOverrides): Promise<BigNumber>;

    SPELL(overrides?: CallOverrides): Promise<string>;

    _GENERAL_LOCK(overrides?: CallOverrides): Promise<BigNumber>;

    _IN_EXEC_LOCK(overrides?: CallOverrides): Promise<BigNumber>;

    acceptGovernor(overrides?: CallOverrides): Promise<void>;

    accrue(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    accrueAll(tokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;

    addBank(token: PromiseOrValue<string>, cToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    allBanks(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    allowBorrowStatus(overrides?: CallOverrides): Promise<boolean>;

    allowContractCalls(overrides?: CallOverrides): Promise<boolean>;

    allowRepayStatus(overrides?: CallOverrides): Promise<boolean>;

    bankStatus(overrides?: CallOverrides): Promise<BigNumber>;

    banks(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [boolean, number, string, BigNumber, BigNumber, BigNumber] & {
        isListed: boolean;
        index: number;
        cToken: string;
        reserve: BigNumber;
        totalDebt: BigNumber;
        totalShare: BigNumber;
      }
    >;

    borrow(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    borrowBalanceCurrent(
      positionId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    borrowBalanceStored(
      positionId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    cTokenInBank(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    caster(overrides?: CallOverrides): Promise<string>;

    execute(
      positionId: PromiseOrValue<BigNumberish>,
      spell: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    feeBps(overrides?: CallOverrides): Promise<BigNumber>;

    getBankInfo(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [boolean, string, BigNumber, BigNumber, BigNumber] & {
        isListed: boolean;
        cToken: string;
        reserve: BigNumber;
        totalDebt: BigNumber;
        totalShare: BigNumber;
      }
    >;

    getBorrowETHValue(positionId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getCollateralETHValue(positionId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getCurrentPositionInfo(overrides?: CallOverrides): Promise<
      [string, string, BigNumber, BigNumber] & {
        owner: string;
        collToken: string;
        collId: BigNumber;
        collateralSize: BigNumber;
      }
    >;

    getPositionDebtShareOf(
      positionId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getPositionDebts(
      positionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string[], BigNumber[]] & { tokens: string[]; debts: BigNumber[] }>;

    getPositionInfo(
      positionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [string, string, BigNumber, BigNumber] & {
        owner: string;
        collToken: string;
        collId: BigNumber;
        collateralSize: BigNumber;
      }
    >;

    governor(overrides?: CallOverrides): Promise<string>;

    initialize(
      _oracle: PromiseOrValue<string>,
      _feeBps: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    liquidate(
      positionId: PromiseOrValue<BigNumberish>,
      debtToken: PromiseOrValue<string>,
      amountCall: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    nextPositionId(overrides?: CallOverrides): Promise<BigNumber>;

    onERC1155BatchReceived(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>[],
      arg3: PromiseOrValue<BigNumberish>[],
      arg4: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<string>;

    onERC1155Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<string>;

    oracle(overrides?: CallOverrides): Promise<string>;

    pendingGovernor(overrides?: CallOverrides): Promise<string>;

    positions(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [string, string, BigNumber, BigNumber, BigNumber] & {
        owner: string;
        collToken: string;
        collId: BigNumber;
        collateralSize: BigNumber;
        debtMap: BigNumber;
      }
    >;

    putCollateral(
      collToken: PromiseOrValue<string>,
      collId: PromiseOrValue<BigNumberish>,
      amountCall: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    repay(
      token: PromiseOrValue<string>,
      amountCall: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setAllowContractCalls(ok: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;

    setBankStatus(_bankStatus: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setFeeBps(_feeBps: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setOracle(_oracle: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setPendingGovernor(_pendingGovernor: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setWhitelistSpells(
      spells: PromiseOrValue<string>[],
      statuses: PromiseOrValue<boolean>[],
      overrides?: CallOverrides,
    ): Promise<void>;

    setWhitelistTokens(
      tokens: PromiseOrValue<string>[],
      statuses: PromiseOrValue<boolean>[],
      overrides?: CallOverrides,
    ): Promise<void>;

    setWhitelistUsers(
      users: PromiseOrValue<string>[],
      statuses: PromiseOrValue<boolean>[],
      overrides?: CallOverrides,
    ): Promise<void>;

    support(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    supportsInterface(interfaceId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;

    takeCollateral(
      collToken: PromiseOrValue<string>,
      collId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    transmit(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    whitelistedSpells(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    whitelistedTokens(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    whitelistedUsers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    withdrawReserve(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;
  };

  filters: {
    'AcceptGovernor(address)'(governor?: null): AcceptGovernorEventFilter;
    AcceptGovernor(governor?: null): AcceptGovernorEventFilter;

    'AddBank(address,address)'(token?: null, cToken?: null): AddBankEventFilter;
    AddBank(token?: null, cToken?: null): AddBankEventFilter;

    'Borrow(uint256,address,address,uint256,uint256)'(
      positionId?: null,
      caller?: null,
      token?: null,
      amount?: null,
      share?: null,
    ): BorrowEventFilter;
    Borrow(positionId?: null, caller?: null, token?: null, amount?: null, share?: null): BorrowEventFilter;

    'Liquidate(uint256,address,address,uint256,uint256,uint256)'(
      positionId?: null,
      liquidator?: null,
      debtToken?: null,
      amount?: null,
      share?: null,
      bounty?: null,
    ): LiquidateEventFilter;
    Liquidate(
      positionId?: null,
      liquidator?: null,
      debtToken?: null,
      amount?: null,
      share?: null,
      bounty?: null,
    ): LiquidateEventFilter;

    'PutCollateral(uint256,address,address,uint256,uint256)'(
      positionId?: null,
      caller?: null,
      token?: null,
      id?: null,
      amount?: null,
    ): PutCollateralEventFilter;
    PutCollateral(positionId?: null, caller?: null, token?: null, id?: null, amount?: null): PutCollateralEventFilter;

    'Repay(uint256,address,address,uint256,uint256)'(
      positionId?: null,
      caller?: null,
      token?: null,
      amount?: null,
      share?: null,
    ): RepayEventFilter;
    Repay(positionId?: null, caller?: null, token?: null, amount?: null, share?: null): RepayEventFilter;

    'SetFeeBps(uint256)'(feeBps?: null): SetFeeBpsEventFilter;
    SetFeeBps(feeBps?: null): SetFeeBpsEventFilter;

    'SetGovernor(address)'(governor?: null): SetGovernorEventFilter;
    SetGovernor(governor?: null): SetGovernorEventFilter;

    'SetOracle(address)'(oracle?: null): SetOracleEventFilter;
    SetOracle(oracle?: null): SetOracleEventFilter;

    'SetPendingGovernor(address)'(pendingGovernor?: null): SetPendingGovernorEventFilter;
    SetPendingGovernor(pendingGovernor?: null): SetPendingGovernorEventFilter;

    'TakeCollateral(uint256,address,address,uint256,uint256)'(
      positionId?: null,
      caller?: null,
      token?: null,
      id?: null,
      amount?: null,
    ): TakeCollateralEventFilter;
    TakeCollateral(positionId?: null, caller?: null, token?: null, id?: null, amount?: null): TakeCollateralEventFilter;

    'WithdrawReserve(address,address,uint256)'(user?: null, token?: null, amount?: null): WithdrawReserveEventFilter;
    WithdrawReserve(user?: null, token?: null, amount?: null): WithdrawReserveEventFilter;
  };

  estimateGas: {
    EXECUTOR(overrides?: CallOverrides): Promise<BigNumber>;

    POSITION_ID(overrides?: CallOverrides): Promise<BigNumber>;

    SPELL(overrides?: CallOverrides): Promise<BigNumber>;

    _GENERAL_LOCK(overrides?: CallOverrides): Promise<BigNumber>;

    _IN_EXEC_LOCK(overrides?: CallOverrides): Promise<BigNumber>;

    acceptGovernor(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    accrue(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    accrueAll(
      tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    addBank(
      token: PromiseOrValue<string>,
      cToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    allBanks(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    allowBorrowStatus(overrides?: CallOverrides): Promise<BigNumber>;

    allowContractCalls(overrides?: CallOverrides): Promise<BigNumber>;

    allowRepayStatus(overrides?: CallOverrides): Promise<BigNumber>;

    bankStatus(overrides?: CallOverrides): Promise<BigNumber>;

    banks(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    borrow(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    borrowBalanceCurrent(
      positionId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    borrowBalanceStored(
      positionId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    cTokenInBank(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    caster(overrides?: CallOverrides): Promise<BigNumber>;

    execute(
      positionId: PromiseOrValue<BigNumberish>,
      spell: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    feeBps(overrides?: CallOverrides): Promise<BigNumber>;

    getBankInfo(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getBorrowETHValue(positionId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getCollateralETHValue(positionId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getCurrentPositionInfo(overrides?: CallOverrides): Promise<BigNumber>;

    getPositionDebtShareOf(
      positionId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getPositionDebts(positionId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getPositionInfo(positionId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    governor(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      _oracle: PromiseOrValue<string>,
      _feeBps: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    liquidate(
      positionId: PromiseOrValue<BigNumberish>,
      debtToken: PromiseOrValue<string>,
      amountCall: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    nextPositionId(overrides?: CallOverrides): Promise<BigNumber>;

    onERC1155BatchReceived(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>[],
      arg3: PromiseOrValue<BigNumberish>[],
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    onERC1155Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    oracle(overrides?: CallOverrides): Promise<BigNumber>;

    pendingGovernor(overrides?: CallOverrides): Promise<BigNumber>;

    positions(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    putCollateral(
      collToken: PromiseOrValue<string>,
      collId: PromiseOrValue<BigNumberish>,
      amountCall: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    repay(
      token: PromiseOrValue<string>,
      amountCall: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setAllowContractCalls(
      ok: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setBankStatus(
      _bankStatus: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setFeeBps(
      _feeBps: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setOracle(
      _oracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setPendingGovernor(
      _pendingGovernor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setWhitelistSpells(
      spells: PromiseOrValue<string>[],
      statuses: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setWhitelistTokens(
      tokens: PromiseOrValue<string>[],
      statuses: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setWhitelistUsers(
      users: PromiseOrValue<string>[],
      statuses: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    support(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    supportsInterface(interfaceId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    takeCollateral(
      collToken: PromiseOrValue<string>,
      collId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    transmit(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    whitelistedSpells(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    whitelistedTokens(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    whitelistedUsers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    withdrawReserve(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    EXECUTOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    POSITION_ID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    SPELL(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    _GENERAL_LOCK(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    _IN_EXEC_LOCK(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    acceptGovernor(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    accrue(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    accrueAll(
      tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    addBank(
      token: PromiseOrValue<string>,
      cToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    allBanks(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    allowBorrowStatus(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    allowContractCalls(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    allowRepayStatus(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bankStatus(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    banks(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    borrow(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    borrowBalanceCurrent(
      positionId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    borrowBalanceStored(
      positionId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    cTokenInBank(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    caster(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    execute(
      positionId: PromiseOrValue<BigNumberish>,
      spell: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    feeBps(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getBankInfo(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getBorrowETHValue(
      positionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getCollateralETHValue(
      positionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getCurrentPositionInfo(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getPositionDebtShareOf(
      positionId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getPositionDebts(
      positionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getPositionInfo(positionId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    governor(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initialize(
      _oracle: PromiseOrValue<string>,
      _feeBps: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    liquidate(
      positionId: PromiseOrValue<BigNumberish>,
      debtToken: PromiseOrValue<string>,
      amountCall: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    nextPositionId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    onERC1155BatchReceived(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>[],
      arg3: PromiseOrValue<BigNumberish>[],
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    onERC1155Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    oracle(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingGovernor(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    positions(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    putCollateral(
      collToken: PromiseOrValue<string>,
      collId: PromiseOrValue<BigNumberish>,
      amountCall: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    repay(
      token: PromiseOrValue<string>,
      amountCall: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setAllowContractCalls(
      ok: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setBankStatus(
      _bankStatus: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setFeeBps(
      _feeBps: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setOracle(
      _oracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setPendingGovernor(
      _pendingGovernor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setWhitelistSpells(
      spells: PromiseOrValue<string>[],
      statuses: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setWhitelistTokens(
      tokens: PromiseOrValue<string>[],
      statuses: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setWhitelistUsers(
      users: PromiseOrValue<string>[],
      statuses: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    support(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    supportsInterface(interfaceId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    takeCollateral(
      collToken: PromiseOrValue<string>,
      collId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    transmit(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    whitelistedSpells(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    whitelistedTokens(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    whitelistedUsers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdrawReserve(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;
  };
}

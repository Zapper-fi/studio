/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export declare namespace BridgeAdminInterface {
  export type DepositUtilityContractsStruct = {
    depositContract: PromiseOrValue<string>;
    messengerContract: PromiseOrValue<string>;
  };

  export type DepositUtilityContractsStructOutput = [string, string] & {
    depositContract: string;
    messengerContract: string;
  };
}

export interface EthBridgeAdminInterface extends utils.Interface {
  functions: {
    'depositContracts(uint256)': FunctionFragment;
    'finder()': FunctionFragment;
    'identifier()': FunctionFragment;
    'optimisticOracleLiveness()': FunctionFragment;
    'owner()': FunctionFragment;
    'proposerBondPct()': FunctionFragment;
    'renounceOwnership()': FunctionFragment;
    'setCrossDomainAdmin(uint256,address,uint256,uint256,uint256,uint256)': FunctionFragment;
    'setDepositContract(uint256,address,address)': FunctionFragment;
    'setEnableDeposits(uint256,address,bool,uint256,uint256,uint256,uint256)': FunctionFragment;
    'setIdentifier(bytes32)': FunctionFragment;
    'setMinimumBridgingDelay(uint256,uint64,uint256,uint256,uint256,uint256)': FunctionFragment;
    'setOptimisticOracleLiveness(uint32)': FunctionFragment;
    'setProposerBondPct(uint64)': FunctionFragment;
    'transferBridgePoolAdmin(address[],address)': FunctionFragment;
    'transferOwnership(address)': FunctionFragment;
    'whitelistToken(uint256,address,address,address,uint256,uint256,uint256,uint256)': FunctionFragment;
    'whitelistedTokens(address,uint256)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'depositContracts'
      | 'finder'
      | 'identifier'
      | 'optimisticOracleLiveness'
      | 'owner'
      | 'proposerBondPct'
      | 'renounceOwnership'
      | 'setCrossDomainAdmin'
      | 'setDepositContract'
      | 'setEnableDeposits'
      | 'setIdentifier'
      | 'setMinimumBridgingDelay'
      | 'setOptimisticOracleLiveness'
      | 'setProposerBondPct'
      | 'transferBridgePoolAdmin'
      | 'transferOwnership'
      | 'whitelistToken'
      | 'whitelistedTokens',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'depositContracts', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'finder', values?: undefined): string;
  encodeFunctionData(functionFragment: 'identifier', values?: undefined): string;
  encodeFunctionData(functionFragment: 'optimisticOracleLiveness', values?: undefined): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'proposerBondPct', values?: undefined): string;
  encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'setCrossDomainAdmin',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'setDepositContract',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setEnableDeposits',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'setIdentifier', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(
    functionFragment: 'setMinimumBridgingDelay',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'setOptimisticOracleLiveness', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setProposerBondPct', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'transferBridgePoolAdmin',
    values: [PromiseOrValue<string>[], PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'transferOwnership', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'whitelistToken',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'whitelistedTokens',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;

  decodeFunctionResult(functionFragment: 'depositContracts', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'finder', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'identifier', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'optimisticOracleLiveness', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'proposerBondPct', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setCrossDomainAdmin', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setDepositContract', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setEnableDeposits', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setIdentifier', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMinimumBridgingDelay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setOptimisticOracleLiveness', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setProposerBondPct', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferBridgePoolAdmin', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'whitelistToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'whitelistedTokens', data: BytesLike): Result;

  events: {
    'BridgePoolsAdminTransferred(address[],address)': EventFragment;
    'DepositsEnabled(uint256,address,bool)': EventFragment;
    'OwnershipTransferred(address,address)': EventFragment;
    'SetCrossDomainAdmin(uint256,address)': EventFragment;
    'SetDepositContracts(uint256,address,address)': EventFragment;
    'SetMinimumBridgingDelay(uint256,uint64)': EventFragment;
    'SetOptimisticOracleLiveness(uint32)': EventFragment;
    'SetProposerBondPct(uint64)': EventFragment;
    'SetRelayIdentifier(bytes32)': EventFragment;
    'WhitelistToken(uint256,address,address,address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'BridgePoolsAdminTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'DepositsEnabled'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SetCrossDomainAdmin'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SetDepositContracts'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SetMinimumBridgingDelay'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SetOptimisticOracleLiveness'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SetProposerBondPct'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SetRelayIdentifier'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'WhitelistToken'): EventFragment;
}

export interface BridgePoolsAdminTransferredEventObject {
  bridgePools: string[];
  newAdmin: string;
}
export type BridgePoolsAdminTransferredEvent = TypedEvent<[string[], string], BridgePoolsAdminTransferredEventObject>;

export type BridgePoolsAdminTransferredEventFilter = TypedEventFilter<BridgePoolsAdminTransferredEvent>;

export interface DepositsEnabledEventObject {
  chainId: BigNumber;
  l2Token: string;
  depositsEnabled: boolean;
}
export type DepositsEnabledEvent = TypedEvent<[BigNumber, string, boolean], DepositsEnabledEventObject>;

export type DepositsEnabledEventFilter = TypedEventFilter<DepositsEnabledEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<[string, string], OwnershipTransferredEventObject>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export interface SetCrossDomainAdminEventObject {
  chainId: BigNumber;
  newAdmin: string;
}
export type SetCrossDomainAdminEvent = TypedEvent<[BigNumber, string], SetCrossDomainAdminEventObject>;

export type SetCrossDomainAdminEventFilter = TypedEventFilter<SetCrossDomainAdminEvent>;

export interface SetDepositContractsEventObject {
  chainId: BigNumber;
  l2DepositContract: string;
  l2MessengerContract: string;
}
export type SetDepositContractsEvent = TypedEvent<[BigNumber, string, string], SetDepositContractsEventObject>;

export type SetDepositContractsEventFilter = TypedEventFilter<SetDepositContractsEvent>;

export interface SetMinimumBridgingDelayEventObject {
  chainId: BigNumber;
  newMinimumBridgingDelay: BigNumber;
}
export type SetMinimumBridgingDelayEvent = TypedEvent<[BigNumber, BigNumber], SetMinimumBridgingDelayEventObject>;

export type SetMinimumBridgingDelayEventFilter = TypedEventFilter<SetMinimumBridgingDelayEvent>;

export interface SetOptimisticOracleLivenessEventObject {
  liveness: number;
}
export type SetOptimisticOracleLivenessEvent = TypedEvent<[number], SetOptimisticOracleLivenessEventObject>;

export type SetOptimisticOracleLivenessEventFilter = TypedEventFilter<SetOptimisticOracleLivenessEvent>;

export interface SetProposerBondPctEventObject {
  proposerBondPct: BigNumber;
}
export type SetProposerBondPctEvent = TypedEvent<[BigNumber], SetProposerBondPctEventObject>;

export type SetProposerBondPctEventFilter = TypedEventFilter<SetProposerBondPctEvent>;

export interface SetRelayIdentifierEventObject {
  identifier: string;
}
export type SetRelayIdentifierEvent = TypedEvent<[string], SetRelayIdentifierEventObject>;

export type SetRelayIdentifierEventFilter = TypedEventFilter<SetRelayIdentifierEvent>;

export interface WhitelistTokenEventObject {
  chainId: BigNumber;
  l1Token: string;
  l2Token: string;
  bridgePool: string;
}
export type WhitelistTokenEvent = TypedEvent<[BigNumber, string, string, string], WhitelistTokenEventObject>;

export type WhitelistTokenEventFilter = TypedEventFilter<WhitelistTokenEvent>;

export interface EthBridgeAdmin extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: EthBridgeAdminInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    depositContracts(
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BridgeAdminInterface.DepositUtilityContractsStructOutput]>;

    finder(overrides?: CallOverrides): Promise<[string]>;

    identifier(overrides?: CallOverrides): Promise<[string]>;

    optimisticOracleLiveness(overrides?: CallOverrides): Promise<[number]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    proposerBondPct(overrides?: CallOverrides): Promise<[BigNumber]>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    setCrossDomainAdmin(
      chainId: PromiseOrValue<BigNumberish>,
      admin: PromiseOrValue<string>,
      l1CallValue: PromiseOrValue<BigNumberish>,
      l2Gas: PromiseOrValue<BigNumberish>,
      l2GasPrice: PromiseOrValue<BigNumberish>,
      maxSubmissionCost: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setDepositContract(
      chainId: PromiseOrValue<BigNumberish>,
      depositContract: PromiseOrValue<string>,
      messengerContract: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setEnableDeposits(
      chainId: PromiseOrValue<BigNumberish>,
      l2Token: PromiseOrValue<string>,
      depositsEnabled: PromiseOrValue<boolean>,
      l1CallValue: PromiseOrValue<BigNumberish>,
      l2Gas: PromiseOrValue<BigNumberish>,
      l2GasPrice: PromiseOrValue<BigNumberish>,
      maxSubmissionCost: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setIdentifier(
      _identifier: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setMinimumBridgingDelay(
      chainId: PromiseOrValue<BigNumberish>,
      minimumBridgingDelay: PromiseOrValue<BigNumberish>,
      l1CallValue: PromiseOrValue<BigNumberish>,
      l2Gas: PromiseOrValue<BigNumberish>,
      l2GasPrice: PromiseOrValue<BigNumberish>,
      maxSubmissionCost: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setOptimisticOracleLiveness(
      liveness: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setProposerBondPct(
      _proposerBondPct: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    transferBridgePoolAdmin(
      bridgePools: PromiseOrValue<string>[],
      newAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    whitelistToken(
      chainId: PromiseOrValue<BigNumberish>,
      l1Token: PromiseOrValue<string>,
      l2Token: PromiseOrValue<string>,
      bridgePool: PromiseOrValue<string>,
      l1CallValue: PromiseOrValue<BigNumberish>,
      l2Gas: PromiseOrValue<BigNumberish>,
      l2GasPrice: PromiseOrValue<BigNumberish>,
      maxSubmissionCost: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    whitelistedTokens(
      l1Token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string, string] & { l2Token: string; bridgePool: string }>;
  };

  depositContracts(
    chainId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BridgeAdminInterface.DepositUtilityContractsStructOutput>;

  finder(overrides?: CallOverrides): Promise<string>;

  identifier(overrides?: CallOverrides): Promise<string>;

  optimisticOracleLiveness(overrides?: CallOverrides): Promise<number>;

  owner(overrides?: CallOverrides): Promise<string>;

  proposerBondPct(overrides?: CallOverrides): Promise<BigNumber>;

  renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  setCrossDomainAdmin(
    chainId: PromiseOrValue<BigNumberish>,
    admin: PromiseOrValue<string>,
    l1CallValue: PromiseOrValue<BigNumberish>,
    l2Gas: PromiseOrValue<BigNumberish>,
    l2GasPrice: PromiseOrValue<BigNumberish>,
    maxSubmissionCost: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setDepositContract(
    chainId: PromiseOrValue<BigNumberish>,
    depositContract: PromiseOrValue<string>,
    messengerContract: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setEnableDeposits(
    chainId: PromiseOrValue<BigNumberish>,
    l2Token: PromiseOrValue<string>,
    depositsEnabled: PromiseOrValue<boolean>,
    l1CallValue: PromiseOrValue<BigNumberish>,
    l2Gas: PromiseOrValue<BigNumberish>,
    l2GasPrice: PromiseOrValue<BigNumberish>,
    maxSubmissionCost: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setIdentifier(
    _identifier: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setMinimumBridgingDelay(
    chainId: PromiseOrValue<BigNumberish>,
    minimumBridgingDelay: PromiseOrValue<BigNumberish>,
    l1CallValue: PromiseOrValue<BigNumberish>,
    l2Gas: PromiseOrValue<BigNumberish>,
    l2GasPrice: PromiseOrValue<BigNumberish>,
    maxSubmissionCost: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setOptimisticOracleLiveness(
    liveness: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setProposerBondPct(
    _proposerBondPct: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  transferBridgePoolAdmin(
    bridgePools: PromiseOrValue<string>[],
    newAdmin: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  whitelistToken(
    chainId: PromiseOrValue<BigNumberish>,
    l1Token: PromiseOrValue<string>,
    l2Token: PromiseOrValue<string>,
    bridgePool: PromiseOrValue<string>,
    l1CallValue: PromiseOrValue<BigNumberish>,
    l2Gas: PromiseOrValue<BigNumberish>,
    l2GasPrice: PromiseOrValue<BigNumberish>,
    maxSubmissionCost: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  whitelistedTokens(
    l1Token: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<[string, string] & { l2Token: string; bridgePool: string }>;

  callStatic: {
    depositContracts(
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BridgeAdminInterface.DepositUtilityContractsStructOutput>;

    finder(overrides?: CallOverrides): Promise<string>;

    identifier(overrides?: CallOverrides): Promise<string>;

    optimisticOracleLiveness(overrides?: CallOverrides): Promise<number>;

    owner(overrides?: CallOverrides): Promise<string>;

    proposerBondPct(overrides?: CallOverrides): Promise<BigNumber>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    setCrossDomainAdmin(
      chainId: PromiseOrValue<BigNumberish>,
      admin: PromiseOrValue<string>,
      l1CallValue: PromiseOrValue<BigNumberish>,
      l2Gas: PromiseOrValue<BigNumberish>,
      l2GasPrice: PromiseOrValue<BigNumberish>,
      maxSubmissionCost: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setDepositContract(
      chainId: PromiseOrValue<BigNumberish>,
      depositContract: PromiseOrValue<string>,
      messengerContract: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setEnableDeposits(
      chainId: PromiseOrValue<BigNumberish>,
      l2Token: PromiseOrValue<string>,
      depositsEnabled: PromiseOrValue<boolean>,
      l1CallValue: PromiseOrValue<BigNumberish>,
      l2Gas: PromiseOrValue<BigNumberish>,
      l2GasPrice: PromiseOrValue<BigNumberish>,
      maxSubmissionCost: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setIdentifier(_identifier: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;

    setMinimumBridgingDelay(
      chainId: PromiseOrValue<BigNumberish>,
      minimumBridgingDelay: PromiseOrValue<BigNumberish>,
      l1CallValue: PromiseOrValue<BigNumberish>,
      l2Gas: PromiseOrValue<BigNumberish>,
      l2GasPrice: PromiseOrValue<BigNumberish>,
      maxSubmissionCost: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setOptimisticOracleLiveness(liveness: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setProposerBondPct(_proposerBondPct: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    transferBridgePoolAdmin(
      bridgePools: PromiseOrValue<string>[],
      newAdmin: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    transferOwnership(newOwner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    whitelistToken(
      chainId: PromiseOrValue<BigNumberish>,
      l1Token: PromiseOrValue<string>,
      l2Token: PromiseOrValue<string>,
      bridgePool: PromiseOrValue<string>,
      l1CallValue: PromiseOrValue<BigNumberish>,
      l2Gas: PromiseOrValue<BigNumberish>,
      l2GasPrice: PromiseOrValue<BigNumberish>,
      maxSubmissionCost: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    whitelistedTokens(
      l1Token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string, string] & { l2Token: string; bridgePool: string }>;
  };

  filters: {
    'BridgePoolsAdminTransferred(address[],address)'(
      bridgePools?: null,
      newAdmin?: PromiseOrValue<string> | null,
    ): BridgePoolsAdminTransferredEventFilter;
    BridgePoolsAdminTransferred(
      bridgePools?: null,
      newAdmin?: PromiseOrValue<string> | null,
    ): BridgePoolsAdminTransferredEventFilter;

    'DepositsEnabled(uint256,address,bool)'(
      chainId?: PromiseOrValue<BigNumberish> | null,
      l2Token?: PromiseOrValue<string> | null,
      depositsEnabled?: null,
    ): DepositsEnabledEventFilter;
    DepositsEnabled(
      chainId?: PromiseOrValue<BigNumberish> | null,
      l2Token?: PromiseOrValue<string> | null,
      depositsEnabled?: null,
    ): DepositsEnabledEventFilter;

    'OwnershipTransferred(address,address)'(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;

    'SetCrossDomainAdmin(uint256,address)'(
      chainId?: PromiseOrValue<BigNumberish> | null,
      newAdmin?: PromiseOrValue<string> | null,
    ): SetCrossDomainAdminEventFilter;
    SetCrossDomainAdmin(
      chainId?: PromiseOrValue<BigNumberish> | null,
      newAdmin?: PromiseOrValue<string> | null,
    ): SetCrossDomainAdminEventFilter;

    'SetDepositContracts(uint256,address,address)'(
      chainId?: PromiseOrValue<BigNumberish> | null,
      l2DepositContract?: PromiseOrValue<string> | null,
      l2MessengerContract?: PromiseOrValue<string> | null,
    ): SetDepositContractsEventFilter;
    SetDepositContracts(
      chainId?: PromiseOrValue<BigNumberish> | null,
      l2DepositContract?: PromiseOrValue<string> | null,
      l2MessengerContract?: PromiseOrValue<string> | null,
    ): SetDepositContractsEventFilter;

    'SetMinimumBridgingDelay(uint256,uint64)'(
      chainId?: PromiseOrValue<BigNumberish> | null,
      newMinimumBridgingDelay?: null,
    ): SetMinimumBridgingDelayEventFilter;
    SetMinimumBridgingDelay(
      chainId?: PromiseOrValue<BigNumberish> | null,
      newMinimumBridgingDelay?: null,
    ): SetMinimumBridgingDelayEventFilter;

    'SetOptimisticOracleLiveness(uint32)'(
      liveness?: PromiseOrValue<BigNumberish> | null,
    ): SetOptimisticOracleLivenessEventFilter;
    SetOptimisticOracleLiveness(liveness?: PromiseOrValue<BigNumberish> | null): SetOptimisticOracleLivenessEventFilter;

    'SetProposerBondPct(uint64)'(proposerBondPct?: PromiseOrValue<BigNumberish> | null): SetProposerBondPctEventFilter;
    SetProposerBondPct(proposerBondPct?: PromiseOrValue<BigNumberish> | null): SetProposerBondPctEventFilter;

    'SetRelayIdentifier(bytes32)'(identifier?: PromiseOrValue<BytesLike> | null): SetRelayIdentifierEventFilter;
    SetRelayIdentifier(identifier?: PromiseOrValue<BytesLike> | null): SetRelayIdentifierEventFilter;

    'WhitelistToken(uint256,address,address,address)'(
      chainId?: null,
      l1Token?: PromiseOrValue<string> | null,
      l2Token?: PromiseOrValue<string> | null,
      bridgePool?: PromiseOrValue<string> | null,
    ): WhitelistTokenEventFilter;
    WhitelistToken(
      chainId?: null,
      l1Token?: PromiseOrValue<string> | null,
      l2Token?: PromiseOrValue<string> | null,
      bridgePool?: PromiseOrValue<string> | null,
    ): WhitelistTokenEventFilter;
  };

  estimateGas: {
    depositContracts(chainId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    finder(overrides?: CallOverrides): Promise<BigNumber>;

    identifier(overrides?: CallOverrides): Promise<BigNumber>;

    optimisticOracleLiveness(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    proposerBondPct(overrides?: CallOverrides): Promise<BigNumber>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    setCrossDomainAdmin(
      chainId: PromiseOrValue<BigNumberish>,
      admin: PromiseOrValue<string>,
      l1CallValue: PromiseOrValue<BigNumberish>,
      l2Gas: PromiseOrValue<BigNumberish>,
      l2GasPrice: PromiseOrValue<BigNumberish>,
      maxSubmissionCost: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setDepositContract(
      chainId: PromiseOrValue<BigNumberish>,
      depositContract: PromiseOrValue<string>,
      messengerContract: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setEnableDeposits(
      chainId: PromiseOrValue<BigNumberish>,
      l2Token: PromiseOrValue<string>,
      depositsEnabled: PromiseOrValue<boolean>,
      l1CallValue: PromiseOrValue<BigNumberish>,
      l2Gas: PromiseOrValue<BigNumberish>,
      l2GasPrice: PromiseOrValue<BigNumberish>,
      maxSubmissionCost: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setIdentifier(
      _identifier: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setMinimumBridgingDelay(
      chainId: PromiseOrValue<BigNumberish>,
      minimumBridgingDelay: PromiseOrValue<BigNumberish>,
      l1CallValue: PromiseOrValue<BigNumberish>,
      l2Gas: PromiseOrValue<BigNumberish>,
      l2GasPrice: PromiseOrValue<BigNumberish>,
      maxSubmissionCost: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setOptimisticOracleLiveness(
      liveness: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setProposerBondPct(
      _proposerBondPct: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    transferBridgePoolAdmin(
      bridgePools: PromiseOrValue<string>[],
      newAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    whitelistToken(
      chainId: PromiseOrValue<BigNumberish>,
      l1Token: PromiseOrValue<string>,
      l2Token: PromiseOrValue<string>,
      bridgePool: PromiseOrValue<string>,
      l1CallValue: PromiseOrValue<BigNumberish>,
      l2Gas: PromiseOrValue<BigNumberish>,
      l2GasPrice: PromiseOrValue<BigNumberish>,
      maxSubmissionCost: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    whitelistedTokens(
      l1Token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    depositContracts(chainId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    finder(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    identifier(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    optimisticOracleLiveness(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proposerBondPct(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    setCrossDomainAdmin(
      chainId: PromiseOrValue<BigNumberish>,
      admin: PromiseOrValue<string>,
      l1CallValue: PromiseOrValue<BigNumberish>,
      l2Gas: PromiseOrValue<BigNumberish>,
      l2GasPrice: PromiseOrValue<BigNumberish>,
      maxSubmissionCost: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setDepositContract(
      chainId: PromiseOrValue<BigNumberish>,
      depositContract: PromiseOrValue<string>,
      messengerContract: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setEnableDeposits(
      chainId: PromiseOrValue<BigNumberish>,
      l2Token: PromiseOrValue<string>,
      depositsEnabled: PromiseOrValue<boolean>,
      l1CallValue: PromiseOrValue<BigNumberish>,
      l2Gas: PromiseOrValue<BigNumberish>,
      l2GasPrice: PromiseOrValue<BigNumberish>,
      maxSubmissionCost: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setIdentifier(
      _identifier: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setMinimumBridgingDelay(
      chainId: PromiseOrValue<BigNumberish>,
      minimumBridgingDelay: PromiseOrValue<BigNumberish>,
      l1CallValue: PromiseOrValue<BigNumberish>,
      l2Gas: PromiseOrValue<BigNumberish>,
      l2GasPrice: PromiseOrValue<BigNumberish>,
      maxSubmissionCost: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setOptimisticOracleLiveness(
      liveness: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setProposerBondPct(
      _proposerBondPct: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    transferBridgePoolAdmin(
      bridgePools: PromiseOrValue<string>[],
      newAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    whitelistToken(
      chainId: PromiseOrValue<BigNumberish>,
      l1Token: PromiseOrValue<string>,
      l2Token: PromiseOrValue<string>,
      bridgePool: PromiseOrValue<string>,
      l1CallValue: PromiseOrValue<BigNumberish>,
      l2Gas: PromiseOrValue<BigNumberish>,
      l2GasPrice: PromiseOrValue<BigNumberish>,
      maxSubmissionCost: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    whitelistedTokens(
      l1Token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;
  };
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export declare namespace BridgePool {
  export type DepositDataStruct = {
    chainId: PromiseOrValue<BigNumberish>;
    depositId: PromiseOrValue<BigNumberish>;
    l1Recipient: PromiseOrValue<string>;
    l2Sender: PromiseOrValue<string>;
    amount: PromiseOrValue<BigNumberish>;
    slowRelayFeePct: PromiseOrValue<BigNumberish>;
    instantRelayFeePct: PromiseOrValue<BigNumberish>;
    quoteTimestamp: PromiseOrValue<BigNumberish>;
  };

  export type DepositDataStructOutput = [
    BigNumber,
    BigNumber,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    number,
  ] & {
    chainId: BigNumber;
    depositId: BigNumber;
    l1Recipient: string;
    l2Sender: string;
    amount: BigNumber;
    slowRelayFeePct: BigNumber;
    instantRelayFeePct: BigNumber;
    quoteTimestamp: number;
  };

  export type RelayDataStruct = {
    relayState: PromiseOrValue<BigNumberish>;
    slowRelayer: PromiseOrValue<string>;
    relayId: PromiseOrValue<BigNumberish>;
    realizedLpFeePct: PromiseOrValue<BigNumberish>;
    priceRequestTime: PromiseOrValue<BigNumberish>;
    proposerBond: PromiseOrValue<BigNumberish>;
    finalFee: PromiseOrValue<BigNumberish>;
  };

  export type RelayDataStructOutput = [number, string, number, BigNumber, number, BigNumber, BigNumber] & {
    relayState: number;
    slowRelayer: string;
    relayId: number;
    realizedLpFeePct: BigNumber;
    priceRequestTime: number;
    proposerBond: BigNumber;
    finalFee: BigNumber;
  };
}

export interface AcrossPoolV1Interface extends utils.Interface {
  functions: {
    'addLiquidity(uint256)': FunctionFragment;
    'allowance(address,address)': FunctionFragment;
    'approve(address,uint256)': FunctionFragment;
    'balanceOf(address)': FunctionFragment;
    'bonds()': FunctionFragment;
    'bridgeAdmin()': FunctionFragment;
    'changeAdmin(address)': FunctionFragment;
    'decimals()': FunctionFragment;
    'decreaseAllowance(address,uint256)': FunctionFragment;
    'disputeRelay((uint256,uint64,address,address,uint256,uint64,uint64,uint32),(uint8,address,uint32,uint64,uint32,uint256,uint256))': FunctionFragment;
    'exchangeRateCurrent()': FunctionFragment;
    'getAccumulatedFees()': FunctionFragment;
    'getCurrentTime()': FunctionFragment;
    'getLiquidityUtilization(uint256)': FunctionFragment;
    'getRelayAncillaryData((uint256,uint64,address,address,uint256,uint64,uint64,uint32),(uint8,address,uint32,uint64,uint32,uint256,uint256))': FunctionFragment;
    'identifier()': FunctionFragment;
    'increaseAllowance(address,uint256)': FunctionFragment;
    'instantRelays(bytes32)': FunctionFragment;
    'isWethPool()': FunctionFragment;
    'l1Token()': FunctionFragment;
    'lastLpFeeUpdate()': FunctionFragment;
    'liquidReserves()': FunctionFragment;
    'liquidityUtilizationCurrent()': FunctionFragment;
    'liquidityUtilizationPostRelay(uint256)': FunctionFragment;
    'lpFeeRatePerSecond()': FunctionFragment;
    'multicall(bytes[])': FunctionFragment;
    'name()': FunctionFragment;
    'numberOfRelays()': FunctionFragment;
    'optimisticOracle()': FunctionFragment;
    'optimisticOracleLiveness()': FunctionFragment;
    'pendingReserves()': FunctionFragment;
    'proposerBondPct()': FunctionFragment;
    'relayAndSpeedUp((uint256,uint64,address,address,uint256,uint64,uint64,uint32),uint64)': FunctionFragment;
    'relayDeposit((uint256,uint64,address,address,uint256,uint64,uint64,uint32),uint64)': FunctionFragment;
    'relays(bytes32)': FunctionFragment;
    'removeLiquidity(uint256,bool)': FunctionFragment;
    'setCurrentTime(uint256)': FunctionFragment;
    'settleRelay((uint256,uint64,address,address,uint256,uint64,uint64,uint32),(uint8,address,uint32,uint64,uint32,uint256,uint256))': FunctionFragment;
    'speedUpRelay((uint256,uint64,address,address,uint256,uint64,uint64,uint32),(uint8,address,uint32,uint64,uint32,uint256,uint256))': FunctionFragment;
    'store()': FunctionFragment;
    'symbol()': FunctionFragment;
    'sync()': FunctionFragment;
    'syncUmaEcosystemParams()': FunctionFragment;
    'syncWithBridgeAdminParams()': FunctionFragment;
    'timerAddress()': FunctionFragment;
    'totalSupply()': FunctionFragment;
    'transfer(address,uint256)': FunctionFragment;
    'transferFrom(address,address,uint256)': FunctionFragment;
    'undistributedLpFees()': FunctionFragment;
    'utilizedReserves()': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'addLiquidity'
      | 'allowance'
      | 'approve'
      | 'balanceOf'
      | 'bonds'
      | 'bridgeAdmin'
      | 'changeAdmin'
      | 'decimals'
      | 'decreaseAllowance'
      | 'disputeRelay'
      | 'exchangeRateCurrent'
      | 'getAccumulatedFees'
      | 'getCurrentTime'
      | 'getLiquidityUtilization'
      | 'getRelayAncillaryData'
      | 'identifier'
      | 'increaseAllowance'
      | 'instantRelays'
      | 'isWethPool'
      | 'l1Token'
      | 'lastLpFeeUpdate'
      | 'liquidReserves'
      | 'liquidityUtilizationCurrent'
      | 'liquidityUtilizationPostRelay'
      | 'lpFeeRatePerSecond'
      | 'multicall'
      | 'name'
      | 'numberOfRelays'
      | 'optimisticOracle'
      | 'optimisticOracleLiveness'
      | 'pendingReserves'
      | 'proposerBondPct'
      | 'relayAndSpeedUp'
      | 'relayDeposit'
      | 'relays'
      | 'removeLiquidity'
      | 'setCurrentTime'
      | 'settleRelay'
      | 'speedUpRelay'
      | 'store'
      | 'symbol'
      | 'sync'
      | 'syncUmaEcosystemParams'
      | 'syncWithBridgeAdminParams'
      | 'timerAddress'
      | 'totalSupply'
      | 'transfer'
      | 'transferFrom'
      | 'undistributedLpFees'
      | 'utilizedReserves',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'addLiquidity', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'allowance', values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'approve',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'balanceOf', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'bonds', values?: undefined): string;
  encodeFunctionData(functionFragment: 'bridgeAdmin', values?: undefined): string;
  encodeFunctionData(functionFragment: 'changeAdmin', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'decimals', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'decreaseAllowance',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'disputeRelay',
    values: [BridgePool.DepositDataStruct, BridgePool.RelayDataStruct],
  ): string;
  encodeFunctionData(functionFragment: 'exchangeRateCurrent', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getAccumulatedFees', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getCurrentTime', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getLiquidityUtilization', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'getRelayAncillaryData',
    values: [BridgePool.DepositDataStruct, BridgePool.RelayDataStruct],
  ): string;
  encodeFunctionData(functionFragment: 'identifier', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'increaseAllowance',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'instantRelays', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(functionFragment: 'isWethPool', values?: undefined): string;
  encodeFunctionData(functionFragment: 'l1Token', values?: undefined): string;
  encodeFunctionData(functionFragment: 'lastLpFeeUpdate', values?: undefined): string;
  encodeFunctionData(functionFragment: 'liquidReserves', values?: undefined): string;
  encodeFunctionData(functionFragment: 'liquidityUtilizationCurrent', values?: undefined): string;
  encodeFunctionData(functionFragment: 'liquidityUtilizationPostRelay', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'lpFeeRatePerSecond', values?: undefined): string;
  encodeFunctionData(functionFragment: 'multicall', values: [PromiseOrValue<BytesLike>[]]): string;
  encodeFunctionData(functionFragment: 'name', values?: undefined): string;
  encodeFunctionData(functionFragment: 'numberOfRelays', values?: undefined): string;
  encodeFunctionData(functionFragment: 'optimisticOracle', values?: undefined): string;
  encodeFunctionData(functionFragment: 'optimisticOracleLiveness', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pendingReserves', values?: undefined): string;
  encodeFunctionData(functionFragment: 'proposerBondPct', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'relayAndSpeedUp',
    values: [BridgePool.DepositDataStruct, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'relayDeposit',
    values: [BridgePool.DepositDataStruct, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'relays', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(
    functionFragment: 'removeLiquidity',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'setCurrentTime', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'settleRelay',
    values: [BridgePool.DepositDataStruct, BridgePool.RelayDataStruct],
  ): string;
  encodeFunctionData(
    functionFragment: 'speedUpRelay',
    values: [BridgePool.DepositDataStruct, BridgePool.RelayDataStruct],
  ): string;
  encodeFunctionData(functionFragment: 'store', values?: undefined): string;
  encodeFunctionData(functionFragment: 'symbol', values?: undefined): string;
  encodeFunctionData(functionFragment: 'sync', values?: undefined): string;
  encodeFunctionData(functionFragment: 'syncUmaEcosystemParams', values?: undefined): string;
  encodeFunctionData(functionFragment: 'syncWithBridgeAdminParams', values?: undefined): string;
  encodeFunctionData(functionFragment: 'timerAddress', values?: undefined): string;
  encodeFunctionData(functionFragment: 'totalSupply', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'transfer',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'transferFrom',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'undistributedLpFees', values?: undefined): string;
  encodeFunctionData(functionFragment: 'utilizedReserves', values?: undefined): string;

  decodeFunctionResult(functionFragment: 'addLiquidity', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allowance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'approve', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'bonds', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'bridgeAdmin', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'changeAdmin', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'decimals', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'decreaseAllowance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'disputeRelay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exchangeRateCurrent', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getAccumulatedFees', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getCurrentTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getLiquidityUtilization', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getRelayAncillaryData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'identifier', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'increaseAllowance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'instantRelays', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isWethPool', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'l1Token', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lastLpFeeUpdate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidReserves', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidityUtilizationCurrent', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidityUtilizationPostRelay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lpFeeRatePerSecond', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'multicall', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'name', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'numberOfRelays', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'optimisticOracle', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'optimisticOracleLiveness', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pendingReserves', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'proposerBondPct', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'relayAndSpeedUp', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'relayDeposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'relays', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'removeLiquidity', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setCurrentTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'settleRelay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'speedUpRelay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'store', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'symbol', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'sync', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'syncUmaEcosystemParams', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'syncWithBridgeAdminParams', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'timerAddress', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalSupply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transfer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferFrom', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'undistributedLpFees', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'utilizedReserves', data: BytesLike): Result;

  events: {
    'Approval(address,address,uint256)': EventFragment;
    'BridgePoolAdminTransferred(address,address)': EventFragment;
    'DepositRelayed(bytes32,tuple,tuple,bytes32)': EventFragment;
    'LiquidityAdded(uint256,uint256,address)': EventFragment;
    'LiquidityRemoved(uint256,uint256,address)': EventFragment;
    'RelayCanceled(bytes32,bytes32,address)': EventFragment;
    'RelayDisputed(bytes32,bytes32,address)': EventFragment;
    'RelaySettled(bytes32,address,tuple)': EventFragment;
    'RelaySpedUp(bytes32,address,tuple)': EventFragment;
    'Transfer(address,address,uint256)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'Approval'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'BridgePoolAdminTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'DepositRelayed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LiquidityAdded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LiquidityRemoved'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RelayCanceled'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RelayDisputed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RelaySettled'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RelaySpedUp'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Transfer'): EventFragment;
}

export interface ApprovalEventObject {
  owner: string;
  spender: string;
  value: BigNumber;
}
export type ApprovalEvent = TypedEvent<[string, string, BigNumber], ApprovalEventObject>;

export type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;

export interface BridgePoolAdminTransferredEventObject {
  oldAdmin: string;
  newAdmin: string;
}
export type BridgePoolAdminTransferredEvent = TypedEvent<[string, string], BridgePoolAdminTransferredEventObject>;

export type BridgePoolAdminTransferredEventFilter = TypedEventFilter<BridgePoolAdminTransferredEvent>;

export interface DepositRelayedEventObject {
  depositHash: string;
  depositData: BridgePool.DepositDataStructOutput;
  relay: BridgePool.RelayDataStructOutput;
  relayAncillaryDataHash: string;
}
export type DepositRelayedEvent = TypedEvent<
  [string, BridgePool.DepositDataStructOutput, BridgePool.RelayDataStructOutput, string],
  DepositRelayedEventObject
>;

export type DepositRelayedEventFilter = TypedEventFilter<DepositRelayedEvent>;

export interface LiquidityAddedEventObject {
  amount: BigNumber;
  lpTokensMinted: BigNumber;
  liquidityProvider: string;
}
export type LiquidityAddedEvent = TypedEvent<[BigNumber, BigNumber, string], LiquidityAddedEventObject>;

export type LiquidityAddedEventFilter = TypedEventFilter<LiquidityAddedEvent>;

export interface LiquidityRemovedEventObject {
  amount: BigNumber;
  lpTokensBurnt: BigNumber;
  liquidityProvider: string;
}
export type LiquidityRemovedEvent = TypedEvent<[BigNumber, BigNumber, string], LiquidityRemovedEventObject>;

export type LiquidityRemovedEventFilter = TypedEventFilter<LiquidityRemovedEvent>;

export interface RelayCanceledEventObject {
  depositHash: string;
  relayHash: string;
  disputer: string;
}
export type RelayCanceledEvent = TypedEvent<[string, string, string], RelayCanceledEventObject>;

export type RelayCanceledEventFilter = TypedEventFilter<RelayCanceledEvent>;

export interface RelayDisputedEventObject {
  depositHash: string;
  relayHash: string;
  disputer: string;
}
export type RelayDisputedEvent = TypedEvent<[string, string, string], RelayDisputedEventObject>;

export type RelayDisputedEventFilter = TypedEventFilter<RelayDisputedEvent>;

export interface RelaySettledEventObject {
  depositHash: string;
  caller: string;
  relay: BridgePool.RelayDataStructOutput;
}
export type RelaySettledEvent = TypedEvent<[string, string, BridgePool.RelayDataStructOutput], RelaySettledEventObject>;

export type RelaySettledEventFilter = TypedEventFilter<RelaySettledEvent>;

export interface RelaySpedUpEventObject {
  depositHash: string;
  instantRelayer: string;
  relay: BridgePool.RelayDataStructOutput;
}
export type RelaySpedUpEvent = TypedEvent<[string, string, BridgePool.RelayDataStructOutput], RelaySpedUpEventObject>;

export type RelaySpedUpEventFilter = TypedEventFilter<RelaySpedUpEvent>;

export interface TransferEventObject {
  from: string;
  to: string;
  value: BigNumber;
}
export type TransferEvent = TypedEvent<[string, string, BigNumber], TransferEventObject>;

export type TransferEventFilter = TypedEventFilter<TransferEvent>;

export interface AcrossPoolV1 extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: AcrossPoolV1Interface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    addLiquidity(
      l1TokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    allowance(
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    approve(
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    bonds(overrides?: CallOverrides): Promise<[BigNumber]>;

    bridgeAdmin(overrides?: CallOverrides): Promise<[string]>;

    changeAdmin(
      _newAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    decimals(overrides?: CallOverrides): Promise<[number]>;

    decreaseAllowance(
      spender: PromiseOrValue<string>,
      subtractedValue: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    disputeRelay(
      depositData: BridgePool.DepositDataStruct,
      relayData: BridgePool.RelayDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    exchangeRateCurrent(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    getAccumulatedFees(overrides?: CallOverrides): Promise<[BigNumber]>;

    getCurrentTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    getLiquidityUtilization(
      relayedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    getRelayAncillaryData(
      depositData: BridgePool.DepositDataStruct,
      relayData: BridgePool.RelayDataStruct,
      overrides?: CallOverrides,
    ): Promise<[string]>;

    identifier(overrides?: CallOverrides): Promise<[string]>;

    increaseAllowance(
      spender: PromiseOrValue<string>,
      addedValue: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    instantRelays(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;

    isWethPool(overrides?: CallOverrides): Promise<[boolean]>;

    l1Token(overrides?: CallOverrides): Promise<[string]>;

    lastLpFeeUpdate(overrides?: CallOverrides): Promise<[number]>;

    liquidReserves(overrides?: CallOverrides): Promise<[BigNumber]>;

    liquidityUtilizationCurrent(
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    liquidityUtilizationPostRelay(
      relayedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    lpFeeRatePerSecond(overrides?: CallOverrides): Promise<[BigNumber]>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    name(overrides?: CallOverrides): Promise<[string]>;

    numberOfRelays(overrides?: CallOverrides): Promise<[number]>;

    optimisticOracle(overrides?: CallOverrides): Promise<[string]>;

    optimisticOracleLiveness(overrides?: CallOverrides): Promise<[number]>;

    pendingReserves(overrides?: CallOverrides): Promise<[BigNumber]>;

    proposerBondPct(overrides?: CallOverrides): Promise<[BigNumber]>;

    relayAndSpeedUp(
      depositData: BridgePool.DepositDataStruct,
      realizedLpFeePct: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    relayDeposit(
      depositData: BridgePool.DepositDataStruct,
      realizedLpFeePct: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    relays(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;

    removeLiquidity(
      lpTokenAmount: PromiseOrValue<BigNumberish>,
      sendEth: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setCurrentTime(
      time: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    settleRelay(
      depositData: BridgePool.DepositDataStruct,
      relayData: BridgePool.RelayDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    speedUpRelay(
      depositData: BridgePool.DepositDataStruct,
      relayData: BridgePool.RelayDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    store(overrides?: CallOverrides): Promise<[string]>;

    symbol(overrides?: CallOverrides): Promise<[string]>;

    sync(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    syncUmaEcosystemParams(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    syncWithBridgeAdminParams(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    timerAddress(overrides?: CallOverrides): Promise<[string]>;

    totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    transfer(
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    transferFrom(
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    undistributedLpFees(overrides?: CallOverrides): Promise<[BigNumber]>;

    utilizedReserves(overrides?: CallOverrides): Promise<[BigNumber]>;
  };

  addLiquidity(
    l1TokenAmount: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  allowance(
    owner: PromiseOrValue<string>,
    spender: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  approve(
    spender: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  bonds(overrides?: CallOverrides): Promise<BigNumber>;

  bridgeAdmin(overrides?: CallOverrides): Promise<string>;

  changeAdmin(
    _newAdmin: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  decimals(overrides?: CallOverrides): Promise<number>;

  decreaseAllowance(
    spender: PromiseOrValue<string>,
    subtractedValue: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  disputeRelay(
    depositData: BridgePool.DepositDataStruct,
    relayData: BridgePool.RelayDataStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  exchangeRateCurrent(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  getAccumulatedFees(overrides?: CallOverrides): Promise<BigNumber>;

  getCurrentTime(overrides?: CallOverrides): Promise<BigNumber>;

  getLiquidityUtilization(
    relayedAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  getRelayAncillaryData(
    depositData: BridgePool.DepositDataStruct,
    relayData: BridgePool.RelayDataStruct,
    overrides?: CallOverrides,
  ): Promise<string>;

  identifier(overrides?: CallOverrides): Promise<string>;

  increaseAllowance(
    spender: PromiseOrValue<string>,
    addedValue: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  instantRelays(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

  isWethPool(overrides?: CallOverrides): Promise<boolean>;

  l1Token(overrides?: CallOverrides): Promise<string>;

  lastLpFeeUpdate(overrides?: CallOverrides): Promise<number>;

  liquidReserves(overrides?: CallOverrides): Promise<BigNumber>;

  liquidityUtilizationCurrent(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  liquidityUtilizationPostRelay(
    relayedAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  lpFeeRatePerSecond(overrides?: CallOverrides): Promise<BigNumber>;

  multicall(
    data: PromiseOrValue<BytesLike>[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  name(overrides?: CallOverrides): Promise<string>;

  numberOfRelays(overrides?: CallOverrides): Promise<number>;

  optimisticOracle(overrides?: CallOverrides): Promise<string>;

  optimisticOracleLiveness(overrides?: CallOverrides): Promise<number>;

  pendingReserves(overrides?: CallOverrides): Promise<BigNumber>;

  proposerBondPct(overrides?: CallOverrides): Promise<BigNumber>;

  relayAndSpeedUp(
    depositData: BridgePool.DepositDataStruct,
    realizedLpFeePct: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  relayDeposit(
    depositData: BridgePool.DepositDataStruct,
    realizedLpFeePct: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  relays(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

  removeLiquidity(
    lpTokenAmount: PromiseOrValue<BigNumberish>,
    sendEth: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setCurrentTime(
    time: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  settleRelay(
    depositData: BridgePool.DepositDataStruct,
    relayData: BridgePool.RelayDataStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  speedUpRelay(
    depositData: BridgePool.DepositDataStruct,
    relayData: BridgePool.RelayDataStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  store(overrides?: CallOverrides): Promise<string>;

  symbol(overrides?: CallOverrides): Promise<string>;

  sync(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  syncUmaEcosystemParams(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  syncWithBridgeAdminParams(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  timerAddress(overrides?: CallOverrides): Promise<string>;

  totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  transfer(
    recipient: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  transferFrom(
    sender: PromiseOrValue<string>,
    recipient: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  undistributedLpFees(overrides?: CallOverrides): Promise<BigNumber>;

  utilizedReserves(overrides?: CallOverrides): Promise<BigNumber>;

  callStatic: {
    addLiquidity(l1TokenAmount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    allowance(
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    approve(
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    bonds(overrides?: CallOverrides): Promise<BigNumber>;

    bridgeAdmin(overrides?: CallOverrides): Promise<string>;

    changeAdmin(_newAdmin: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    decimals(overrides?: CallOverrides): Promise<number>;

    decreaseAllowance(
      spender: PromiseOrValue<string>,
      subtractedValue: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    disputeRelay(
      depositData: BridgePool.DepositDataStruct,
      relayData: BridgePool.RelayDataStruct,
      overrides?: CallOverrides,
    ): Promise<void>;

    exchangeRateCurrent(overrides?: CallOverrides): Promise<BigNumber>;

    getAccumulatedFees(overrides?: CallOverrides): Promise<BigNumber>;

    getCurrentTime(overrides?: CallOverrides): Promise<BigNumber>;

    getLiquidityUtilization(
      relayedAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        utilizationCurrent: BigNumber;
        utilizationPostRelay: BigNumber;
      }
    >;

    getRelayAncillaryData(
      depositData: BridgePool.DepositDataStruct,
      relayData: BridgePool.RelayDataStruct,
      overrides?: CallOverrides,
    ): Promise<string>;

    identifier(overrides?: CallOverrides): Promise<string>;

    increaseAllowance(
      spender: PromiseOrValue<string>,
      addedValue: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    instantRelays(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

    isWethPool(overrides?: CallOverrides): Promise<boolean>;

    l1Token(overrides?: CallOverrides): Promise<string>;

    lastLpFeeUpdate(overrides?: CallOverrides): Promise<number>;

    liquidReserves(overrides?: CallOverrides): Promise<BigNumber>;

    liquidityUtilizationCurrent(overrides?: CallOverrides): Promise<BigNumber>;

    liquidityUtilizationPostRelay(
      relayedAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    lpFeeRatePerSecond(overrides?: CallOverrides): Promise<BigNumber>;

    multicall(data: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<string[]>;

    name(overrides?: CallOverrides): Promise<string>;

    numberOfRelays(overrides?: CallOverrides): Promise<number>;

    optimisticOracle(overrides?: CallOverrides): Promise<string>;

    optimisticOracleLiveness(overrides?: CallOverrides): Promise<number>;

    pendingReserves(overrides?: CallOverrides): Promise<BigNumber>;

    proposerBondPct(overrides?: CallOverrides): Promise<BigNumber>;

    relayAndSpeedUp(
      depositData: BridgePool.DepositDataStruct,
      realizedLpFeePct: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    relayDeposit(
      depositData: BridgePool.DepositDataStruct,
      realizedLpFeePct: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    relays(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

    removeLiquidity(
      lpTokenAmount: PromiseOrValue<BigNumberish>,
      sendEth: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setCurrentTime(time: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    settleRelay(
      depositData: BridgePool.DepositDataStruct,
      relayData: BridgePool.RelayDataStruct,
      overrides?: CallOverrides,
    ): Promise<void>;

    speedUpRelay(
      depositData: BridgePool.DepositDataStruct,
      relayData: BridgePool.RelayDataStruct,
      overrides?: CallOverrides,
    ): Promise<void>;

    store(overrides?: CallOverrides): Promise<string>;

    symbol(overrides?: CallOverrides): Promise<string>;

    sync(overrides?: CallOverrides): Promise<void>;

    syncUmaEcosystemParams(overrides?: CallOverrides): Promise<void>;

    syncWithBridgeAdminParams(overrides?: CallOverrides): Promise<void>;

    timerAddress(overrides?: CallOverrides): Promise<string>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    transfer(
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    transferFrom(
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    undistributedLpFees(overrides?: CallOverrides): Promise<BigNumber>;

    utilizedReserves(overrides?: CallOverrides): Promise<BigNumber>;
  };

  filters: {
    'Approval(address,address,uint256)'(
      owner?: PromiseOrValue<string> | null,
      spender?: PromiseOrValue<string> | null,
      value?: null,
    ): ApprovalEventFilter;
    Approval(
      owner?: PromiseOrValue<string> | null,
      spender?: PromiseOrValue<string> | null,
      value?: null,
    ): ApprovalEventFilter;

    'BridgePoolAdminTransferred(address,address)'(
      oldAdmin?: null,
      newAdmin?: null,
    ): BridgePoolAdminTransferredEventFilter;
    BridgePoolAdminTransferred(oldAdmin?: null, newAdmin?: null): BridgePoolAdminTransferredEventFilter;

    'DepositRelayed(bytes32,tuple,tuple,bytes32)'(
      depositHash?: PromiseOrValue<BytesLike> | null,
      depositData?: null,
      relay?: null,
      relayAncillaryDataHash?: null,
    ): DepositRelayedEventFilter;
    DepositRelayed(
      depositHash?: PromiseOrValue<BytesLike> | null,
      depositData?: null,
      relay?: null,
      relayAncillaryDataHash?: null,
    ): DepositRelayedEventFilter;

    'LiquidityAdded(uint256,uint256,address)'(
      amount?: null,
      lpTokensMinted?: null,
      liquidityProvider?: PromiseOrValue<string> | null,
    ): LiquidityAddedEventFilter;
    LiquidityAdded(
      amount?: null,
      lpTokensMinted?: null,
      liquidityProvider?: PromiseOrValue<string> | null,
    ): LiquidityAddedEventFilter;

    'LiquidityRemoved(uint256,uint256,address)'(
      amount?: null,
      lpTokensBurnt?: null,
      liquidityProvider?: PromiseOrValue<string> | null,
    ): LiquidityRemovedEventFilter;
    LiquidityRemoved(
      amount?: null,
      lpTokensBurnt?: null,
      liquidityProvider?: PromiseOrValue<string> | null,
    ): LiquidityRemovedEventFilter;

    'RelayCanceled(bytes32,bytes32,address)'(
      depositHash?: PromiseOrValue<BytesLike> | null,
      relayHash?: PromiseOrValue<BytesLike> | null,
      disputer?: PromiseOrValue<string> | null,
    ): RelayCanceledEventFilter;
    RelayCanceled(
      depositHash?: PromiseOrValue<BytesLike> | null,
      relayHash?: PromiseOrValue<BytesLike> | null,
      disputer?: PromiseOrValue<string> | null,
    ): RelayCanceledEventFilter;

    'RelayDisputed(bytes32,bytes32,address)'(
      depositHash?: PromiseOrValue<BytesLike> | null,
      relayHash?: PromiseOrValue<BytesLike> | null,
      disputer?: PromiseOrValue<string> | null,
    ): RelayDisputedEventFilter;
    RelayDisputed(
      depositHash?: PromiseOrValue<BytesLike> | null,
      relayHash?: PromiseOrValue<BytesLike> | null,
      disputer?: PromiseOrValue<string> | null,
    ): RelayDisputedEventFilter;

    'RelaySettled(bytes32,address,tuple)'(
      depositHash?: PromiseOrValue<BytesLike> | null,
      caller?: PromiseOrValue<string> | null,
      relay?: null,
    ): RelaySettledEventFilter;
    RelaySettled(
      depositHash?: PromiseOrValue<BytesLike> | null,
      caller?: PromiseOrValue<string> | null,
      relay?: null,
    ): RelaySettledEventFilter;

    'RelaySpedUp(bytes32,address,tuple)'(
      depositHash?: PromiseOrValue<BytesLike> | null,
      instantRelayer?: PromiseOrValue<string> | null,
      relay?: null,
    ): RelaySpedUpEventFilter;
    RelaySpedUp(
      depositHash?: PromiseOrValue<BytesLike> | null,
      instantRelayer?: PromiseOrValue<string> | null,
      relay?: null,
    ): RelaySpedUpEventFilter;

    'Transfer(address,address,uint256)'(
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      value?: null,
    ): TransferEventFilter;
    Transfer(
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      value?: null,
    ): TransferEventFilter;
  };

  estimateGas: {
    addLiquidity(
      l1TokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    allowance(
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    approve(
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    bonds(overrides?: CallOverrides): Promise<BigNumber>;

    bridgeAdmin(overrides?: CallOverrides): Promise<BigNumber>;

    changeAdmin(
      _newAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    decimals(overrides?: CallOverrides): Promise<BigNumber>;

    decreaseAllowance(
      spender: PromiseOrValue<string>,
      subtractedValue: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    disputeRelay(
      depositData: BridgePool.DepositDataStruct,
      relayData: BridgePool.RelayDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    exchangeRateCurrent(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    getAccumulatedFees(overrides?: CallOverrides): Promise<BigNumber>;

    getCurrentTime(overrides?: CallOverrides): Promise<BigNumber>;

    getLiquidityUtilization(
      relayedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    getRelayAncillaryData(
      depositData: BridgePool.DepositDataStruct,
      relayData: BridgePool.RelayDataStruct,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    identifier(overrides?: CallOverrides): Promise<BigNumber>;

    increaseAllowance(
      spender: PromiseOrValue<string>,
      addedValue: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    instantRelays(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    isWethPool(overrides?: CallOverrides): Promise<BigNumber>;

    l1Token(overrides?: CallOverrides): Promise<BigNumber>;

    lastLpFeeUpdate(overrides?: CallOverrides): Promise<BigNumber>;

    liquidReserves(overrides?: CallOverrides): Promise<BigNumber>;

    liquidityUtilizationCurrent(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    liquidityUtilizationPostRelay(
      relayedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    lpFeeRatePerSecond(overrides?: CallOverrides): Promise<BigNumber>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    numberOfRelays(overrides?: CallOverrides): Promise<BigNumber>;

    optimisticOracle(overrides?: CallOverrides): Promise<BigNumber>;

    optimisticOracleLiveness(overrides?: CallOverrides): Promise<BigNumber>;

    pendingReserves(overrides?: CallOverrides): Promise<BigNumber>;

    proposerBondPct(overrides?: CallOverrides): Promise<BigNumber>;

    relayAndSpeedUp(
      depositData: BridgePool.DepositDataStruct,
      realizedLpFeePct: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    relayDeposit(
      depositData: BridgePool.DepositDataStruct,
      realizedLpFeePct: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    relays(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    removeLiquidity(
      lpTokenAmount: PromiseOrValue<BigNumberish>,
      sendEth: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setCurrentTime(
      time: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    settleRelay(
      depositData: BridgePool.DepositDataStruct,
      relayData: BridgePool.RelayDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    speedUpRelay(
      depositData: BridgePool.DepositDataStruct,
      relayData: BridgePool.RelayDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    store(overrides?: CallOverrides): Promise<BigNumber>;

    symbol(overrides?: CallOverrides): Promise<BigNumber>;

    sync(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    syncUmaEcosystemParams(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    syncWithBridgeAdminParams(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    timerAddress(overrides?: CallOverrides): Promise<BigNumber>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    transfer(
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    transferFrom(
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    undistributedLpFees(overrides?: CallOverrides): Promise<BigNumber>;

    utilizedReserves(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    addLiquidity(
      l1TokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    allowance(
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    approve(
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bonds(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bridgeAdmin(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    changeAdmin(
      _newAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    decreaseAllowance(
      spender: PromiseOrValue<string>,
      subtractedValue: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    disputeRelay(
      depositData: BridgePool.DepositDataStruct,
      relayData: BridgePool.RelayDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    exchangeRateCurrent(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    getAccumulatedFees(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getCurrentTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getLiquidityUtilization(
      relayedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    getRelayAncillaryData(
      depositData: BridgePool.DepositDataStruct,
      relayData: BridgePool.RelayDataStruct,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    identifier(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    increaseAllowance(
      spender: PromiseOrValue<string>,
      addedValue: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    instantRelays(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isWethPool(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    l1Token(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastLpFeeUpdate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    liquidReserves(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    liquidityUtilizationCurrent(
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    liquidityUtilizationPostRelay(
      relayedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    lpFeeRatePerSecond(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    numberOfRelays(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    optimisticOracle(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    optimisticOracleLiveness(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingReserves(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proposerBondPct(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    relayAndSpeedUp(
      depositData: BridgePool.DepositDataStruct,
      realizedLpFeePct: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    relayDeposit(
      depositData: BridgePool.DepositDataStruct,
      realizedLpFeePct: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    relays(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    removeLiquidity(
      lpTokenAmount: PromiseOrValue<BigNumberish>,
      sendEth: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setCurrentTime(
      time: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    settleRelay(
      depositData: BridgePool.DepositDataStruct,
      relayData: BridgePool.RelayDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    speedUpRelay(
      depositData: BridgePool.DepositDataStruct,
      relayData: BridgePool.RelayDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    store(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    sync(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    syncUmaEcosystemParams(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    syncWithBridgeAdminParams(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    timerAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transfer(
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    transferFrom(
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    undistributedLpFees(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    utilizedReserves(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}

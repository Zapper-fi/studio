/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from './common';

export interface SynthetixNetworkTokenInterface extends utils.Interface {
  functions: {
    'resolver()': FunctionFragment;
    'maxIssuableSynths(address)': FunctionFragment;
    'name()': FunctionFragment;
    'approve(address,uint256)': FunctionFragment;
    'removeSynth(bytes32)': FunctionFragment;
    'remainingIssuableSynths(address)': FunctionFragment;
    'mint()': FunctionFragment;
    'setIntegrationProxy(address)': FunctionFragment;
    'nominateNewOwner(address)': FunctionFragment;
    'synthsByAddress(address)': FunctionFragment;
    'initiationTime()': FunctionFragment;
    'totalSupply()': FunctionFragment;
    'isWaitingPeriod(bytes32)': FunctionFragment;
    'setSelfDestructBeneficiary(address)': FunctionFragment;
    'transferFrom(address,address,uint256)': FunctionFragment;
    'burnSynths(uint256)': FunctionFragment;
    'burnSynthsToTargetOnBehalf(address)': FunctionFragment;
    'decimals()': FunctionFragment;
    'issueMaxSynthsOnBehalf(address)': FunctionFragment;
    'synths(bytes32)': FunctionFragment;
    'terminateSelfDestruct()': FunctionFragment;
    'setResolverAndSyncCache(address)': FunctionFragment;
    'nominatedOwner()': FunctionFragment;
    'debtBalanceOfAndTotalDebt(address,bytes32)': FunctionFragment;
    'isResolverCached(address)': FunctionFragment;
    'transferableSynthetix(address)': FunctionFragment;
    'emitSynthExchange(address,bytes32,uint256,bytes32,uint256,address)': FunctionFragment;
    'emitExchangeRebate(address,bytes32,uint256)': FunctionFragment;
    'balanceOf(address)': FunctionFragment;
    'availableCurrencyKeys()': FunctionFragment;
    'acceptOwnership()': FunctionFragment;
    'availableSynths(uint256)': FunctionFragment;
    'totalIssuedSynths(bytes32)': FunctionFragment;
    'addSynth(address)': FunctionFragment;
    'issueSynths(uint256)': FunctionFragment;
    'owner()': FunctionFragment;
    'symbol()': FunctionFragment;
    'setProxy(address)': FunctionFragment;
    'burnSynthsToTarget()': FunctionFragment;
    'settle(bytes32)': FunctionFragment;
    'selfDestruct()': FunctionFragment;
    'integrationProxy()': FunctionFragment;
    'setTokenState(address)': FunctionFragment;
    'collateralisationRatio(address)': FunctionFragment;
    'SELFDESTRUCT_DELAY()': FunctionFragment;
    'collateral(address)': FunctionFragment;
    'transfer(address,uint256)': FunctionFragment;
    'getResolverAddressesRequired()': FunctionFragment;
    'emitExchangeReclaim(address,bytes32,uint256)': FunctionFragment;
    'issueMaxSynths()': FunctionFragment;
    'selfDestructInitiated()': FunctionFragment;
    'setMessageSender(address)': FunctionFragment;
    'initiateSelfDestruct()': FunctionFragment;
    'burnSynthsOnBehalf(address,uint256)': FunctionFragment;
    'selfDestructBeneficiary()': FunctionFragment;
    'resolverAddressesRequired(uint256)': FunctionFragment;
    'exchangeOnBehalf(address,bytes32,uint256,bytes32)': FunctionFragment;
    'debtBalanceOf(address,bytes32)': FunctionFragment;
    'totalIssuedSynthsExcludeEtherCollateral(bytes32)': FunctionFragment;
    'messageSender()': FunctionFragment;
    'availableSynthCount()': FunctionFragment;
    'allowance(address,address)': FunctionFragment;
    'MAX_ADDRESSES_FROM_RESOLVER()': FunctionFragment;
    'issueSynthsOnBehalf(address,uint256)': FunctionFragment;
    'tokenState()': FunctionFragment;
    'proxy()': FunctionFragment;
    'exchange(bytes32,uint256,bytes32)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'resolver'
      | 'maxIssuableSynths'
      | 'name'
      | 'approve'
      | 'removeSynth'
      | 'remainingIssuableSynths'
      | 'mint'
      | 'setIntegrationProxy'
      | 'nominateNewOwner'
      | 'synthsByAddress'
      | 'initiationTime'
      | 'totalSupply'
      | 'isWaitingPeriod'
      | 'setSelfDestructBeneficiary'
      | 'transferFrom'
      | 'burnSynths'
      | 'burnSynthsToTargetOnBehalf'
      | 'decimals'
      | 'issueMaxSynthsOnBehalf'
      | 'synths'
      | 'terminateSelfDestruct'
      | 'setResolverAndSyncCache'
      | 'nominatedOwner'
      | 'debtBalanceOfAndTotalDebt'
      | 'isResolverCached'
      | 'transferableSynthetix'
      | 'emitSynthExchange'
      | 'emitExchangeRebate'
      | 'balanceOf'
      | 'availableCurrencyKeys'
      | 'acceptOwnership'
      | 'availableSynths'
      | 'totalIssuedSynths'
      | 'addSynth'
      | 'issueSynths'
      | 'owner'
      | 'symbol'
      | 'setProxy'
      | 'burnSynthsToTarget'
      | 'settle'
      | 'selfDestruct'
      | 'integrationProxy'
      | 'setTokenState'
      | 'collateralisationRatio'
      | 'SELFDESTRUCT_DELAY'
      | 'collateral'
      | 'transfer'
      | 'getResolverAddressesRequired'
      | 'emitExchangeReclaim'
      | 'issueMaxSynths'
      | 'selfDestructInitiated'
      | 'setMessageSender'
      | 'initiateSelfDestruct'
      | 'burnSynthsOnBehalf'
      | 'selfDestructBeneficiary'
      | 'resolverAddressesRequired'
      | 'exchangeOnBehalf'
      | 'debtBalanceOf'
      | 'totalIssuedSynthsExcludeEtherCollateral'
      | 'messageSender'
      | 'availableSynthCount'
      | 'allowance'
      | 'MAX_ADDRESSES_FROM_RESOLVER'
      | 'issueSynthsOnBehalf'
      | 'tokenState'
      | 'proxy'
      | 'exchange',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'resolver', values?: undefined): string;
  encodeFunctionData(functionFragment: 'maxIssuableSynths', values: [string]): string;
  encodeFunctionData(functionFragment: 'name', values?: undefined): string;
  encodeFunctionData(functionFragment: 'approve', values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'removeSynth', values: [BytesLike]): string;
  encodeFunctionData(functionFragment: 'remainingIssuableSynths', values: [string]): string;
  encodeFunctionData(functionFragment: 'mint', values?: undefined): string;
  encodeFunctionData(functionFragment: 'setIntegrationProxy', values: [string]): string;
  encodeFunctionData(functionFragment: 'nominateNewOwner', values: [string]): string;
  encodeFunctionData(functionFragment: 'synthsByAddress', values: [string]): string;
  encodeFunctionData(functionFragment: 'initiationTime', values?: undefined): string;
  encodeFunctionData(functionFragment: 'totalSupply', values?: undefined): string;
  encodeFunctionData(functionFragment: 'isWaitingPeriod', values: [BytesLike]): string;
  encodeFunctionData(functionFragment: 'setSelfDestructBeneficiary', values: [string]): string;
  encodeFunctionData(functionFragment: 'transferFrom', values: [string, string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'burnSynths', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'burnSynthsToTargetOnBehalf', values: [string]): string;
  encodeFunctionData(functionFragment: 'decimals', values?: undefined): string;
  encodeFunctionData(functionFragment: 'issueMaxSynthsOnBehalf', values: [string]): string;
  encodeFunctionData(functionFragment: 'synths', values: [BytesLike]): string;
  encodeFunctionData(functionFragment: 'terminateSelfDestruct', values?: undefined): string;
  encodeFunctionData(functionFragment: 'setResolverAndSyncCache', values: [string]): string;
  encodeFunctionData(functionFragment: 'nominatedOwner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'debtBalanceOfAndTotalDebt', values: [string, BytesLike]): string;
  encodeFunctionData(functionFragment: 'isResolverCached', values: [string]): string;
  encodeFunctionData(functionFragment: 'transferableSynthetix', values: [string]): string;
  encodeFunctionData(
    functionFragment: 'emitSynthExchange',
    values: [string, BytesLike, BigNumberish, BytesLike, BigNumberish, string],
  ): string;
  encodeFunctionData(functionFragment: 'emitExchangeRebate', values: [string, BytesLike, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'balanceOf', values: [string]): string;
  encodeFunctionData(functionFragment: 'availableCurrencyKeys', values?: undefined): string;
  encodeFunctionData(functionFragment: 'acceptOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'availableSynths', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'totalIssuedSynths', values: [BytesLike]): string;
  encodeFunctionData(functionFragment: 'addSynth', values: [string]): string;
  encodeFunctionData(functionFragment: 'issueSynths', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'symbol', values?: undefined): string;
  encodeFunctionData(functionFragment: 'setProxy', values: [string]): string;
  encodeFunctionData(functionFragment: 'burnSynthsToTarget', values?: undefined): string;
  encodeFunctionData(functionFragment: 'settle', values: [BytesLike]): string;
  encodeFunctionData(functionFragment: 'selfDestruct', values?: undefined): string;
  encodeFunctionData(functionFragment: 'integrationProxy', values?: undefined): string;
  encodeFunctionData(functionFragment: 'setTokenState', values: [string]): string;
  encodeFunctionData(functionFragment: 'collateralisationRatio', values: [string]): string;
  encodeFunctionData(functionFragment: 'SELFDESTRUCT_DELAY', values?: undefined): string;
  encodeFunctionData(functionFragment: 'collateral', values: [string]): string;
  encodeFunctionData(functionFragment: 'transfer', values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'getResolverAddressesRequired', values?: undefined): string;
  encodeFunctionData(functionFragment: 'emitExchangeReclaim', values: [string, BytesLike, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'issueMaxSynths', values?: undefined): string;
  encodeFunctionData(functionFragment: 'selfDestructInitiated', values?: undefined): string;
  encodeFunctionData(functionFragment: 'setMessageSender', values: [string]): string;
  encodeFunctionData(functionFragment: 'initiateSelfDestruct', values?: undefined): string;
  encodeFunctionData(functionFragment: 'burnSynthsOnBehalf', values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'selfDestructBeneficiary', values?: undefined): string;
  encodeFunctionData(functionFragment: 'resolverAddressesRequired', values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: 'exchangeOnBehalf',
    values: [string, BytesLike, BigNumberish, BytesLike],
  ): string;
  encodeFunctionData(functionFragment: 'debtBalanceOf', values: [string, BytesLike]): string;
  encodeFunctionData(functionFragment: 'totalIssuedSynthsExcludeEtherCollateral', values: [BytesLike]): string;
  encodeFunctionData(functionFragment: 'messageSender', values?: undefined): string;
  encodeFunctionData(functionFragment: 'availableSynthCount', values?: undefined): string;
  encodeFunctionData(functionFragment: 'allowance', values: [string, string]): string;
  encodeFunctionData(functionFragment: 'MAX_ADDRESSES_FROM_RESOLVER', values?: undefined): string;
  encodeFunctionData(functionFragment: 'issueSynthsOnBehalf', values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'tokenState', values?: undefined): string;
  encodeFunctionData(functionFragment: 'proxy', values?: undefined): string;
  encodeFunctionData(functionFragment: 'exchange', values: [BytesLike, BigNumberish, BytesLike]): string;

  decodeFunctionResult(functionFragment: 'resolver', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'maxIssuableSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'name', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'approve', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'removeSynth', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'remainingIssuableSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'mint', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setIntegrationProxy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nominateNewOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'synthsByAddress', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initiationTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalSupply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isWaitingPeriod', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setSelfDestructBeneficiary', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferFrom', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burnSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burnSynthsToTargetOnBehalf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'decimals', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'issueMaxSynthsOnBehalf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'synths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'terminateSelfDestruct', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setResolverAndSyncCache', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nominatedOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'debtBalanceOfAndTotalDebt', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isResolverCached', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferableSynthetix', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'emitSynthExchange', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'emitExchangeRebate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'availableCurrencyKeys', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'acceptOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'availableSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalIssuedSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addSynth', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'issueSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'symbol', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setProxy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burnSynthsToTarget', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'settle', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'selfDestruct', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'integrationProxy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setTokenState', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'collateralisationRatio', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'SELFDESTRUCT_DELAY', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'collateral', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transfer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getResolverAddressesRequired', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'emitExchangeReclaim', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'issueMaxSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'selfDestructInitiated', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMessageSender', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initiateSelfDestruct', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burnSynthsOnBehalf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'selfDestructBeneficiary', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'resolverAddressesRequired', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exchangeOnBehalf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'debtBalanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalIssuedSynthsExcludeEtherCollateral', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'messageSender', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'availableSynthCount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allowance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'MAX_ADDRESSES_FROM_RESOLVER', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'issueSynthsOnBehalf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tokenState', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'proxy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exchange', data: BytesLike): Result;

  events: {
    'SynthExchange(address,bytes32,uint256,bytes32,uint256,address)': EventFragment;
    'ExchangeReclaim(address,bytes32,uint256)': EventFragment;
    'ExchangeRebate(address,bytes32,uint256)': EventFragment;
    'Transfer(address,address,uint256)': EventFragment;
    'Approval(address,address,uint256)': EventFragment;
    'TokenStateUpdated(address)': EventFragment;
    'ProxyUpdated(address)': EventFragment;
    'SelfDestructTerminated()': EventFragment;
    'SelfDestructed(address)': EventFragment;
    'SelfDestructInitiated(uint256)': EventFragment;
    'SelfDestructBeneficiaryUpdated(address)': EventFragment;
    'OwnerNominated(address)': EventFragment;
    'OwnerChanged(address,address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'SynthExchange'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ExchangeReclaim'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ExchangeRebate'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Transfer'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Approval'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TokenStateUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ProxyUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SelfDestructTerminated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SelfDestructed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SelfDestructInitiated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SelfDestructBeneficiaryUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnerNominated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnerChanged'): EventFragment;
}

export interface SynthExchangeEventObject {
  account: string;
  fromCurrencyKey: string;
  fromAmount: BigNumber;
  toCurrencyKey: string;
  toAmount: BigNumber;
  toAddress: string;
}
export type SynthExchangeEvent = TypedEvent<
  [string, string, BigNumber, string, BigNumber, string],
  SynthExchangeEventObject
>;

export type SynthExchangeEventFilter = TypedEventFilter<SynthExchangeEvent>;

export interface ExchangeReclaimEventObject {
  account: string;
  currencyKey: string;
  amount: BigNumber;
}
export type ExchangeReclaimEvent = TypedEvent<[string, string, BigNumber], ExchangeReclaimEventObject>;

export type ExchangeReclaimEventFilter = TypedEventFilter<ExchangeReclaimEvent>;

export interface ExchangeRebateEventObject {
  account: string;
  currencyKey: string;
  amount: BigNumber;
}
export type ExchangeRebateEvent = TypedEvent<[string, string, BigNumber], ExchangeRebateEventObject>;

export type ExchangeRebateEventFilter = TypedEventFilter<ExchangeRebateEvent>;

export interface TransferEventObject {
  from: string;
  to: string;
  value: BigNumber;
}
export type TransferEvent = TypedEvent<[string, string, BigNumber], TransferEventObject>;

export type TransferEventFilter = TypedEventFilter<TransferEvent>;

export interface ApprovalEventObject {
  owner: string;
  spender: string;
  value: BigNumber;
}
export type ApprovalEvent = TypedEvent<[string, string, BigNumber], ApprovalEventObject>;

export type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;

export interface TokenStateUpdatedEventObject {
  newTokenState: string;
}
export type TokenStateUpdatedEvent = TypedEvent<[string], TokenStateUpdatedEventObject>;

export type TokenStateUpdatedEventFilter = TypedEventFilter<TokenStateUpdatedEvent>;

export interface ProxyUpdatedEventObject {
  proxyAddress: string;
}
export type ProxyUpdatedEvent = TypedEvent<[string], ProxyUpdatedEventObject>;

export type ProxyUpdatedEventFilter = TypedEventFilter<ProxyUpdatedEvent>;

export interface SelfDestructTerminatedEventObject {}
export type SelfDestructTerminatedEvent = TypedEvent<[], SelfDestructTerminatedEventObject>;

export type SelfDestructTerminatedEventFilter = TypedEventFilter<SelfDestructTerminatedEvent>;

export interface SelfDestructedEventObject {
  beneficiary: string;
}
export type SelfDestructedEvent = TypedEvent<[string], SelfDestructedEventObject>;

export type SelfDestructedEventFilter = TypedEventFilter<SelfDestructedEvent>;

export interface SelfDestructInitiatedEventObject {
  selfDestructDelay: BigNumber;
}
export type SelfDestructInitiatedEvent = TypedEvent<[BigNumber], SelfDestructInitiatedEventObject>;

export type SelfDestructInitiatedEventFilter = TypedEventFilter<SelfDestructInitiatedEvent>;

export interface SelfDestructBeneficiaryUpdatedEventObject {
  newBeneficiary: string;
}
export type SelfDestructBeneficiaryUpdatedEvent = TypedEvent<[string], SelfDestructBeneficiaryUpdatedEventObject>;

export type SelfDestructBeneficiaryUpdatedEventFilter = TypedEventFilter<SelfDestructBeneficiaryUpdatedEvent>;

export interface OwnerNominatedEventObject {
  newOwner: string;
}
export type OwnerNominatedEvent = TypedEvent<[string], OwnerNominatedEventObject>;

export type OwnerNominatedEventFilter = TypedEventFilter<OwnerNominatedEvent>;

export interface OwnerChangedEventObject {
  oldOwner: string;
  newOwner: string;
}
export type OwnerChangedEvent = TypedEvent<[string, string], OwnerChangedEventObject>;

export type OwnerChangedEventFilter = TypedEventFilter<OwnerChangedEvent>;

export interface SynthetixNetworkToken extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: SynthetixNetworkTokenInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    resolver(overrides?: CallOverrides): Promise<[string]>;

    maxIssuableSynths(_issuer: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    name(overrides?: CallOverrides): Promise<[string]>;

    approve(
      spender: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    removeSynth(
      currencyKey: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    remainingIssuableSynths(
      _issuer: string,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        maxIssuable: BigNumber;
        alreadyIssued: BigNumber;
        totalSystemDebt: BigNumber;
      }
    >;

    mint(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    setIntegrationProxy(
      _integrationProxy: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    nominateNewOwner(
      _owner: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    synthsByAddress(arg0: string, overrides?: CallOverrides): Promise<[string]>;

    initiationTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    isWaitingPeriod(currencyKey: BytesLike, overrides?: CallOverrides): Promise<[boolean]>;

    setSelfDestructBeneficiary(
      _beneficiary: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    transferFrom(
      from: string,
      to: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    burnSynths(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    burnSynthsToTargetOnBehalf(
      burnForAddress: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    decimals(overrides?: CallOverrides): Promise<[number]>;

    issueMaxSynthsOnBehalf(
      issueForAddress: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    synths(arg0: BytesLike, overrides?: CallOverrides): Promise<[string]>;

    terminateSelfDestruct(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    setResolverAndSyncCache(
      _resolver: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    nominatedOwner(overrides?: CallOverrides): Promise<[string]>;

    debtBalanceOfAndTotalDebt(
      _issuer: string,
      currencyKey: BytesLike,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        debtBalance: BigNumber;
        totalSystemValue: BigNumber;
      }
    >;

    isResolverCached(_resolver: string, overrides?: CallOverrides): Promise<[boolean]>;

    transferableSynthetix(account: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    emitSynthExchange(
      account: string,
      fromCurrencyKey: BytesLike,
      fromAmount: BigNumberish,
      toCurrencyKey: BytesLike,
      toAmount: BigNumberish,
      toAddress: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    emitExchangeRebate(
      account: string,
      currencyKey: BytesLike,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    balanceOf(account: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    availableCurrencyKeys(overrides?: CallOverrides): Promise<[string[]]>;

    acceptOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    availableSynths(arg0: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    totalIssuedSynths(currencyKey: BytesLike, overrides?: CallOverrides): Promise<[BigNumber]>;

    addSynth(synth: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    issueSynths(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    symbol(overrides?: CallOverrides): Promise<[string]>;

    setProxy(_proxy: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    burnSynthsToTarget(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    settle(
      currencyKey: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    selfDestruct(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    integrationProxy(overrides?: CallOverrides): Promise<[string]>;

    setTokenState(
      _tokenState: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    collateralisationRatio(_issuer: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    SELFDESTRUCT_DELAY(overrides?: CallOverrides): Promise<[BigNumber]>;

    collateral(account: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    transfer(
      to: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    getResolverAddressesRequired(overrides?: CallOverrides): Promise<[string[]] & { addressesRequired: string[] }>;

    emitExchangeReclaim(
      account: string,
      currencyKey: BytesLike,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    issueMaxSynths(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    selfDestructInitiated(overrides?: CallOverrides): Promise<[boolean]>;

    setMessageSender(
      sender: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    initiateSelfDestruct(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    burnSynthsOnBehalf(
      burnForAddress: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    selfDestructBeneficiary(overrides?: CallOverrides): Promise<[string]>;

    resolverAddressesRequired(arg0: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    exchangeOnBehalf(
      exchangeForAddress: string,
      sourceCurrencyKey: BytesLike,
      sourceAmount: BigNumberish,
      destinationCurrencyKey: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    debtBalanceOf(_issuer: string, currencyKey: BytesLike, overrides?: CallOverrides): Promise<[BigNumber]>;

    totalIssuedSynthsExcludeEtherCollateral(currencyKey: BytesLike, overrides?: CallOverrides): Promise<[BigNumber]>;

    messageSender(overrides?: CallOverrides): Promise<[string]>;

    availableSynthCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    allowance(owner: string, spender: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    MAX_ADDRESSES_FROM_RESOLVER(overrides?: CallOverrides): Promise<[BigNumber]>;

    issueSynthsOnBehalf(
      issueForAddress: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    tokenState(overrides?: CallOverrides): Promise<[string]>;

    proxy(overrides?: CallOverrides): Promise<[string]>;

    exchange(
      sourceCurrencyKey: BytesLike,
      sourceAmount: BigNumberish,
      destinationCurrencyKey: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;
  };

  resolver(overrides?: CallOverrides): Promise<string>;

  maxIssuableSynths(_issuer: string, overrides?: CallOverrides): Promise<BigNumber>;

  name(overrides?: CallOverrides): Promise<string>;

  approve(
    spender: string,
    value: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  removeSynth(
    currencyKey: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  remainingIssuableSynths(
    _issuer: string,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      maxIssuable: BigNumber;
      alreadyIssued: BigNumber;
      totalSystemDebt: BigNumber;
    }
  >;

  mint(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  setIntegrationProxy(
    _integrationProxy: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  nominateNewOwner(
    _owner: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  synthsByAddress(arg0: string, overrides?: CallOverrides): Promise<string>;

  initiationTime(overrides?: CallOverrides): Promise<BigNumber>;

  totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  isWaitingPeriod(currencyKey: BytesLike, overrides?: CallOverrides): Promise<boolean>;

  setSelfDestructBeneficiary(
    _beneficiary: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  transferFrom(
    from: string,
    to: string,
    value: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  burnSynths(
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  burnSynthsToTargetOnBehalf(
    burnForAddress: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  decimals(overrides?: CallOverrides): Promise<number>;

  issueMaxSynthsOnBehalf(
    issueForAddress: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  synths(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;

  terminateSelfDestruct(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  setResolverAndSyncCache(
    _resolver: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  nominatedOwner(overrides?: CallOverrides): Promise<string>;

  debtBalanceOfAndTotalDebt(
    _issuer: string,
    currencyKey: BytesLike,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber] & {
      debtBalance: BigNumber;
      totalSystemValue: BigNumber;
    }
  >;

  isResolverCached(_resolver: string, overrides?: CallOverrides): Promise<boolean>;

  transferableSynthetix(account: string, overrides?: CallOverrides): Promise<BigNumber>;

  emitSynthExchange(
    account: string,
    fromCurrencyKey: BytesLike,
    fromAmount: BigNumberish,
    toCurrencyKey: BytesLike,
    toAmount: BigNumberish,
    toAddress: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  emitExchangeRebate(
    account: string,
    currencyKey: BytesLike,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;

  availableCurrencyKeys(overrides?: CallOverrides): Promise<string[]>;

  acceptOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  availableSynths(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

  totalIssuedSynths(currencyKey: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

  addSynth(synth: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  issueSynths(
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  symbol(overrides?: CallOverrides): Promise<string>;

  setProxy(_proxy: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  burnSynthsToTarget(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  settle(
    currencyKey: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  selfDestruct(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  integrationProxy(overrides?: CallOverrides): Promise<string>;

  setTokenState(
    _tokenState: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  collateralisationRatio(_issuer: string, overrides?: CallOverrides): Promise<BigNumber>;

  SELFDESTRUCT_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

  collateral(account: string, overrides?: CallOverrides): Promise<BigNumber>;

  transfer(
    to: string,
    value: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  getResolverAddressesRequired(overrides?: CallOverrides): Promise<string[]>;

  emitExchangeReclaim(
    account: string,
    currencyKey: BytesLike,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  issueMaxSynths(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  selfDestructInitiated(overrides?: CallOverrides): Promise<boolean>;

  setMessageSender(
    sender: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  initiateSelfDestruct(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  burnSynthsOnBehalf(
    burnForAddress: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  selfDestructBeneficiary(overrides?: CallOverrides): Promise<string>;

  resolverAddressesRequired(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

  exchangeOnBehalf(
    exchangeForAddress: string,
    sourceCurrencyKey: BytesLike,
    sourceAmount: BigNumberish,
    destinationCurrencyKey: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  debtBalanceOf(_issuer: string, currencyKey: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

  totalIssuedSynthsExcludeEtherCollateral(currencyKey: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

  messageSender(overrides?: CallOverrides): Promise<string>;

  availableSynthCount(overrides?: CallOverrides): Promise<BigNumber>;

  allowance(owner: string, spender: string, overrides?: CallOverrides): Promise<BigNumber>;

  MAX_ADDRESSES_FROM_RESOLVER(overrides?: CallOverrides): Promise<BigNumber>;

  issueSynthsOnBehalf(
    issueForAddress: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  tokenState(overrides?: CallOverrides): Promise<string>;

  proxy(overrides?: CallOverrides): Promise<string>;

  exchange(
    sourceCurrencyKey: BytesLike,
    sourceAmount: BigNumberish,
    destinationCurrencyKey: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    resolver(overrides?: CallOverrides): Promise<string>;

    maxIssuableSynths(_issuer: string, overrides?: CallOverrides): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<string>;

    approve(spender: string, value: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

    removeSynth(currencyKey: BytesLike, overrides?: CallOverrides): Promise<void>;

    remainingIssuableSynths(
      _issuer: string,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        maxIssuable: BigNumber;
        alreadyIssued: BigNumber;
        totalSystemDebt: BigNumber;
      }
    >;

    mint(overrides?: CallOverrides): Promise<boolean>;

    setIntegrationProxy(_integrationProxy: string, overrides?: CallOverrides): Promise<void>;

    nominateNewOwner(_owner: string, overrides?: CallOverrides): Promise<void>;

    synthsByAddress(arg0: string, overrides?: CallOverrides): Promise<string>;

    initiationTime(overrides?: CallOverrides): Promise<BigNumber>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    isWaitingPeriod(currencyKey: BytesLike, overrides?: CallOverrides): Promise<boolean>;

    setSelfDestructBeneficiary(_beneficiary: string, overrides?: CallOverrides): Promise<void>;

    transferFrom(from: string, to: string, value: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

    burnSynths(amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

    burnSynthsToTargetOnBehalf(burnForAddress: string, overrides?: CallOverrides): Promise<void>;

    decimals(overrides?: CallOverrides): Promise<number>;

    issueMaxSynthsOnBehalf(issueForAddress: string, overrides?: CallOverrides): Promise<void>;

    synths(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;

    terminateSelfDestruct(overrides?: CallOverrides): Promise<void>;

    setResolverAndSyncCache(_resolver: string, overrides?: CallOverrides): Promise<void>;

    nominatedOwner(overrides?: CallOverrides): Promise<string>;

    debtBalanceOfAndTotalDebt(
      _issuer: string,
      currencyKey: BytesLike,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        debtBalance: BigNumber;
        totalSystemValue: BigNumber;
      }
    >;

    isResolverCached(_resolver: string, overrides?: CallOverrides): Promise<boolean>;

    transferableSynthetix(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    emitSynthExchange(
      account: string,
      fromCurrencyKey: BytesLike,
      fromAmount: BigNumberish,
      toCurrencyKey: BytesLike,
      toAmount: BigNumberish,
      toAddress: string,
      overrides?: CallOverrides,
    ): Promise<void>;

    emitExchangeRebate(
      account: string,
      currencyKey: BytesLike,
      amount: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<void>;

    balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    availableCurrencyKeys(overrides?: CallOverrides): Promise<string[]>;

    acceptOwnership(overrides?: CallOverrides): Promise<void>;

    availableSynths(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

    totalIssuedSynths(currencyKey: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    addSynth(synth: string, overrides?: CallOverrides): Promise<void>;

    issueSynths(amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

    owner(overrides?: CallOverrides): Promise<string>;

    symbol(overrides?: CallOverrides): Promise<string>;

    setProxy(_proxy: string, overrides?: CallOverrides): Promise<void>;

    burnSynthsToTarget(overrides?: CallOverrides): Promise<void>;

    settle(
      currencyKey: BytesLike,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        reclaimed: BigNumber;
        refunded: BigNumber;
        numEntriesSettled: BigNumber;
      }
    >;

    selfDestruct(overrides?: CallOverrides): Promise<void>;

    integrationProxy(overrides?: CallOverrides): Promise<string>;

    setTokenState(_tokenState: string, overrides?: CallOverrides): Promise<void>;

    collateralisationRatio(_issuer: string, overrides?: CallOverrides): Promise<BigNumber>;

    SELFDESTRUCT_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

    collateral(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    transfer(to: string, value: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

    getResolverAddressesRequired(overrides?: CallOverrides): Promise<string[]>;

    emitExchangeReclaim(
      account: string,
      currencyKey: BytesLike,
      amount: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<void>;

    issueMaxSynths(overrides?: CallOverrides): Promise<void>;

    selfDestructInitiated(overrides?: CallOverrides): Promise<boolean>;

    setMessageSender(sender: string, overrides?: CallOverrides): Promise<void>;

    initiateSelfDestruct(overrides?: CallOverrides): Promise<void>;

    burnSynthsOnBehalf(burnForAddress: string, amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

    selfDestructBeneficiary(overrides?: CallOverrides): Promise<string>;

    resolverAddressesRequired(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

    exchangeOnBehalf(
      exchangeForAddress: string,
      sourceCurrencyKey: BytesLike,
      sourceAmount: BigNumberish,
      destinationCurrencyKey: BytesLike,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    debtBalanceOf(_issuer: string, currencyKey: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    totalIssuedSynthsExcludeEtherCollateral(currencyKey: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    messageSender(overrides?: CallOverrides): Promise<string>;

    availableSynthCount(overrides?: CallOverrides): Promise<BigNumber>;

    allowance(owner: string, spender: string, overrides?: CallOverrides): Promise<BigNumber>;

    MAX_ADDRESSES_FROM_RESOLVER(overrides?: CallOverrides): Promise<BigNumber>;

    issueSynthsOnBehalf(issueForAddress: string, amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

    tokenState(overrides?: CallOverrides): Promise<string>;

    proxy(overrides?: CallOverrides): Promise<string>;

    exchange(
      sourceCurrencyKey: BytesLike,
      sourceAmount: BigNumberish,
      destinationCurrencyKey: BytesLike,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;
  };

  filters: {
    'SynthExchange(address,bytes32,uint256,bytes32,uint256,address)'(
      account?: string | null,
      fromCurrencyKey?: null,
      fromAmount?: null,
      toCurrencyKey?: null,
      toAmount?: null,
      toAddress?: null,
    ): SynthExchangeEventFilter;
    SynthExchange(
      account?: string | null,
      fromCurrencyKey?: null,
      fromAmount?: null,
      toCurrencyKey?: null,
      toAmount?: null,
      toAddress?: null,
    ): SynthExchangeEventFilter;

    'ExchangeReclaim(address,bytes32,uint256)'(
      account?: string | null,
      currencyKey?: null,
      amount?: null,
    ): ExchangeReclaimEventFilter;
    ExchangeReclaim(account?: string | null, currencyKey?: null, amount?: null): ExchangeReclaimEventFilter;

    'ExchangeRebate(address,bytes32,uint256)'(
      account?: string | null,
      currencyKey?: null,
      amount?: null,
    ): ExchangeRebateEventFilter;
    ExchangeRebate(account?: string | null, currencyKey?: null, amount?: null): ExchangeRebateEventFilter;

    'Transfer(address,address,uint256)'(from?: string | null, to?: string | null, value?: null): TransferEventFilter;
    Transfer(from?: string | null, to?: string | null, value?: null): TransferEventFilter;

    'Approval(address,address,uint256)'(
      owner?: string | null,
      spender?: string | null,
      value?: null,
    ): ApprovalEventFilter;
    Approval(owner?: string | null, spender?: string | null, value?: null): ApprovalEventFilter;

    'TokenStateUpdated(address)'(newTokenState?: null): TokenStateUpdatedEventFilter;
    TokenStateUpdated(newTokenState?: null): TokenStateUpdatedEventFilter;

    'ProxyUpdated(address)'(proxyAddress?: null): ProxyUpdatedEventFilter;
    ProxyUpdated(proxyAddress?: null): ProxyUpdatedEventFilter;

    'SelfDestructTerminated()'(): SelfDestructTerminatedEventFilter;
    SelfDestructTerminated(): SelfDestructTerminatedEventFilter;

    'SelfDestructed(address)'(beneficiary?: null): SelfDestructedEventFilter;
    SelfDestructed(beneficiary?: null): SelfDestructedEventFilter;

    'SelfDestructInitiated(uint256)'(selfDestructDelay?: null): SelfDestructInitiatedEventFilter;
    SelfDestructInitiated(selfDestructDelay?: null): SelfDestructInitiatedEventFilter;

    'SelfDestructBeneficiaryUpdated(address)'(newBeneficiary?: null): SelfDestructBeneficiaryUpdatedEventFilter;
    SelfDestructBeneficiaryUpdated(newBeneficiary?: null): SelfDestructBeneficiaryUpdatedEventFilter;

    'OwnerNominated(address)'(newOwner?: null): OwnerNominatedEventFilter;
    OwnerNominated(newOwner?: null): OwnerNominatedEventFilter;

    'OwnerChanged(address,address)'(oldOwner?: null, newOwner?: null): OwnerChangedEventFilter;
    OwnerChanged(oldOwner?: null, newOwner?: null): OwnerChangedEventFilter;
  };

  estimateGas: {
    resolver(overrides?: CallOverrides): Promise<BigNumber>;

    maxIssuableSynths(_issuer: string, overrides?: CallOverrides): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    approve(
      spender: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    removeSynth(
      currencyKey: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    remainingIssuableSynths(_issuer: string, overrides?: CallOverrides): Promise<BigNumber>;

    mint(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    setIntegrationProxy(
      _integrationProxy: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    nominateNewOwner(_owner: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    synthsByAddress(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    initiationTime(overrides?: CallOverrides): Promise<BigNumber>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    isWaitingPeriod(currencyKey: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    setSelfDestructBeneficiary(
      _beneficiary: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    transferFrom(
      from: string,
      to: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    burnSynths(amount: BigNumberish, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    burnSynthsToTargetOnBehalf(
      burnForAddress: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    decimals(overrides?: CallOverrides): Promise<BigNumber>;

    issueMaxSynthsOnBehalf(
      issueForAddress: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    synths(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    terminateSelfDestruct(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    setResolverAndSyncCache(
      _resolver: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    nominatedOwner(overrides?: CallOverrides): Promise<BigNumber>;

    debtBalanceOfAndTotalDebt(_issuer: string, currencyKey: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    isResolverCached(_resolver: string, overrides?: CallOverrides): Promise<BigNumber>;

    transferableSynthetix(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    emitSynthExchange(
      account: string,
      fromCurrencyKey: BytesLike,
      fromAmount: BigNumberish,
      toCurrencyKey: BytesLike,
      toAmount: BigNumberish,
      toAddress: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    emitExchangeRebate(
      account: string,
      currencyKey: BytesLike,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    availableCurrencyKeys(overrides?: CallOverrides): Promise<BigNumber>;

    acceptOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    availableSynths(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    totalIssuedSynths(currencyKey: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    addSynth(synth: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    issueSynths(amount: BigNumberish, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    symbol(overrides?: CallOverrides): Promise<BigNumber>;

    setProxy(_proxy: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    burnSynthsToTarget(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    settle(currencyKey: BytesLike, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    selfDestruct(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    integrationProxy(overrides?: CallOverrides): Promise<BigNumber>;

    setTokenState(_tokenState: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    collateralisationRatio(_issuer: string, overrides?: CallOverrides): Promise<BigNumber>;

    SELFDESTRUCT_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

    collateral(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    transfer(
      to: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    getResolverAddressesRequired(overrides?: CallOverrides): Promise<BigNumber>;

    emitExchangeReclaim(
      account: string,
      currencyKey: BytesLike,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    issueMaxSynths(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    selfDestructInitiated(overrides?: CallOverrides): Promise<BigNumber>;

    setMessageSender(sender: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    initiateSelfDestruct(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    burnSynthsOnBehalf(
      burnForAddress: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    selfDestructBeneficiary(overrides?: CallOverrides): Promise<BigNumber>;

    resolverAddressesRequired(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    exchangeOnBehalf(
      exchangeForAddress: string,
      sourceCurrencyKey: BytesLike,
      sourceAmount: BigNumberish,
      destinationCurrencyKey: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    debtBalanceOf(_issuer: string, currencyKey: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    totalIssuedSynthsExcludeEtherCollateral(currencyKey: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    messageSender(overrides?: CallOverrides): Promise<BigNumber>;

    availableSynthCount(overrides?: CallOverrides): Promise<BigNumber>;

    allowance(owner: string, spender: string, overrides?: CallOverrides): Promise<BigNumber>;

    MAX_ADDRESSES_FROM_RESOLVER(overrides?: CallOverrides): Promise<BigNumber>;

    issueSynthsOnBehalf(
      issueForAddress: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    tokenState(overrides?: CallOverrides): Promise<BigNumber>;

    proxy(overrides?: CallOverrides): Promise<BigNumber>;

    exchange(
      sourceCurrencyKey: BytesLike,
      sourceAmount: BigNumberish,
      destinationCurrencyKey: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    resolver(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    maxIssuableSynths(_issuer: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    approve(
      spender: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    removeSynth(
      currencyKey: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    remainingIssuableSynths(_issuer: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    mint(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    setIntegrationProxy(
      _integrationProxy: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    nominateNewOwner(
      _owner: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    synthsByAddress(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initiationTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isWaitingPeriod(currencyKey: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setSelfDestructBeneficiary(
      _beneficiary: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    transferFrom(
      from: string,
      to: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    burnSynths(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    burnSynthsToTargetOnBehalf(
      burnForAddress: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    issueMaxSynthsOnBehalf(
      issueForAddress: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    synths(arg0: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    terminateSelfDestruct(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    setResolverAndSyncCache(
      _resolver: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    nominatedOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    debtBalanceOfAndTotalDebt(
      _issuer: string,
      currencyKey: BytesLike,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    isResolverCached(_resolver: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferableSynthetix(account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    emitSynthExchange(
      account: string,
      fromCurrencyKey: BytesLike,
      fromAmount: BigNumberish,
      toCurrencyKey: BytesLike,
      toAmount: BigNumberish,
      toAddress: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    emitExchangeRebate(
      account: string,
      currencyKey: BytesLike,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    balanceOf(account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    availableCurrencyKeys(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    acceptOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    availableSynths(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalIssuedSynths(currencyKey: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    addSynth(synth: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    issueSynths(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setProxy(
      _proxy: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    burnSynthsToTarget(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    settle(
      currencyKey: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    selfDestruct(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    integrationProxy(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setTokenState(
      _tokenState: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    collateralisationRatio(_issuer: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    SELFDESTRUCT_DELAY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    collateral(account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transfer(
      to: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    getResolverAddressesRequired(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    emitExchangeReclaim(
      account: string,
      currencyKey: BytesLike,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    issueMaxSynths(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    selfDestructInitiated(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setMessageSender(
      sender: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    initiateSelfDestruct(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    burnSynthsOnBehalf(
      burnForAddress: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    selfDestructBeneficiary(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    resolverAddressesRequired(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    exchangeOnBehalf(
      exchangeForAddress: string,
      sourceCurrencyKey: BytesLike,
      sourceAmount: BigNumberish,
      destinationCurrencyKey: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    debtBalanceOf(_issuer: string, currencyKey: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalIssuedSynthsExcludeEtherCollateral(
      currencyKey: BytesLike,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    messageSender(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    availableSynthCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    allowance(owner: string, spender: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAX_ADDRESSES_FROM_RESOLVER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    issueSynthsOnBehalf(
      issueForAddress: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    tokenState(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proxy(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    exchange(
      sourceCurrencyKey: BytesLike,
      sourceAmount: BigNumberish,
      destinationCurrencyKey: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;
  };
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export interface SynthetixLoanInterface extends utils.Interface {
  functions: {
    'acceptOwnership()': FunctionFragment;
    'addRewardsContracts(address,bytes32)': FunctionFragment;
    'addSynths(bytes32[],bytes32[])': FunctionFragment;
    'areSynthsAndCurrenciesSet(bytes32[],bytes32[])': FunctionFragment;
    'canOpenLoans()': FunctionFragment;
    'claim(uint256)': FunctionFragment;
    'close(uint256)': FunctionFragment;
    'collateralKey()': FunctionFragment;
    'collateralRatio(uint256)': FunctionFragment;
    'deposit(address,uint256)': FunctionFragment;
    'draw(uint256,uint256)': FunctionFragment;
    'isResolverCached()': FunctionFragment;
    'issueFeeRate()': FunctionFragment;
    'liquidate(address,uint256,uint256)': FunctionFragment;
    'liquidationAmount(uint256)': FunctionFragment;
    'loans(uint256)': FunctionFragment;
    'manager()': FunctionFragment;
    'maxLoan(uint256,bytes32)': FunctionFragment;
    'minCollateral()': FunctionFragment;
    'minCratio()': FunctionFragment;
    'nominateNewOwner(address)': FunctionFragment;
    'nominatedOwner()': FunctionFragment;
    'open(uint256,bytes32)': FunctionFragment;
    'owner()': FunctionFragment;
    'pendingWithdrawals(address)': FunctionFragment;
    'rebuildCache()': FunctionFragment;
    'repay(address,uint256,uint256)': FunctionFragment;
    'resolver()': FunctionFragment;
    'resolverAddressesRequired()': FunctionFragment;
    'setCanOpenLoans(bool)': FunctionFragment;
    'setIssueFeeRate(uint256)': FunctionFragment;
    'setMinCollateral(uint256)': FunctionFragment;
    'shortingRewards(bytes32)': FunctionFragment;
    'synths(uint256)': FunctionFragment;
    'synthsByKey(bytes32)': FunctionFragment;
    'withdraw(uint256,uint256)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'acceptOwnership'
      | 'addRewardsContracts'
      | 'addSynths'
      | 'areSynthsAndCurrenciesSet'
      | 'canOpenLoans'
      | 'claim'
      | 'close'
      | 'collateralKey'
      | 'collateralRatio'
      | 'deposit'
      | 'draw'
      | 'isResolverCached'
      | 'issueFeeRate'
      | 'liquidate'
      | 'liquidationAmount'
      | 'loans'
      | 'manager'
      | 'maxLoan'
      | 'minCollateral'
      | 'minCratio'
      | 'nominateNewOwner'
      | 'nominatedOwner'
      | 'open'
      | 'owner'
      | 'pendingWithdrawals'
      | 'rebuildCache'
      | 'repay'
      | 'resolver'
      | 'resolverAddressesRequired'
      | 'setCanOpenLoans'
      | 'setIssueFeeRate'
      | 'setMinCollateral'
      | 'shortingRewards'
      | 'synths'
      | 'synthsByKey'
      | 'withdraw',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'acceptOwnership', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'addRewardsContracts',
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'addSynths',
    values: [PromiseOrValue<BytesLike>[], PromiseOrValue<BytesLike>[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'areSynthsAndCurrenciesSet',
    values: [PromiseOrValue<BytesLike>[], PromiseOrValue<BytesLike>[]],
  ): string;
  encodeFunctionData(functionFragment: 'canOpenLoans', values?: undefined): string;
  encodeFunctionData(functionFragment: 'claim', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'close', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'collateralKey', values?: undefined): string;
  encodeFunctionData(functionFragment: 'collateralRatio', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'deposit',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'draw',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'isResolverCached', values?: undefined): string;
  encodeFunctionData(functionFragment: 'issueFeeRate', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'liquidate',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'liquidationAmount', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'loans', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'manager', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'maxLoan',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(functionFragment: 'minCollateral', values?: undefined): string;
  encodeFunctionData(functionFragment: 'minCratio', values?: undefined): string;
  encodeFunctionData(functionFragment: 'nominateNewOwner', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'nominatedOwner', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'open',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pendingWithdrawals', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'rebuildCache', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'repay',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'resolver', values?: undefined): string;
  encodeFunctionData(functionFragment: 'resolverAddressesRequired', values?: undefined): string;
  encodeFunctionData(functionFragment: 'setCanOpenLoans', values: [PromiseOrValue<boolean>]): string;
  encodeFunctionData(functionFragment: 'setIssueFeeRate', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setMinCollateral', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'shortingRewards', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(functionFragment: 'synths', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'synthsByKey', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(
    functionFragment: 'withdraw',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;

  decodeFunctionResult(functionFragment: 'acceptOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addRewardsContracts', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addSynths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'areSynthsAndCurrenciesSet', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'canOpenLoans', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claim', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'close', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'collateralKey', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'collateralRatio', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'draw', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isResolverCached', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'issueFeeRate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidationAmount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'loans', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'manager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'maxLoan', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'minCollateral', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'minCratio', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nominateNewOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nominatedOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'open', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pendingWithdrawals', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rebuildCache', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'repay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'resolver', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'resolverAddressesRequired', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setCanOpenLoans', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setIssueFeeRate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMinCollateral', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'shortingRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'synths', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'synthsByKey', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result;

  events: {
    'CacheUpdated(bytes32,address)': EventFragment;
    'CanOpenLoansUpdated(bool)': EventFragment;
    'CollateralDeposited(address,uint256,uint256,uint256)': EventFragment;
    'CollateralWithdrawn(address,uint256,uint256,uint256)': EventFragment;
    'IssueFeeRateUpdated(uint256)': EventFragment;
    'LoanClosed(address,uint256)': EventFragment;
    'LoanClosedByLiquidation(address,uint256,address,uint256,uint256)': EventFragment;
    'LoanClosedByRepayment(address,uint256,uint256,uint256)': EventFragment;
    'LoanCreated(address,uint256,uint256,uint256,bytes32,uint256)': EventFragment;
    'LoanDrawnDown(address,uint256,uint256)': EventFragment;
    'LoanPartiallyLiquidated(address,uint256,address,uint256,uint256)': EventFragment;
    'LoanRepaymentMade(address,address,uint256,uint256,uint256)': EventFragment;
    'MinCollateralUpdated(uint256)': EventFragment;
    'OwnerChanged(address,address)': EventFragment;
    'OwnerNominated(address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'CacheUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CanOpenLoansUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CollateralDeposited'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CollateralWithdrawn'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'IssueFeeRateUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LoanClosed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LoanClosedByLiquidation'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LoanClosedByRepayment'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LoanCreated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LoanDrawnDown'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LoanPartiallyLiquidated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LoanRepaymentMade'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'MinCollateralUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnerChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnerNominated'): EventFragment;
}

export interface CacheUpdatedEventObject {
  name: string;
  destination: string;
}
export type CacheUpdatedEvent = TypedEvent<[string, string], CacheUpdatedEventObject>;

export type CacheUpdatedEventFilter = TypedEventFilter<CacheUpdatedEvent>;

export interface CanOpenLoansUpdatedEventObject {
  canOpenLoans: boolean;
}
export type CanOpenLoansUpdatedEvent = TypedEvent<[boolean], CanOpenLoansUpdatedEventObject>;

export type CanOpenLoansUpdatedEventFilter = TypedEventFilter<CanOpenLoansUpdatedEvent>;

export interface CollateralDepositedEventObject {
  account: string;
  id: BigNumber;
  amountDeposited: BigNumber;
  collateralAfter: BigNumber;
}
export type CollateralDepositedEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber],
  CollateralDepositedEventObject
>;

export type CollateralDepositedEventFilter = TypedEventFilter<CollateralDepositedEvent>;

export interface CollateralWithdrawnEventObject {
  account: string;
  id: BigNumber;
  amountWithdrawn: BigNumber;
  collateralAfter: BigNumber;
}
export type CollateralWithdrawnEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber],
  CollateralWithdrawnEventObject
>;

export type CollateralWithdrawnEventFilter = TypedEventFilter<CollateralWithdrawnEvent>;

export interface IssueFeeRateUpdatedEventObject {
  issueFeeRate: BigNumber;
}
export type IssueFeeRateUpdatedEvent = TypedEvent<[BigNumber], IssueFeeRateUpdatedEventObject>;

export type IssueFeeRateUpdatedEventFilter = TypedEventFilter<IssueFeeRateUpdatedEvent>;

export interface LoanClosedEventObject {
  account: string;
  id: BigNumber;
}
export type LoanClosedEvent = TypedEvent<[string, BigNumber], LoanClosedEventObject>;

export type LoanClosedEventFilter = TypedEventFilter<LoanClosedEvent>;

export interface LoanClosedByLiquidationEventObject {
  account: string;
  id: BigNumber;
  liquidator: string;
  amountLiquidated: BigNumber;
  collateralLiquidated: BigNumber;
}
export type LoanClosedByLiquidationEvent = TypedEvent<
  [string, BigNumber, string, BigNumber, BigNumber],
  LoanClosedByLiquidationEventObject
>;

export type LoanClosedByLiquidationEventFilter = TypedEventFilter<LoanClosedByLiquidationEvent>;

export interface LoanClosedByRepaymentEventObject {
  account: string;
  id: BigNumber;
  amountRepaid: BigNumber;
  collateralAfter: BigNumber;
}
export type LoanClosedByRepaymentEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber],
  LoanClosedByRepaymentEventObject
>;

export type LoanClosedByRepaymentEventFilter = TypedEventFilter<LoanClosedByRepaymentEvent>;

export interface LoanCreatedEventObject {
  account: string;
  id: BigNumber;
  amount: BigNumber;
  collateral: BigNumber;
  currency: string;
  issuanceFee: BigNumber;
}
export type LoanCreatedEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, string, BigNumber],
  LoanCreatedEventObject
>;

export type LoanCreatedEventFilter = TypedEventFilter<LoanCreatedEvent>;

export interface LoanDrawnDownEventObject {
  account: string;
  id: BigNumber;
  amount: BigNumber;
}
export type LoanDrawnDownEvent = TypedEvent<[string, BigNumber, BigNumber], LoanDrawnDownEventObject>;

export type LoanDrawnDownEventFilter = TypedEventFilter<LoanDrawnDownEvent>;

export interface LoanPartiallyLiquidatedEventObject {
  account: string;
  id: BigNumber;
  liquidator: string;
  amountLiquidated: BigNumber;
  collateralLiquidated: BigNumber;
}
export type LoanPartiallyLiquidatedEvent = TypedEvent<
  [string, BigNumber, string, BigNumber, BigNumber],
  LoanPartiallyLiquidatedEventObject
>;

export type LoanPartiallyLiquidatedEventFilter = TypedEventFilter<LoanPartiallyLiquidatedEvent>;

export interface LoanRepaymentMadeEventObject {
  account: string;
  repayer: string;
  id: BigNumber;
  amountRepaid: BigNumber;
  amountAfter: BigNumber;
}
export type LoanRepaymentMadeEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, BigNumber],
  LoanRepaymentMadeEventObject
>;

export type LoanRepaymentMadeEventFilter = TypedEventFilter<LoanRepaymentMadeEvent>;

export interface MinCollateralUpdatedEventObject {
  minCollateral: BigNumber;
}
export type MinCollateralUpdatedEvent = TypedEvent<[BigNumber], MinCollateralUpdatedEventObject>;

export type MinCollateralUpdatedEventFilter = TypedEventFilter<MinCollateralUpdatedEvent>;

export interface OwnerChangedEventObject {
  oldOwner: string;
  newOwner: string;
}
export type OwnerChangedEvent = TypedEvent<[string, string], OwnerChangedEventObject>;

export type OwnerChangedEventFilter = TypedEventFilter<OwnerChangedEvent>;

export interface OwnerNominatedEventObject {
  newOwner: string;
}
export type OwnerNominatedEvent = TypedEvent<[string], OwnerNominatedEventObject>;

export type OwnerNominatedEventFilter = TypedEventFilter<OwnerNominatedEvent>;

export interface SynthetixLoan extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: SynthetixLoanInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    addRewardsContracts(
      rewardsContract: PromiseOrValue<string>,
      synth: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    addSynths(
      _synthNamesInResolver: PromiseOrValue<BytesLike>[],
      _synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    areSynthsAndCurrenciesSet(
      _synthNamesInResolver: PromiseOrValue<BytesLike>[],
      _synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    canOpenLoans(overrides?: CallOverrides): Promise<[boolean]>;

    claim(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    close(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    collateralKey(overrides?: CallOverrides): Promise<[string]>;

    collateralRatio(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { cratio: BigNumber }>;

    deposit(
      borrower: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    draw(
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    isResolverCached(overrides?: CallOverrides): Promise<[boolean]>;

    issueFeeRate(overrides?: CallOverrides): Promise<[BigNumber]>;

    liquidate(
      borrower: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    liquidationAmount(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { liqAmount: BigNumber }>;

    loans(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, string, BigNumber, string, BigNumber, boolean, BigNumber, BigNumber, BigNumber] & {
        id: BigNumber;
        account: string;
        collateral: BigNumber;
        currency: string;
        amount: BigNumber;
        short: boolean;
        accruedInterest: BigNumber;
        interestIndex: BigNumber;
        lastInteraction: BigNumber;
      }
    >;

    manager(overrides?: CallOverrides): Promise<[string]>;

    maxLoan(
      amount: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { max: BigNumber }>;

    minCollateral(overrides?: CallOverrides): Promise<[BigNumber]>;

    minCratio(overrides?: CallOverrides): Promise<[BigNumber]>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    nominatedOwner(overrides?: CallOverrides): Promise<[string]>;

    open(
      amount: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pendingWithdrawals(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    rebuildCache(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    repay(
      borrower: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    resolver(overrides?: CallOverrides): Promise<[string]>;

    resolverAddressesRequired(overrides?: CallOverrides): Promise<[string[]] & { addresses: string[] }>;

    setCanOpenLoans(
      _canOpenLoans: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setIssueFeeRate(
      _issueFeeRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setMinCollateral(
      _minCollateral: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    shortingRewards(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;

    synths(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    synthsByKey(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;

    withdraw(
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;
  };

  acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  addRewardsContracts(
    rewardsContract: PromiseOrValue<string>,
    synth: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  addSynths(
    _synthNamesInResolver: PromiseOrValue<BytesLike>[],
    _synthKeys: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  areSynthsAndCurrenciesSet(
    _synthNamesInResolver: PromiseOrValue<BytesLike>[],
    _synthKeys: PromiseOrValue<BytesLike>[],
    overrides?: CallOverrides,
  ): Promise<boolean>;

  canOpenLoans(overrides?: CallOverrides): Promise<boolean>;

  claim(
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  close(
    id: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  collateralKey(overrides?: CallOverrides): Promise<string>;

  collateralRatio(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  deposit(
    borrower: PromiseOrValue<string>,
    id: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  draw(
    id: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  isResolverCached(overrides?: CallOverrides): Promise<boolean>;

  issueFeeRate(overrides?: CallOverrides): Promise<BigNumber>;

  liquidate(
    borrower: PromiseOrValue<string>,
    id: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  liquidationAmount(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  loans(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, string, BigNumber, string, BigNumber, boolean, BigNumber, BigNumber, BigNumber] & {
      id: BigNumber;
      account: string;
      collateral: BigNumber;
      currency: string;
      amount: BigNumber;
      short: boolean;
      accruedInterest: BigNumber;
      interestIndex: BigNumber;
      lastInteraction: BigNumber;
    }
  >;

  manager(overrides?: CallOverrides): Promise<string>;

  maxLoan(
    amount: PromiseOrValue<BigNumberish>,
    currency: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  minCollateral(overrides?: CallOverrides): Promise<BigNumber>;

  minCratio(overrides?: CallOverrides): Promise<BigNumber>;

  nominateNewOwner(
    _owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  nominatedOwner(overrides?: CallOverrides): Promise<string>;

  open(
    amount: PromiseOrValue<BigNumberish>,
    currency: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  pendingWithdrawals(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  rebuildCache(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  repay(
    borrower: PromiseOrValue<string>,
    id: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  resolver(overrides?: CallOverrides): Promise<string>;

  resolverAddressesRequired(overrides?: CallOverrides): Promise<string[]>;

  setCanOpenLoans(
    _canOpenLoans: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setIssueFeeRate(
    _issueFeeRate: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setMinCollateral(
    _minCollateral: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  shortingRewards(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

  synths(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  synthsByKey(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

  withdraw(
    id: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    acceptOwnership(overrides?: CallOverrides): Promise<void>;

    addRewardsContracts(
      rewardsContract: PromiseOrValue<string>,
      synth: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    addSynths(
      _synthNamesInResolver: PromiseOrValue<BytesLike>[],
      _synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides,
    ): Promise<void>;

    areSynthsAndCurrenciesSet(
      _synthNamesInResolver: PromiseOrValue<BytesLike>[],
      _synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides,
    ): Promise<boolean>;

    canOpenLoans(overrides?: CallOverrides): Promise<boolean>;

    claim(amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    close(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { amount: BigNumber; collateral: BigNumber }>;

    collateralKey(overrides?: CallOverrides): Promise<string>;

    collateralRatio(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    deposit(
      borrower: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { principal: BigNumber; collateral: BigNumber }>;

    draw(
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { principal: BigNumber; collateral: BigNumber }>;

    isResolverCached(overrides?: CallOverrides): Promise<boolean>;

    issueFeeRate(overrides?: CallOverrides): Promise<BigNumber>;

    liquidate(
      borrower: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    liquidationAmount(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    loans(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, string, BigNumber, string, BigNumber, boolean, BigNumber, BigNumber, BigNumber] & {
        id: BigNumber;
        account: string;
        collateral: BigNumber;
        currency: string;
        amount: BigNumber;
        short: boolean;
        accruedInterest: BigNumber;
        interestIndex: BigNumber;
        lastInteraction: BigNumber;
      }
    >;

    manager(overrides?: CallOverrides): Promise<string>;

    maxLoan(
      amount: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    minCollateral(overrides?: CallOverrides): Promise<BigNumber>;

    minCratio(overrides?: CallOverrides): Promise<BigNumber>;

    nominateNewOwner(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    nominatedOwner(overrides?: CallOverrides): Promise<string>;

    open(
      amount: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    pendingWithdrawals(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    rebuildCache(overrides?: CallOverrides): Promise<void>;

    repay(
      borrower: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { principal: BigNumber; collateral: BigNumber }>;

    resolver(overrides?: CallOverrides): Promise<string>;

    resolverAddressesRequired(overrides?: CallOverrides): Promise<string[]>;

    setCanOpenLoans(_canOpenLoans: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;

    setIssueFeeRate(_issueFeeRate: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setMinCollateral(_minCollateral: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    shortingRewards(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

    synths(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    synthsByKey(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

    withdraw(
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { principal: BigNumber; collateral: BigNumber }>;
  };

  filters: {
    'CacheUpdated(bytes32,address)'(name?: null, destination?: null): CacheUpdatedEventFilter;
    CacheUpdated(name?: null, destination?: null): CacheUpdatedEventFilter;

    'CanOpenLoansUpdated(bool)'(canOpenLoans?: null): CanOpenLoansUpdatedEventFilter;
    CanOpenLoansUpdated(canOpenLoans?: null): CanOpenLoansUpdatedEventFilter;

    'CollateralDeposited(address,uint256,uint256,uint256)'(
      account?: PromiseOrValue<string> | null,
      id?: null,
      amountDeposited?: null,
      collateralAfter?: null,
    ): CollateralDepositedEventFilter;
    CollateralDeposited(
      account?: PromiseOrValue<string> | null,
      id?: null,
      amountDeposited?: null,
      collateralAfter?: null,
    ): CollateralDepositedEventFilter;

    'CollateralWithdrawn(address,uint256,uint256,uint256)'(
      account?: PromiseOrValue<string> | null,
      id?: null,
      amountWithdrawn?: null,
      collateralAfter?: null,
    ): CollateralWithdrawnEventFilter;
    CollateralWithdrawn(
      account?: PromiseOrValue<string> | null,
      id?: null,
      amountWithdrawn?: null,
      collateralAfter?: null,
    ): CollateralWithdrawnEventFilter;

    'IssueFeeRateUpdated(uint256)'(issueFeeRate?: null): IssueFeeRateUpdatedEventFilter;
    IssueFeeRateUpdated(issueFeeRate?: null): IssueFeeRateUpdatedEventFilter;

    'LoanClosed(address,uint256)'(account?: PromiseOrValue<string> | null, id?: null): LoanClosedEventFilter;
    LoanClosed(account?: PromiseOrValue<string> | null, id?: null): LoanClosedEventFilter;

    'LoanClosedByLiquidation(address,uint256,address,uint256,uint256)'(
      account?: PromiseOrValue<string> | null,
      id?: null,
      liquidator?: PromiseOrValue<string> | null,
      amountLiquidated?: null,
      collateralLiquidated?: null,
    ): LoanClosedByLiquidationEventFilter;
    LoanClosedByLiquidation(
      account?: PromiseOrValue<string> | null,
      id?: null,
      liquidator?: PromiseOrValue<string> | null,
      amountLiquidated?: null,
      collateralLiquidated?: null,
    ): LoanClosedByLiquidationEventFilter;

    'LoanClosedByRepayment(address,uint256,uint256,uint256)'(
      account?: PromiseOrValue<string> | null,
      id?: null,
      amountRepaid?: null,
      collateralAfter?: null,
    ): LoanClosedByRepaymentEventFilter;
    LoanClosedByRepayment(
      account?: PromiseOrValue<string> | null,
      id?: null,
      amountRepaid?: null,
      collateralAfter?: null,
    ): LoanClosedByRepaymentEventFilter;

    'LoanCreated(address,uint256,uint256,uint256,bytes32,uint256)'(
      account?: PromiseOrValue<string> | null,
      id?: null,
      amount?: null,
      collateral?: null,
      currency?: null,
      issuanceFee?: null,
    ): LoanCreatedEventFilter;
    LoanCreated(
      account?: PromiseOrValue<string> | null,
      id?: null,
      amount?: null,
      collateral?: null,
      currency?: null,
      issuanceFee?: null,
    ): LoanCreatedEventFilter;

    'LoanDrawnDown(address,uint256,uint256)'(
      account?: PromiseOrValue<string> | null,
      id?: null,
      amount?: null,
    ): LoanDrawnDownEventFilter;
    LoanDrawnDown(account?: PromiseOrValue<string> | null, id?: null, amount?: null): LoanDrawnDownEventFilter;

    'LoanPartiallyLiquidated(address,uint256,address,uint256,uint256)'(
      account?: PromiseOrValue<string> | null,
      id?: null,
      liquidator?: null,
      amountLiquidated?: null,
      collateralLiquidated?: null,
    ): LoanPartiallyLiquidatedEventFilter;
    LoanPartiallyLiquidated(
      account?: PromiseOrValue<string> | null,
      id?: null,
      liquidator?: null,
      amountLiquidated?: null,
      collateralLiquidated?: null,
    ): LoanPartiallyLiquidatedEventFilter;

    'LoanRepaymentMade(address,address,uint256,uint256,uint256)'(
      account?: PromiseOrValue<string> | null,
      repayer?: PromiseOrValue<string> | null,
      id?: null,
      amountRepaid?: null,
      amountAfter?: null,
    ): LoanRepaymentMadeEventFilter;
    LoanRepaymentMade(
      account?: PromiseOrValue<string> | null,
      repayer?: PromiseOrValue<string> | null,
      id?: null,
      amountRepaid?: null,
      amountAfter?: null,
    ): LoanRepaymentMadeEventFilter;

    'MinCollateralUpdated(uint256)'(minCollateral?: null): MinCollateralUpdatedEventFilter;
    MinCollateralUpdated(minCollateral?: null): MinCollateralUpdatedEventFilter;

    'OwnerChanged(address,address)'(oldOwner?: null, newOwner?: null): OwnerChangedEventFilter;
    OwnerChanged(oldOwner?: null, newOwner?: null): OwnerChangedEventFilter;

    'OwnerNominated(address)'(newOwner?: null): OwnerNominatedEventFilter;
    OwnerNominated(newOwner?: null): OwnerNominatedEventFilter;
  };

  estimateGas: {
    acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    addRewardsContracts(
      rewardsContract: PromiseOrValue<string>,
      synth: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    addSynths(
      _synthNamesInResolver: PromiseOrValue<BytesLike>[],
      _synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    areSynthsAndCurrenciesSet(
      _synthNamesInResolver: PromiseOrValue<BytesLike>[],
      _synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    canOpenLoans(overrides?: CallOverrides): Promise<BigNumber>;

    claim(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    close(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    collateralKey(overrides?: CallOverrides): Promise<BigNumber>;

    collateralRatio(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    deposit(
      borrower: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    draw(
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    isResolverCached(overrides?: CallOverrides): Promise<BigNumber>;

    issueFeeRate(overrides?: CallOverrides): Promise<BigNumber>;

    liquidate(
      borrower: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    liquidationAmount(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    loans(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    manager(overrides?: CallOverrides): Promise<BigNumber>;

    maxLoan(
      amount: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    minCollateral(overrides?: CallOverrides): Promise<BigNumber>;

    minCratio(overrides?: CallOverrides): Promise<BigNumber>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    nominatedOwner(overrides?: CallOverrides): Promise<BigNumber>;

    open(
      amount: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pendingWithdrawals(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    rebuildCache(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    repay(
      borrower: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    resolver(overrides?: CallOverrides): Promise<BigNumber>;

    resolverAddressesRequired(overrides?: CallOverrides): Promise<BigNumber>;

    setCanOpenLoans(
      _canOpenLoans: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setIssueFeeRate(
      _issueFeeRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setMinCollateral(
      _minCollateral: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    shortingRewards(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    synths(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    synthsByKey(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    withdraw(
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    addRewardsContracts(
      rewardsContract: PromiseOrValue<string>,
      synth: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    addSynths(
      _synthNamesInResolver: PromiseOrValue<BytesLike>[],
      _synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    areSynthsAndCurrenciesSet(
      _synthNamesInResolver: PromiseOrValue<BytesLike>[],
      _synthKeys: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    canOpenLoans(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    claim(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    close(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    collateralKey(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    collateralRatio(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    deposit(
      borrower: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    draw(
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    isResolverCached(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    issueFeeRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    liquidate(
      borrower: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    liquidationAmount(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    loans(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    manager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    maxLoan(
      amount: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    minCollateral(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minCratio(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    nominatedOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    open(
      amount: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingWithdrawals(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rebuildCache(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    repay(
      borrower: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    resolver(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    resolverAddressesRequired(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setCanOpenLoans(
      _canOpenLoans: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setIssueFeeRate(
      _issueFeeRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setMinCollateral(
      _minCollateral: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    shortingRewards(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    synths(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    synthsByKey(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdraw(
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;
  };
}

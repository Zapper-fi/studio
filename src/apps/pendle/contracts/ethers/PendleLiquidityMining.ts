/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export type PairTokensStruct = {
  tokenA: PromiseOrValue<string>;
  tokenB: PromiseOrValue<string>;
};

export type PairTokensStructOutput = [string, string] & {
  tokenA: string;
  tokenB: string;
};

export type PairUintsStruct = {
  uintA: PromiseOrValue<BigNumberish>;
  uintB: PromiseOrValue<BigNumberish>;
};

export type PairUintsStructOutput = [BigNumber, BigNumber] & {
  uintA: BigNumber;
  uintB: BigNumber;
};

export declare namespace PendleLiquidityMiningBaseMulti {
  export type ConstructorArgsStruct = {
    governanceManager: PromiseOrValue<string>;
    pausingManager: PromiseOrValue<string>;
    whitelist: PromiseOrValue<string>;
    rewardTokens: PairTokensStruct;
    router: PromiseOrValue<string>;
    marketFactoryId: PromiseOrValue<BytesLike>;
    forgeId: PromiseOrValue<BytesLike>;
    underlyingAsset: PromiseOrValue<string>;
    baseToken: PromiseOrValue<string>;
    startTime: PromiseOrValue<BigNumberish>;
    epochDuration: PromiseOrValue<BigNumberish>;
    vestingEpochs: PromiseOrValue<BigNumberish>;
  };

  export type ConstructorArgsStructOutput = [
    string,
    string,
    string,
    PairTokensStructOutput,
    string,
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
  ] & {
    governanceManager: string;
    pausingManager: string;
    whitelist: string;
    rewardTokens: PairTokensStructOutput;
    router: string;
    marketFactoryId: string;
    forgeId: string;
    underlyingAsset: string;
    baseToken: string;
    startTime: BigNumber;
    epochDuration: BigNumber;
    vestingEpochs: BigNumber;
  };
}

export interface PendleLiquidityMiningInterface extends utils.Interface {
  functions: {
    'allExpiries(uint256)': FunctionFragment;
    'allocationSettings(uint256,uint256)': FunctionFragment;
    'baseToken()': FunctionFragment;
    'data()': FunctionFragment;
    'epochDuration()': FunctionFragment;
    'forge()': FunctionFragment;
    'forgeId()': FunctionFragment;
    'fund((uint256,uint256)[])': FunctionFragment;
    'funded()': FunctionFragment;
    'getBalances(uint256,address)': FunctionFragment;
    'getCurrentEpochId()': FunctionFragment;
    'governanceManager()': FunctionFragment;
    'latestSetting()': FunctionFragment;
    'lpHolderForExpiry(uint256)': FunctionFragment;
    'marketFactoryId()': FunctionFragment;
    'numberOfEpochs()': FunctionFragment;
    'readAllExpiriesLength()': FunctionFragment;
    'readAvailableRewardsForUser(uint256,address)': FunctionFragment;
    'readEpochData(uint256)': FunctionFragment;
    'readExpiryData(uint256)': FunctionFragment;
    'readExpirySpecificEpochData(uint256,uint256)': FunctionFragment;
    'readRewardTokens()': FunctionFragment;
    'readStakeUnitsForUser(uint256,address,uint256)': FunctionFragment;
    'readUserExpiries(address)': FunctionFragment;
    'readUserSpecificExpiryData(uint256,address)': FunctionFragment;
    'redeemLpInterests(uint256,address)': FunctionFragment;
    'redeemRewards(uint256,address)': FunctionFragment;
    'rewardTokens()': FunctionFragment;
    'router()': FunctionFragment;
    'setAllocationSetting(uint256[],uint256[])': FunctionFragment;
    'setUpEmergencyMode(uint256[],address)': FunctionFragment;
    'stakeFor(address,uint256,uint256)': FunctionFragment;
    'stakeWithPermit(uint256,uint256,uint256,uint8,bytes32,bytes32)': FunctionFragment;
    'startTime()': FunctionFragment;
    'topUpRewards(uint256[],(uint256,uint256)[])': FunctionFragment;
    'totalRewardsForEpoch(uint256)': FunctionFragment;
    'underlyingAsset()': FunctionFragment;
    'underlyingYieldToken()': FunctionFragment;
    'vestingEpochs()': FunctionFragment;
    'whitelist()': FunctionFragment;
    'withdrawEther(uint256,address)': FunctionFragment;
    'withdrawTo(address,uint256,uint256)': FunctionFragment;
    'withdrawToken(address,uint256,address)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'allExpiries'
      | 'allocationSettings'
      | 'baseToken'
      | 'data'
      | 'epochDuration'
      | 'forge'
      | 'forgeId'
      | 'fund'
      | 'funded'
      | 'getBalances'
      | 'getCurrentEpochId'
      | 'governanceManager'
      | 'latestSetting'
      | 'lpHolderForExpiry'
      | 'marketFactoryId'
      | 'numberOfEpochs'
      | 'readAllExpiriesLength'
      | 'readAvailableRewardsForUser'
      | 'readEpochData'
      | 'readExpiryData'
      | 'readExpirySpecificEpochData'
      | 'readRewardTokens'
      | 'readStakeUnitsForUser'
      | 'readUserExpiries'
      | 'readUserSpecificExpiryData'
      | 'redeemLpInterests'
      | 'redeemRewards'
      | 'rewardTokens'
      | 'router'
      | 'setAllocationSetting'
      | 'setUpEmergencyMode'
      | 'stakeFor'
      | 'stakeWithPermit'
      | 'startTime'
      | 'topUpRewards'
      | 'totalRewardsForEpoch'
      | 'underlyingAsset'
      | 'underlyingYieldToken'
      | 'vestingEpochs'
      | 'whitelist'
      | 'withdrawEther'
      | 'withdrawTo'
      | 'withdrawToken',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'allExpiries', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'allocationSettings',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'baseToken', values?: undefined): string;
  encodeFunctionData(functionFragment: 'data', values?: undefined): string;
  encodeFunctionData(functionFragment: 'epochDuration', values?: undefined): string;
  encodeFunctionData(functionFragment: 'forge', values?: undefined): string;
  encodeFunctionData(functionFragment: 'forgeId', values?: undefined): string;
  encodeFunctionData(functionFragment: 'fund', values: [PairUintsStruct[]]): string;
  encodeFunctionData(functionFragment: 'funded', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'getBalances',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'getCurrentEpochId', values?: undefined): string;
  encodeFunctionData(functionFragment: 'governanceManager', values?: undefined): string;
  encodeFunctionData(functionFragment: 'latestSetting', values?: undefined): string;
  encodeFunctionData(functionFragment: 'lpHolderForExpiry', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'marketFactoryId', values?: undefined): string;
  encodeFunctionData(functionFragment: 'numberOfEpochs', values?: undefined): string;
  encodeFunctionData(functionFragment: 'readAllExpiriesLength', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'readAvailableRewardsForUser',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'readEpochData', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'readExpiryData', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'readExpirySpecificEpochData',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'readRewardTokens', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'readStakeUnitsForUser',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'readUserExpiries', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'readUserSpecificExpiryData',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'redeemLpInterests',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'redeemRewards',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'rewardTokens', values?: undefined): string;
  encodeFunctionData(functionFragment: 'router', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'setAllocationSetting',
    values: [PromiseOrValue<BigNumberish>[], PromiseOrValue<BigNumberish>[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'setUpEmergencyMode',
    values: [PromiseOrValue<BigNumberish>[], PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'stakeFor',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'stakeWithPermit',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'startTime', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'topUpRewards',
    values: [PromiseOrValue<BigNumberish>[], PairUintsStruct[]],
  ): string;
  encodeFunctionData(functionFragment: 'totalRewardsForEpoch', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'underlyingAsset', values?: undefined): string;
  encodeFunctionData(functionFragment: 'underlyingYieldToken', values?: undefined): string;
  encodeFunctionData(functionFragment: 'vestingEpochs', values?: undefined): string;
  encodeFunctionData(functionFragment: 'whitelist', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'withdrawEther',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'withdrawTo',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'withdrawToken',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;

  decodeFunctionResult(functionFragment: 'allExpiries', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allocationSettings', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'baseToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'data', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'epochDuration', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'forge', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'forgeId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'fund', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'funded', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getBalances', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getCurrentEpochId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'governanceManager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'latestSetting', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lpHolderForExpiry', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'marketFactoryId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'numberOfEpochs', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'readAllExpiriesLength', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'readAvailableRewardsForUser', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'readEpochData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'readExpiryData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'readExpirySpecificEpochData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'readRewardTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'readStakeUnitsForUser', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'readUserExpiries', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'readUserSpecificExpiryData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'redeemLpInterests', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'redeemRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'router', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setAllocationSetting', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setUpEmergencyMode', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stakeFor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stakeWithPermit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'startTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'topUpRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalRewardsForEpoch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'underlyingAsset', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'underlyingYieldToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'vestingEpochs', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'whitelist', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawEther', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawTo', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawToken', data: BytesLike): Result;

  events: {
    'AllocationSettingSet(uint256[],uint256[])': EventFragment;
    'EtherWithdraw(uint256,address)': EventFragment;
    'Funded(tuple[],uint256)': EventFragment;
    'PendleRewardsSettled(uint256,address,tuple)': EventFragment;
    'RedeemLpInterests(uint256,address,uint256)': EventFragment;
    'RewardsToppedUp(uint256[],tuple[])': EventFragment;
    'Staked(uint256,address,uint256)': EventFragment;
    'TokenWithdraw(address,uint256,address)': EventFragment;
    'Withdrawn(uint256,address,uint256)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'AllocationSettingSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'EtherWithdraw'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Funded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'PendleRewardsSettled'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RedeemLpInterests'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardsToppedUp'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Staked'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TokenWithdraw'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Withdrawn'): EventFragment;
}

export interface AllocationSettingSetEventObject {
  _expiries: BigNumber[];
  _allocationNumerators: BigNumber[];
}
export type AllocationSettingSetEvent = TypedEvent<[BigNumber[], BigNumber[]], AllocationSettingSetEventObject>;

export type AllocationSettingSetEventFilter = TypedEventFilter<AllocationSettingSetEvent>;

export interface EtherWithdrawEventObject {
  amount: BigNumber;
  sendTo: string;
}
export type EtherWithdrawEvent = TypedEvent<[BigNumber, string], EtherWithdrawEventObject>;

export type EtherWithdrawEventFilter = TypedEventFilter<EtherWithdrawEvent>;

export interface FundedEventObject {
  _rewards: PairUintsStructOutput[];
  numberOfEpochs: BigNumber;
}
export type FundedEvent = TypedEvent<[PairUintsStructOutput[], BigNumber], FundedEventObject>;

export type FundedEventFilter = TypedEventFilter<FundedEvent>;

export interface PendleRewardsSettledEventObject {
  expiry: BigNumber;
  user: string;
  amount: PairUintsStructOutput;
}
export type PendleRewardsSettledEvent = TypedEvent<
  [BigNumber, string, PairUintsStructOutput],
  PendleRewardsSettledEventObject
>;

export type PendleRewardsSettledEventFilter = TypedEventFilter<PendleRewardsSettledEvent>;

export interface RedeemLpInterestsEventObject {
  expiry: BigNumber;
  user: string;
  interests: BigNumber;
}
export type RedeemLpInterestsEvent = TypedEvent<[BigNumber, string, BigNumber], RedeemLpInterestsEventObject>;

export type RedeemLpInterestsEventFilter = TypedEventFilter<RedeemLpInterestsEvent>;

export interface RewardsToppedUpEventObject {
  _epochIds: BigNumber[];
  _rewards: PairUintsStructOutput[];
}
export type RewardsToppedUpEvent = TypedEvent<[BigNumber[], PairUintsStructOutput[]], RewardsToppedUpEventObject>;

export type RewardsToppedUpEventFilter = TypedEventFilter<RewardsToppedUpEvent>;

export interface StakedEventObject {
  expiry: BigNumber;
  user: string;
  amount: BigNumber;
}
export type StakedEvent = TypedEvent<[BigNumber, string, BigNumber], StakedEventObject>;

export type StakedEventFilter = TypedEventFilter<StakedEvent>;

export interface TokenWithdrawEventObject {
  token: string;
  amount: BigNumber;
  sendTo: string;
}
export type TokenWithdrawEvent = TypedEvent<[string, BigNumber, string], TokenWithdrawEventObject>;

export type TokenWithdrawEventFilter = TypedEventFilter<TokenWithdrawEvent>;

export interface WithdrawnEventObject {
  expiry: BigNumber;
  user: string;
  amount: BigNumber;
}
export type WithdrawnEvent = TypedEvent<[BigNumber, string, BigNumber], WithdrawnEventObject>;

export type WithdrawnEventFilter = TypedEventFilter<WithdrawnEvent>;

export interface PendleLiquidityMining extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: PendleLiquidityMiningInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    allExpiries(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    allocationSettings(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    baseToken(overrides?: CallOverrides): Promise<[string]>;

    data(overrides?: CallOverrides): Promise<[string]>;

    epochDuration(overrides?: CallOverrides): Promise<[BigNumber]>;

    forge(overrides?: CallOverrides): Promise<[string]>;

    forgeId(overrides?: CallOverrides): Promise<[string]>;

    fund(
      _rewards: PairUintsStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    funded(overrides?: CallOverrides): Promise<[boolean]>;

    getBalances(
      expiry: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    getCurrentEpochId(overrides?: CallOverrides): Promise<[BigNumber]>;

    governanceManager(overrides?: CallOverrides): Promise<[string]>;

    latestSetting(
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { id: BigNumber; firstEpochToApply: BigNumber }>;

    lpHolderForExpiry(expiry: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    marketFactoryId(overrides?: CallOverrides): Promise<[string]>;

    numberOfEpochs(overrides?: CallOverrides): Promise<[BigNumber]>;

    readAllExpiriesLength(overrides?: CallOverrides): Promise<[BigNumber] & { length: BigNumber }>;

    readAvailableRewardsForUser(
      epochId: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [PairUintsStructOutput] & {
        availableRewardsForUser: PairUintsStructOutput;
      }
    >;

    readEpochData(
      epochId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, PairUintsStructOutput] & {
        settingId: BigNumber;
        totalRewards: PairUintsStructOutput;
      }
    >;

    readExpiryData(
      expiry: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, string] & {
        totalStakeLP: BigNumber;
        lastNYield: BigNumber;
        paramL: BigNumber;
        lpHolder: string;
      }
    >;

    readExpirySpecificEpochData(
      epochId: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        stakeUnits: BigNumber;
        lastUpdatedForExpiry: BigNumber;
      }
    >;

    readRewardTokens(overrides?: CallOverrides): Promise<[PairTokensStructOutput] & { tokens: PairTokensStructOutput }>;

    readStakeUnitsForUser(
      epochId: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { stakeUnitsForUser: BigNumber }>;

    readUserExpiries(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber[]] & { _expiries: BigNumber[] }>;

    readUserSpecificExpiryData(
      expiry: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        lastTimeUserStakeUpdated: BigNumber;
        lastEpochClaimed: BigNumber;
        balances: BigNumber;
        lastParamL: BigNumber;
        dueInterests: BigNumber;
      }
    >;

    redeemLpInterests(
      expiry: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    redeemRewards(
      expiry: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    rewardTokens(overrides?: CallOverrides): Promise<[string, string] & { tokenA: string; tokenB: string }>;

    router(overrides?: CallOverrides): Promise<[string]>;

    setAllocationSetting(
      _expiries: PromiseOrValue<BigNumberish>[],
      _allocationNumerators: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setUpEmergencyMode(
      expiries: PromiseOrValue<BigNumberish>[],
      spender: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    stakeFor(
      forAddr: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    stakeWithPermit(
      expiry: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    startTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    topUpRewards(
      _epochIds: PromiseOrValue<BigNumberish>[],
      _rewards: PairUintsStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    totalRewardsForEpoch(
      epochId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[PairUintsStructOutput] & { rewards: PairUintsStructOutput }>;

    underlyingAsset(overrides?: CallOverrides): Promise<[string]>;

    underlyingYieldToken(overrides?: CallOverrides): Promise<[string]>;

    vestingEpochs(overrides?: CallOverrides): Promise<[BigNumber]>;

    whitelist(overrides?: CallOverrides): Promise<[string]>;

    withdrawEther(
      amount: PromiseOrValue<BigNumberish>,
      sendTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    withdrawTo(
      to: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    withdrawToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      sendTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;
  };

  allExpiries(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  allocationSettings(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  baseToken(overrides?: CallOverrides): Promise<string>;

  data(overrides?: CallOverrides): Promise<string>;

  epochDuration(overrides?: CallOverrides): Promise<BigNumber>;

  forge(overrides?: CallOverrides): Promise<string>;

  forgeId(overrides?: CallOverrides): Promise<string>;

  fund(
    _rewards: PairUintsStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  funded(overrides?: CallOverrides): Promise<boolean>;

  getBalances(
    expiry: PromiseOrValue<BigNumberish>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  getCurrentEpochId(overrides?: CallOverrides): Promise<BigNumber>;

  governanceManager(overrides?: CallOverrides): Promise<string>;

  latestSetting(
    overrides?: CallOverrides,
  ): Promise<[BigNumber, BigNumber] & { id: BigNumber; firstEpochToApply: BigNumber }>;

  lpHolderForExpiry(expiry: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  marketFactoryId(overrides?: CallOverrides): Promise<string>;

  numberOfEpochs(overrides?: CallOverrides): Promise<BigNumber>;

  readAllExpiriesLength(overrides?: CallOverrides): Promise<BigNumber>;

  readAvailableRewardsForUser(
    epochId: PromiseOrValue<BigNumberish>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<PairUintsStructOutput>;

  readEpochData(
    epochId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, PairUintsStructOutput] & {
      settingId: BigNumber;
      totalRewards: PairUintsStructOutput;
    }
  >;

  readExpiryData(
    expiry: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber, string] & {
      totalStakeLP: BigNumber;
      lastNYield: BigNumber;
      paramL: BigNumber;
      lpHolder: string;
    }
  >;

  readExpirySpecificEpochData(
    epochId: PromiseOrValue<BigNumberish>,
    expiry: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber] & {
      stakeUnits: BigNumber;
      lastUpdatedForExpiry: BigNumber;
    }
  >;

  readRewardTokens(overrides?: CallOverrides): Promise<PairTokensStructOutput>;

  readStakeUnitsForUser(
    epochId: PromiseOrValue<BigNumberish>,
    user: PromiseOrValue<string>,
    expiry: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  readUserExpiries(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber[]>;

  readUserSpecificExpiryData(
    expiry: PromiseOrValue<BigNumberish>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
      lastTimeUserStakeUpdated: BigNumber;
      lastEpochClaimed: BigNumber;
      balances: BigNumber;
      lastParamL: BigNumber;
      dueInterests: BigNumber;
    }
  >;

  redeemLpInterests(
    expiry: PromiseOrValue<BigNumberish>,
    user: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  redeemRewards(
    expiry: PromiseOrValue<BigNumberish>,
    user: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  rewardTokens(overrides?: CallOverrides): Promise<[string, string] & { tokenA: string; tokenB: string }>;

  router(overrides?: CallOverrides): Promise<string>;

  setAllocationSetting(
    _expiries: PromiseOrValue<BigNumberish>[],
    _allocationNumerators: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setUpEmergencyMode(
    expiries: PromiseOrValue<BigNumberish>[],
    spender: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  stakeFor(
    forAddr: PromiseOrValue<string>,
    expiry: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  stakeWithPermit(
    expiry: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    deadline: PromiseOrValue<BigNumberish>,
    v: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    s: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  startTime(overrides?: CallOverrides): Promise<BigNumber>;

  topUpRewards(
    _epochIds: PromiseOrValue<BigNumberish>[],
    _rewards: PairUintsStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  totalRewardsForEpoch(
    epochId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<PairUintsStructOutput>;

  underlyingAsset(overrides?: CallOverrides): Promise<string>;

  underlyingYieldToken(overrides?: CallOverrides): Promise<string>;

  vestingEpochs(overrides?: CallOverrides): Promise<BigNumber>;

  whitelist(overrides?: CallOverrides): Promise<string>;

  withdrawEther(
    amount: PromiseOrValue<BigNumberish>,
    sendTo: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  withdrawTo(
    to: PromiseOrValue<string>,
    expiry: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  withdrawToken(
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    sendTo: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    allExpiries(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    allocationSettings(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    baseToken(overrides?: CallOverrides): Promise<string>;

    data(overrides?: CallOverrides): Promise<string>;

    epochDuration(overrides?: CallOverrides): Promise<BigNumber>;

    forge(overrides?: CallOverrides): Promise<string>;

    forgeId(overrides?: CallOverrides): Promise<string>;

    fund(_rewards: PairUintsStruct[], overrides?: CallOverrides): Promise<void>;

    funded(overrides?: CallOverrides): Promise<boolean>;

    getBalances(
      expiry: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getCurrentEpochId(overrides?: CallOverrides): Promise<BigNumber>;

    governanceManager(overrides?: CallOverrides): Promise<string>;

    latestSetting(
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { id: BigNumber; firstEpochToApply: BigNumber }>;

    lpHolderForExpiry(expiry: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    marketFactoryId(overrides?: CallOverrides): Promise<string>;

    numberOfEpochs(overrides?: CallOverrides): Promise<BigNumber>;

    readAllExpiriesLength(overrides?: CallOverrides): Promise<BigNumber>;

    readAvailableRewardsForUser(
      epochId: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PairUintsStructOutput>;

    readEpochData(
      epochId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, PairUintsStructOutput] & {
        settingId: BigNumber;
        totalRewards: PairUintsStructOutput;
      }
    >;

    readExpiryData(
      expiry: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, string] & {
        totalStakeLP: BigNumber;
        lastNYield: BigNumber;
        paramL: BigNumber;
        lpHolder: string;
      }
    >;

    readExpirySpecificEpochData(
      epochId: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        stakeUnits: BigNumber;
        lastUpdatedForExpiry: BigNumber;
      }
    >;

    readRewardTokens(overrides?: CallOverrides): Promise<PairTokensStructOutput>;

    readStakeUnitsForUser(
      epochId: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    readUserExpiries(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber[]>;

    readUserSpecificExpiryData(
      expiry: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        lastTimeUserStakeUpdated: BigNumber;
        lastEpochClaimed: BigNumber;
        balances: BigNumber;
        lastParamL: BigNumber;
        dueInterests: BigNumber;
      }
    >;

    redeemLpInterests(
      expiry: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    redeemRewards(
      expiry: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PairUintsStructOutput>;

    rewardTokens(overrides?: CallOverrides): Promise<[string, string] & { tokenA: string; tokenB: string }>;

    router(overrides?: CallOverrides): Promise<string>;

    setAllocationSetting(
      _expiries: PromiseOrValue<BigNumberish>[],
      _allocationNumerators: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<void>;

    setUpEmergencyMode(
      expiries: PromiseOrValue<BigNumberish>[],
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    stakeFor(
      forAddr: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<string>;

    stakeWithPermit(
      expiry: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<string>;

    startTime(overrides?: CallOverrides): Promise<BigNumber>;

    topUpRewards(
      _epochIds: PromiseOrValue<BigNumberish>[],
      _rewards: PairUintsStruct[],
      overrides?: CallOverrides,
    ): Promise<void>;

    totalRewardsForEpoch(
      epochId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PairUintsStructOutput>;

    underlyingAsset(overrides?: CallOverrides): Promise<string>;

    underlyingYieldToken(overrides?: CallOverrides): Promise<string>;

    vestingEpochs(overrides?: CallOverrides): Promise<BigNumber>;

    whitelist(overrides?: CallOverrides): Promise<string>;

    withdrawEther(
      amount: PromiseOrValue<BigNumberish>,
      sendTo: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    withdrawTo(
      to: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    withdrawToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      sendTo: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;
  };

  filters: {
    'AllocationSettingSet(uint256[],uint256[])'(
      _expiries?: null,
      _allocationNumerators?: null,
    ): AllocationSettingSetEventFilter;
    AllocationSettingSet(_expiries?: null, _allocationNumerators?: null): AllocationSettingSetEventFilter;

    'EtherWithdraw(uint256,address)'(amount?: null, sendTo?: null): EtherWithdrawEventFilter;
    EtherWithdraw(amount?: null, sendTo?: null): EtherWithdrawEventFilter;

    'Funded(tuple[],uint256)'(_rewards?: null, numberOfEpochs?: null): FundedEventFilter;
    Funded(_rewards?: null, numberOfEpochs?: null): FundedEventFilter;

    'PendleRewardsSettled(uint256,address,tuple)'(
      expiry?: null,
      user?: null,
      amount?: null,
    ): PendleRewardsSettledEventFilter;
    PendleRewardsSettled(expiry?: null, user?: null, amount?: null): PendleRewardsSettledEventFilter;

    'RedeemLpInterests(uint256,address,uint256)'(
      expiry?: null,
      user?: null,
      interests?: null,
    ): RedeemLpInterestsEventFilter;
    RedeemLpInterests(expiry?: null, user?: null, interests?: null): RedeemLpInterestsEventFilter;

    'RewardsToppedUp(uint256[],tuple[])'(_epochIds?: null, _rewards?: null): RewardsToppedUpEventFilter;
    RewardsToppedUp(_epochIds?: null, _rewards?: null): RewardsToppedUpEventFilter;

    'Staked(uint256,address,uint256)'(expiry?: null, user?: null, amount?: null): StakedEventFilter;
    Staked(expiry?: null, user?: null, amount?: null): StakedEventFilter;

    'TokenWithdraw(address,uint256,address)'(token?: null, amount?: null, sendTo?: null): TokenWithdrawEventFilter;
    TokenWithdraw(token?: null, amount?: null, sendTo?: null): TokenWithdrawEventFilter;

    'Withdrawn(uint256,address,uint256)'(expiry?: null, user?: null, amount?: null): WithdrawnEventFilter;
    Withdrawn(expiry?: null, user?: null, amount?: null): WithdrawnEventFilter;
  };

  estimateGas: {
    allExpiries(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    allocationSettings(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    baseToken(overrides?: CallOverrides): Promise<BigNumber>;

    data(overrides?: CallOverrides): Promise<BigNumber>;

    epochDuration(overrides?: CallOverrides): Promise<BigNumber>;

    forge(overrides?: CallOverrides): Promise<BigNumber>;

    forgeId(overrides?: CallOverrides): Promise<BigNumber>;

    fund(_rewards: PairUintsStruct[], overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    funded(overrides?: CallOverrides): Promise<BigNumber>;

    getBalances(
      expiry: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getCurrentEpochId(overrides?: CallOverrides): Promise<BigNumber>;

    governanceManager(overrides?: CallOverrides): Promise<BigNumber>;

    latestSetting(overrides?: CallOverrides): Promise<BigNumber>;

    lpHolderForExpiry(expiry: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    marketFactoryId(overrides?: CallOverrides): Promise<BigNumber>;

    numberOfEpochs(overrides?: CallOverrides): Promise<BigNumber>;

    readAllExpiriesLength(overrides?: CallOverrides): Promise<BigNumber>;

    readAvailableRewardsForUser(
      epochId: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    readEpochData(epochId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    readExpiryData(expiry: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    readExpirySpecificEpochData(
      epochId: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    readRewardTokens(overrides?: CallOverrides): Promise<BigNumber>;

    readStakeUnitsForUser(
      epochId: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    readUserExpiries(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    readUserSpecificExpiryData(
      expiry: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    redeemLpInterests(
      expiry: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    redeemRewards(
      expiry: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    rewardTokens(overrides?: CallOverrides): Promise<BigNumber>;

    router(overrides?: CallOverrides): Promise<BigNumber>;

    setAllocationSetting(
      _expiries: PromiseOrValue<BigNumberish>[],
      _allocationNumerators: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setUpEmergencyMode(
      expiries: PromiseOrValue<BigNumberish>[],
      spender: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    stakeFor(
      forAddr: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    stakeWithPermit(
      expiry: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    startTime(overrides?: CallOverrides): Promise<BigNumber>;

    topUpRewards(
      _epochIds: PromiseOrValue<BigNumberish>[],
      _rewards: PairUintsStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    totalRewardsForEpoch(epochId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    underlyingAsset(overrides?: CallOverrides): Promise<BigNumber>;

    underlyingYieldToken(overrides?: CallOverrides): Promise<BigNumber>;

    vestingEpochs(overrides?: CallOverrides): Promise<BigNumber>;

    whitelist(overrides?: CallOverrides): Promise<BigNumber>;

    withdrawEther(
      amount: PromiseOrValue<BigNumberish>,
      sendTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    withdrawTo(
      to: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    withdrawToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      sendTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    allExpiries(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    allocationSettings(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    baseToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    data(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    epochDuration(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    forge(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    forgeId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    fund(
      _rewards: PairUintsStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    funded(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getBalances(
      expiry: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getCurrentEpochId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    governanceManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    latestSetting(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lpHolderForExpiry(expiry: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    marketFactoryId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    numberOfEpochs(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    readAllExpiriesLength(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    readAvailableRewardsForUser(
      epochId: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    readEpochData(epochId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    readExpiryData(expiry: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    readExpirySpecificEpochData(
      epochId: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    readRewardTokens(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    readStakeUnitsForUser(
      epochId: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    readUserExpiries(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    readUserSpecificExpiryData(
      expiry: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    redeemLpInterests(
      expiry: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    redeemRewards(
      expiry: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    rewardTokens(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    router(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setAllocationSetting(
      _expiries: PromiseOrValue<BigNumberish>[],
      _allocationNumerators: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setUpEmergencyMode(
      expiries: PromiseOrValue<BigNumberish>[],
      spender: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    stakeFor(
      forAddr: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    stakeWithPermit(
      expiry: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    startTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    topUpRewards(
      _epochIds: PromiseOrValue<BigNumberish>[],
      _rewards: PairUintsStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    totalRewardsForEpoch(
      epochId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    underlyingAsset(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    underlyingYieldToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    vestingEpochs(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    whitelist(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdrawEther(
      amount: PromiseOrValue<BigNumberish>,
      sendTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    withdrawTo(
      to: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    withdrawToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      sendTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;
  };
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export interface SpoolStakingInterface extends utils.Interface {
  functions: {
    'addToken(address,uint32,uint256)': FunctionFragment;
    'allowUnstakeFor(address)': FunctionFragment;
    'balances(address)': FunctionFragment;
    'canStakeFor(address)': FunctionFragment;
    'compound(bool)': FunctionFragment;
    'earned(address,address)': FunctionFragment;
    'getActiveRewards(bool)': FunctionFragment;
    'getRewards(address[],bool)': FunctionFragment;
    'getUpdatedVoSpoolRewardAmount()': FunctionFragment;
    'initialize()': FunctionFragment;
    'lastTimeRewardApplicable(address)': FunctionFragment;
    'notifyRewardAmount(address,uint32,uint256)': FunctionFragment;
    'recoverERC20(address,uint256,address)': FunctionFragment;
    'removeReward(address)': FunctionFragment;
    'rewardConfiguration(address)': FunctionFragment;
    'rewardDistributor()': FunctionFragment;
    'rewardPerToken(address)': FunctionFragment;
    'rewardTokens(uint256)': FunctionFragment;
    'rewardTokensCount()': FunctionFragment;
    'setCanStakeFor(address,bool)': FunctionFragment;
    'stake(uint256)': FunctionFragment;
    'stakeFor(address,uint256)': FunctionFragment;
    'stakedBy(address)': FunctionFragment;
    'stakingToken()': FunctionFragment;
    'tokenBlacklist(address)': FunctionFragment;
    'totalStaked()': FunctionFragment;
    'unstake(uint256)': FunctionFragment;
    'updatePeriodFinish(address,uint32)': FunctionFragment;
    'voSpool()': FunctionFragment;
    'voSpoolRewards()': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'addToken'
      | 'allowUnstakeFor'
      | 'balances'
      | 'canStakeFor'
      | 'compound'
      | 'earned'
      | 'getActiveRewards'
      | 'getRewards'
      | 'getUpdatedVoSpoolRewardAmount'
      | 'initialize'
      | 'lastTimeRewardApplicable'
      | 'notifyRewardAmount'
      | 'recoverERC20'
      | 'removeReward'
      | 'rewardConfiguration'
      | 'rewardDistributor'
      | 'rewardPerToken'
      | 'rewardTokens'
      | 'rewardTokensCount'
      | 'setCanStakeFor'
      | 'stake'
      | 'stakeFor'
      | 'stakedBy'
      | 'stakingToken'
      | 'tokenBlacklist'
      | 'totalStaked'
      | 'unstake'
      | 'updatePeriodFinish'
      | 'voSpool'
      | 'voSpoolRewards',
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: 'addToken',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'allowUnstakeFor', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'balances', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'canStakeFor', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'compound', values: [PromiseOrValue<boolean>]): string;
  encodeFunctionData(functionFragment: 'earned', values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getActiveRewards', values: [PromiseOrValue<boolean>]): string;
  encodeFunctionData(
    functionFragment: 'getRewards',
    values: [PromiseOrValue<string>[], PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'getUpdatedVoSpoolRewardAmount', values?: undefined): string;
  encodeFunctionData(functionFragment: 'initialize', values?: undefined): string;
  encodeFunctionData(functionFragment: 'lastTimeRewardApplicable', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'notifyRewardAmount',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'recoverERC20',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'removeReward', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'rewardConfiguration', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'rewardDistributor', values?: undefined): string;
  encodeFunctionData(functionFragment: 'rewardPerToken', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'rewardTokens', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'rewardTokensCount', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'setCanStakeFor',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'stake', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'stakeFor',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'stakedBy', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'stakingToken', values?: undefined): string;
  encodeFunctionData(functionFragment: 'tokenBlacklist', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'totalStaked', values?: undefined): string;
  encodeFunctionData(functionFragment: 'unstake', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'updatePeriodFinish',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'voSpool', values?: undefined): string;
  encodeFunctionData(functionFragment: 'voSpoolRewards', values?: undefined): string;

  decodeFunctionResult(functionFragment: 'addToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allowUnstakeFor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balances', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'canStakeFor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'compound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'earned', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getActiveRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getUpdatedVoSpoolRewardAmount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lastTimeRewardApplicable', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'notifyRewardAmount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'recoverERC20', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'removeReward', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardConfiguration', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardDistributor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardPerToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardTokensCount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setCanStakeFor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stake', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stakeFor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stakedBy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stakingToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tokenBlacklist', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalStaked', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'unstake', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updatePeriodFinish', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'voSpool', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'voSpoolRewards', data: BytesLike): Result;

  events: {
    'CanStakeForSet(address,bool)': EventFragment;
    'PeriodFinishUpdated(address,uint32)': EventFragment;
    'RewardAdded(address,uint256,uint256)': EventFragment;
    'RewardCompounded(address,uint256)': EventFragment;
    'RewardPaid(address,address,uint256)': EventFragment;
    'RewardRemoved(address)': EventFragment;
    'RewardUpdated(address,uint256,uint256,uint256,uint32)': EventFragment;
    'Staked(address,uint256)': EventFragment;
    'StakedFor(address,address,uint256)': EventFragment;
    'Unstaked(address,uint256)': EventFragment;
    'VoRewardCompounded(address,uint256)': EventFragment;
    'VoSpoolRewardPaid(address,address,uint256)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'CanStakeForSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'PeriodFinishUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardAdded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardCompounded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardPaid'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardRemoved'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Staked'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'StakedFor'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Unstaked'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'VoRewardCompounded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'VoSpoolRewardPaid'): EventFragment;
}

export interface CanStakeForSetEventObject {
  account: string;
  canStakeFor: boolean;
}
export type CanStakeForSetEvent = TypedEvent<[string, boolean], CanStakeForSetEventObject>;

export type CanStakeForSetEventFilter = TypedEventFilter<CanStakeForSetEvent>;

export interface PeriodFinishUpdatedEventObject {
  token: string;
  periodFinish: number;
}
export type PeriodFinishUpdatedEvent = TypedEvent<[string, number], PeriodFinishUpdatedEventObject>;

export type PeriodFinishUpdatedEventFilter = TypedEventFilter<PeriodFinishUpdatedEvent>;

export interface RewardAddedEventObject {
  token: string;
  amount: BigNumber;
  duration: BigNumber;
}
export type RewardAddedEvent = TypedEvent<[string, BigNumber, BigNumber], RewardAddedEventObject>;

export type RewardAddedEventFilter = TypedEventFilter<RewardAddedEvent>;

export interface RewardCompoundedEventObject {
  user: string;
  reward: BigNumber;
}
export type RewardCompoundedEvent = TypedEvent<[string, BigNumber], RewardCompoundedEventObject>;

export type RewardCompoundedEventFilter = TypedEventFilter<RewardCompoundedEvent>;

export interface RewardPaidEventObject {
  token: string;
  user: string;
  reward: BigNumber;
}
export type RewardPaidEvent = TypedEvent<[string, string, BigNumber], RewardPaidEventObject>;

export type RewardPaidEventFilter = TypedEventFilter<RewardPaidEvent>;

export interface RewardRemovedEventObject {
  token: string;
}
export type RewardRemovedEvent = TypedEvent<[string], RewardRemovedEventObject>;

export type RewardRemovedEventFilter = TypedEventFilter<RewardRemovedEvent>;

export interface RewardUpdatedEventObject {
  token: string;
  amount: BigNumber;
  leftover: BigNumber;
  duration: BigNumber;
  periodFinish: number;
}
export type RewardUpdatedEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, number],
  RewardUpdatedEventObject
>;

export type RewardUpdatedEventFilter = TypedEventFilter<RewardUpdatedEvent>;

export interface StakedEventObject {
  user: string;
  amount: BigNumber;
}
export type StakedEvent = TypedEvent<[string, BigNumber], StakedEventObject>;

export type StakedEventFilter = TypedEventFilter<StakedEvent>;

export interface StakedForEventObject {
  stakedFor: string;
  stakedBy: string;
  amount: BigNumber;
}
export type StakedForEvent = TypedEvent<[string, string, BigNumber], StakedForEventObject>;

export type StakedForEventFilter = TypedEventFilter<StakedForEvent>;

export interface UnstakedEventObject {
  user: string;
  amount: BigNumber;
}
export type UnstakedEvent = TypedEvent<[string, BigNumber], UnstakedEventObject>;

export type UnstakedEventFilter = TypedEventFilter<UnstakedEvent>;

export interface VoRewardCompoundedEventObject {
  user: string;
  reward: BigNumber;
}
export type VoRewardCompoundedEvent = TypedEvent<[string, BigNumber], VoRewardCompoundedEventObject>;

export type VoRewardCompoundedEventFilter = TypedEventFilter<VoRewardCompoundedEvent>;

export interface VoSpoolRewardPaidEventObject {
  token: string;
  user: string;
  reward: BigNumber;
}
export type VoSpoolRewardPaidEvent = TypedEvent<[string, string, BigNumber], VoSpoolRewardPaidEventObject>;

export type VoSpoolRewardPaidEventFilter = TypedEventFilter<VoSpoolRewardPaidEvent>;

export interface SpoolStaking extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: SpoolStakingInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    addToken(
      token: PromiseOrValue<string>,
      rewardsDuration: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    allowUnstakeFor(
      allowFor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    balances(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    canStakeFor(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    compound(
      doCompoundVoSpoolRewards: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    earned(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    getActiveRewards(
      doClaimVoSpoolRewards: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    getRewards(
      tokens: PromiseOrValue<string>[],
      doClaimVoSpoolRewards: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    getUpdatedVoSpoolRewardAmount(
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    initialize(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    lastTimeRewardApplicable(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[number]>;

    notifyRewardAmount(
      token: PromiseOrValue<string>,
      _rewardsDuration: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    recoverERC20(
      tokenAddress: PromiseOrValue<string>,
      tokenAmount: PromiseOrValue<BigNumberish>,
      recoverTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    removeReward(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    rewardConfiguration(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [number, number, BigNumber, number, BigNumber] & {
        rewardsDuration: number;
        periodFinish: number;
        rewardRate: BigNumber;
        lastUpdateTime: number;
        rewardPerTokenStored: BigNumber;
      }
    >;

    rewardDistributor(overrides?: CallOverrides): Promise<[string]>;

    rewardPerToken(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    rewardTokens(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    rewardTokensCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    setCanStakeFor(
      account: PromiseOrValue<string>,
      _canStakeFor: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    stake(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    stakeFor(
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    stakedBy(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;

    stakingToken(overrides?: CallOverrides): Promise<[string]>;

    tokenBlacklist(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    totalStaked(overrides?: CallOverrides): Promise<[BigNumber]>;

    unstake(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updatePeriodFinish(
      token: PromiseOrValue<string>,
      timestamp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    voSpool(overrides?: CallOverrides): Promise<[string]>;

    voSpoolRewards(overrides?: CallOverrides): Promise<[string]>;
  };

  addToken(
    token: PromiseOrValue<string>,
    rewardsDuration: PromiseOrValue<BigNumberish>,
    reward: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  allowUnstakeFor(
    allowFor: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  balances(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  canStakeFor(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  compound(
    doCompoundVoSpoolRewards: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  earned(token: PromiseOrValue<string>, account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  getActiveRewards(
    doClaimVoSpoolRewards: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  getRewards(
    tokens: PromiseOrValue<string>[],
    doClaimVoSpoolRewards: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  getUpdatedVoSpoolRewardAmount(
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  initialize(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  lastTimeRewardApplicable(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<number>;

  notifyRewardAmount(
    token: PromiseOrValue<string>,
    _rewardsDuration: PromiseOrValue<BigNumberish>,
    reward: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  recoverERC20(
    tokenAddress: PromiseOrValue<string>,
    tokenAmount: PromiseOrValue<BigNumberish>,
    recoverTo: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  removeReward(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  rewardConfiguration(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [number, number, BigNumber, number, BigNumber] & {
      rewardsDuration: number;
      periodFinish: number;
      rewardRate: BigNumber;
      lastUpdateTime: number;
      rewardPerTokenStored: BigNumber;
    }
  >;

  rewardDistributor(overrides?: CallOverrides): Promise<string>;

  rewardPerToken(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  rewardTokens(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  rewardTokensCount(overrides?: CallOverrides): Promise<BigNumber>;

  setCanStakeFor(
    account: PromiseOrValue<string>,
    _canStakeFor: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  stake(
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  stakeFor(
    account: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  stakedBy(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  stakingToken(overrides?: CallOverrides): Promise<string>;

  tokenBlacklist(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  totalStaked(overrides?: CallOverrides): Promise<BigNumber>;

  unstake(
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updatePeriodFinish(
    token: PromiseOrValue<string>,
    timestamp: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  voSpool(overrides?: CallOverrides): Promise<string>;

  voSpoolRewards(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    addToken(
      token: PromiseOrValue<string>,
      rewardsDuration: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    allowUnstakeFor(allowFor: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    balances(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    canStakeFor(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    compound(doCompoundVoSpoolRewards: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;

    earned(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getActiveRewards(doClaimVoSpoolRewards: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;

    getRewards(
      tokens: PromiseOrValue<string>[],
      doClaimVoSpoolRewards: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    getUpdatedVoSpoolRewardAmount(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(overrides?: CallOverrides): Promise<void>;

    lastTimeRewardApplicable(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<number>;

    notifyRewardAmount(
      token: PromiseOrValue<string>,
      _rewardsDuration: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    recoverERC20(
      tokenAddress: PromiseOrValue<string>,
      tokenAmount: PromiseOrValue<BigNumberish>,
      recoverTo: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    removeReward(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    rewardConfiguration(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [number, number, BigNumber, number, BigNumber] & {
        rewardsDuration: number;
        periodFinish: number;
        rewardRate: BigNumber;
        lastUpdateTime: number;
        rewardPerTokenStored: BigNumber;
      }
    >;

    rewardDistributor(overrides?: CallOverrides): Promise<string>;

    rewardPerToken(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    rewardTokens(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    rewardTokensCount(overrides?: CallOverrides): Promise<BigNumber>;

    setCanStakeFor(
      account: PromiseOrValue<string>,
      _canStakeFor: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    stake(amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    stakeFor(
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    stakedBy(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    stakingToken(overrides?: CallOverrides): Promise<string>;

    tokenBlacklist(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    totalStaked(overrides?: CallOverrides): Promise<BigNumber>;

    unstake(amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    updatePeriodFinish(
      token: PromiseOrValue<string>,
      timestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    voSpool(overrides?: CallOverrides): Promise<string>;

    voSpoolRewards(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    'CanStakeForSet(address,bool)'(
      account?: PromiseOrValue<string> | null,
      canStakeFor?: null,
    ): CanStakeForSetEventFilter;
    CanStakeForSet(account?: PromiseOrValue<string> | null, canStakeFor?: null): CanStakeForSetEventFilter;

    'PeriodFinishUpdated(address,uint32)'(
      token?: PromiseOrValue<string> | null,
      periodFinish?: null,
    ): PeriodFinishUpdatedEventFilter;
    PeriodFinishUpdated(token?: PromiseOrValue<string> | null, periodFinish?: null): PeriodFinishUpdatedEventFilter;

    'RewardAdded(address,uint256,uint256)'(
      token?: PromiseOrValue<string> | null,
      amount?: null,
      duration?: null,
    ): RewardAddedEventFilter;
    RewardAdded(token?: PromiseOrValue<string> | null, amount?: null, duration?: null): RewardAddedEventFilter;

    'RewardCompounded(address,uint256)'(
      user?: PromiseOrValue<string> | null,
      reward?: null,
    ): RewardCompoundedEventFilter;
    RewardCompounded(user?: PromiseOrValue<string> | null, reward?: null): RewardCompoundedEventFilter;

    'RewardPaid(address,address,uint256)'(
      token?: null,
      user?: PromiseOrValue<string> | null,
      reward?: null,
    ): RewardPaidEventFilter;
    RewardPaid(token?: null, user?: PromiseOrValue<string> | null, reward?: null): RewardPaidEventFilter;

    'RewardRemoved(address)'(token?: PromiseOrValue<string> | null): RewardRemovedEventFilter;
    RewardRemoved(token?: PromiseOrValue<string> | null): RewardRemovedEventFilter;

    'RewardUpdated(address,uint256,uint256,uint256,uint32)'(
      token?: PromiseOrValue<string> | null,
      amount?: null,
      leftover?: null,
      duration?: null,
      periodFinish?: null,
    ): RewardUpdatedEventFilter;
    RewardUpdated(
      token?: PromiseOrValue<string> | null,
      amount?: null,
      leftover?: null,
      duration?: null,
      periodFinish?: null,
    ): RewardUpdatedEventFilter;

    'Staked(address,uint256)'(user?: PromiseOrValue<string> | null, amount?: null): StakedEventFilter;
    Staked(user?: PromiseOrValue<string> | null, amount?: null): StakedEventFilter;

    'StakedFor(address,address,uint256)'(
      stakedFor?: PromiseOrValue<string> | null,
      stakedBy?: PromiseOrValue<string> | null,
      amount?: null,
    ): StakedForEventFilter;
    StakedFor(
      stakedFor?: PromiseOrValue<string> | null,
      stakedBy?: PromiseOrValue<string> | null,
      amount?: null,
    ): StakedForEventFilter;

    'Unstaked(address,uint256)'(user?: PromiseOrValue<string> | null, amount?: null): UnstakedEventFilter;
    Unstaked(user?: PromiseOrValue<string> | null, amount?: null): UnstakedEventFilter;

    'VoRewardCompounded(address,uint256)'(
      user?: PromiseOrValue<string> | null,
      reward?: null,
    ): VoRewardCompoundedEventFilter;
    VoRewardCompounded(user?: PromiseOrValue<string> | null, reward?: null): VoRewardCompoundedEventFilter;

    'VoSpoolRewardPaid(address,address,uint256)'(
      token?: null,
      user?: PromiseOrValue<string> | null,
      reward?: null,
    ): VoSpoolRewardPaidEventFilter;
    VoSpoolRewardPaid(token?: null, user?: PromiseOrValue<string> | null, reward?: null): VoSpoolRewardPaidEventFilter;
  };

  estimateGas: {
    addToken(
      token: PromiseOrValue<string>,
      rewardsDuration: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    allowUnstakeFor(
      allowFor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    balances(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    canStakeFor(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    compound(
      doCompoundVoSpoolRewards: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    earned(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getActiveRewards(
      doClaimVoSpoolRewards: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    getRewards(
      tokens: PromiseOrValue<string>[],
      doClaimVoSpoolRewards: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    getUpdatedVoSpoolRewardAmount(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    initialize(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    lastTimeRewardApplicable(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    notifyRewardAmount(
      token: PromiseOrValue<string>,
      _rewardsDuration: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    recoverERC20(
      tokenAddress: PromiseOrValue<string>,
      tokenAmount: PromiseOrValue<BigNumberish>,
      recoverTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    removeReward(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    rewardConfiguration(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    rewardDistributor(overrides?: CallOverrides): Promise<BigNumber>;

    rewardPerToken(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    rewardTokens(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    rewardTokensCount(overrides?: CallOverrides): Promise<BigNumber>;

    setCanStakeFor(
      account: PromiseOrValue<string>,
      _canStakeFor: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    stake(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    stakeFor(
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    stakedBy(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    stakingToken(overrides?: CallOverrides): Promise<BigNumber>;

    tokenBlacklist(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    totalStaked(overrides?: CallOverrides): Promise<BigNumber>;

    unstake(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updatePeriodFinish(
      token: PromiseOrValue<string>,
      timestamp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    voSpool(overrides?: CallOverrides): Promise<BigNumber>;

    voSpoolRewards(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    addToken(
      token: PromiseOrValue<string>,
      rewardsDuration: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    allowUnstakeFor(
      allowFor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    balances(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    canStakeFor(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    compound(
      doCompoundVoSpoolRewards: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    earned(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getActiveRewards(
      doClaimVoSpoolRewards: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    getRewards(
      tokens: PromiseOrValue<string>[],
      doClaimVoSpoolRewards: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    getUpdatedVoSpoolRewardAmount(
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    initialize(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    lastTimeRewardApplicable(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    notifyRewardAmount(
      token: PromiseOrValue<string>,
      _rewardsDuration: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    recoverERC20(
      tokenAddress: PromiseOrValue<string>,
      tokenAmount: PromiseOrValue<BigNumberish>,
      recoverTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    removeReward(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    rewardConfiguration(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardDistributor(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardPerToken(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardTokens(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardTokensCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setCanStakeFor(
      account: PromiseOrValue<string>,
      _canStakeFor: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    stake(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    stakeFor(
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    stakedBy(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    stakingToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokenBlacklist(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalStaked(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    unstake(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updatePeriodFinish(
      token: PromiseOrValue<string>,
      timestamp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    voSpool(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    voSpoolRewards(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}

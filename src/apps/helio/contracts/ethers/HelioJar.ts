/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export interface HelioJarInterface extends utils.Interface {
  functions: {
    'HAY()': FunctionFragment;
    'addOperator(address)': FunctionFragment;
    'balanceOf(address)': FunctionFragment;
    'cage()': FunctionFragment;
    'decimals()': FunctionFragment;
    'deny(address)': FunctionFragment;
    'earned(address)': FunctionFragment;
    'endTime()': FunctionFragment;
    'exit(uint256)': FunctionFragment;
    'exitDelay()': FunctionFragment;
    'extractDust()': FunctionFragment;
    'flashLoanDelay()': FunctionFragment;
    'initialize(string,string,address,uint256,uint256,uint256)': FunctionFragment;
    'join(uint256)': FunctionFragment;
    'lastTimeRewardApplicable()': FunctionFragment;
    'lastUpdate()': FunctionFragment;
    'live()': FunctionFragment;
    'name()': FunctionFragment;
    'operators(address)': FunctionFragment;
    'rate()': FunctionFragment;
    'redeemBatch(address[])': FunctionFragment;
    'rely(address)': FunctionFragment;
    'removeOperator(address)': FunctionFragment;
    'replenish(uint256,bool)': FunctionFragment;
    'rewards(address)': FunctionFragment;
    'setExitDelay(uint256)': FunctionFragment;
    'setSpread(uint256)': FunctionFragment;
    'spread()': FunctionFragment;
    'stakeTime(address)': FunctionFragment;
    'symbol()': FunctionFragment;
    'tokensPerShare()': FunctionFragment;
    'totalSupply()': FunctionFragment;
    'tps()': FunctionFragment;
    'tpsPaid(address)': FunctionFragment;
    'unstakeTime(address)': FunctionFragment;
    'wards(address)': FunctionFragment;
    'withdrawn(address)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'HAY'
      | 'addOperator'
      | 'balanceOf'
      | 'cage'
      | 'decimals'
      | 'deny'
      | 'earned'
      | 'endTime'
      | 'exit'
      | 'exitDelay'
      | 'extractDust'
      | 'flashLoanDelay'
      | 'initialize'
      | 'join'
      | 'lastTimeRewardApplicable'
      | 'lastUpdate'
      | 'live'
      | 'name'
      | 'operators'
      | 'rate'
      | 'redeemBatch'
      | 'rely'
      | 'removeOperator'
      | 'replenish'
      | 'rewards'
      | 'setExitDelay'
      | 'setSpread'
      | 'spread'
      | 'stakeTime'
      | 'symbol'
      | 'tokensPerShare'
      | 'totalSupply'
      | 'tps'
      | 'tpsPaid'
      | 'unstakeTime'
      | 'wards'
      | 'withdrawn',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'HAY', values?: undefined): string;
  encodeFunctionData(functionFragment: 'addOperator', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'balanceOf', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'cage', values?: undefined): string;
  encodeFunctionData(functionFragment: 'decimals', values?: undefined): string;
  encodeFunctionData(functionFragment: 'deny', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'earned', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'endTime', values?: undefined): string;
  encodeFunctionData(functionFragment: 'exit', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'exitDelay', values?: undefined): string;
  encodeFunctionData(functionFragment: 'extractDust', values?: undefined): string;
  encodeFunctionData(functionFragment: 'flashLoanDelay', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'initialize',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'join', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'lastTimeRewardApplicable', values?: undefined): string;
  encodeFunctionData(functionFragment: 'lastUpdate', values?: undefined): string;
  encodeFunctionData(functionFragment: 'live', values?: undefined): string;
  encodeFunctionData(functionFragment: 'name', values?: undefined): string;
  encodeFunctionData(functionFragment: 'operators', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'rate', values?: undefined): string;
  encodeFunctionData(functionFragment: 'redeemBatch', values: [PromiseOrValue<string>[]]): string;
  encodeFunctionData(functionFragment: 'rely', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'removeOperator', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'replenish',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'rewards', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setExitDelay', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setSpread', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'spread', values?: undefined): string;
  encodeFunctionData(functionFragment: 'stakeTime', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'symbol', values?: undefined): string;
  encodeFunctionData(functionFragment: 'tokensPerShare', values?: undefined): string;
  encodeFunctionData(functionFragment: 'totalSupply', values?: undefined): string;
  encodeFunctionData(functionFragment: 'tps', values?: undefined): string;
  encodeFunctionData(functionFragment: 'tpsPaid', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'unstakeTime', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'wards', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'withdrawn', values: [PromiseOrValue<string>]): string;

  decodeFunctionResult(functionFragment: 'HAY', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addOperator', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cage', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'decimals', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deny', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'earned', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'endTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exitDelay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'extractDust', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'flashLoanDelay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'join', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lastTimeRewardApplicable', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lastUpdate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'live', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'name', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'operators', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'redeemBatch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rely', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'removeOperator', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'replenish', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setExitDelay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setSpread', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'spread', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stakeTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'symbol', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tokensPerShare', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalSupply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tps', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tpsPaid', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'unstakeTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'wards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawn', data: BytesLike): Result;

  events: {
    'Cage()': EventFragment;
    'Exit(address,uint256)': EventFragment;
    'ExitDelayUpdated(uint256)': EventFragment;
    'Initialized(uint8)': EventFragment;
    'Join(address,uint256)': EventFragment;
    'OperatorSet(address)': EventFragment;
    'OperatorUnset(address)': EventFragment;
    'Redeem(address[])': EventFragment;
    'Replenished(uint256)': EventFragment;
    'SpreadUpdated(uint256)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'Cage'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Exit'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ExitDelayUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Initialized'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Join'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OperatorSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OperatorUnset'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Redeem'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Replenished'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SpreadUpdated'): EventFragment;
}

export interface CageEventObject {}
export type CageEvent = TypedEvent<[], CageEventObject>;

export type CageEventFilter = TypedEventFilter<CageEvent>;

export interface ExitEventObject {
  user: string;
  amount: BigNumber;
}
export type ExitEvent = TypedEvent<[string, BigNumber], ExitEventObject>;

export type ExitEventFilter = TypedEventFilter<ExitEvent>;

export interface ExitDelayUpdatedEventObject {
  exitDelay: BigNumber;
}
export type ExitDelayUpdatedEvent = TypedEvent<[BigNumber], ExitDelayUpdatedEventObject>;

export type ExitDelayUpdatedEventFilter = TypedEventFilter<ExitDelayUpdatedEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface JoinEventObject {
  user: string;
  amount: BigNumber;
}
export type JoinEvent = TypedEvent<[string, BigNumber], JoinEventObject>;

export type JoinEventFilter = TypedEventFilter<JoinEvent>;

export interface OperatorSetEventObject {
  operator: string;
}
export type OperatorSetEvent = TypedEvent<[string], OperatorSetEventObject>;

export type OperatorSetEventFilter = TypedEventFilter<OperatorSetEvent>;

export interface OperatorUnsetEventObject {
  operator: string;
}
export type OperatorUnsetEvent = TypedEvent<[string], OperatorUnsetEventObject>;

export type OperatorUnsetEventFilter = TypedEventFilter<OperatorUnsetEvent>;

export interface RedeemEventObject {
  user: string[];
}
export type RedeemEvent = TypedEvent<[string[]], RedeemEventObject>;

export type RedeemEventFilter = TypedEventFilter<RedeemEvent>;

export interface ReplenishedEventObject {
  reward: BigNumber;
}
export type ReplenishedEvent = TypedEvent<[BigNumber], ReplenishedEventObject>;

export type ReplenishedEventFilter = TypedEventFilter<ReplenishedEvent>;

export interface SpreadUpdatedEventObject {
  newDuration: BigNumber;
}
export type SpreadUpdatedEvent = TypedEvent<[BigNumber], SpreadUpdatedEventObject>;

export type SpreadUpdatedEventFilter = TypedEventFilter<SpreadUpdatedEvent>;

export interface HelioJar extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: HelioJarInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    HAY(overrides?: CallOverrides): Promise<[string]>;

    addOperator(
      _operator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    balanceOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    cage(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    decimals(overrides?: CallOverrides): Promise<[number]>;

    deny(
      guy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    earned(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    endTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    exit(
      wad: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    exitDelay(overrides?: CallOverrides): Promise<[BigNumber]>;

    extractDust(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    flashLoanDelay(overrides?: CallOverrides): Promise<[BigNumber]>;

    initialize(
      _name: PromiseOrValue<string>,
      _symbol: PromiseOrValue<string>,
      _hayToken: PromiseOrValue<string>,
      _spread: PromiseOrValue<BigNumberish>,
      _exitDelay: PromiseOrValue<BigNumberish>,
      _flashLoanDelay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    join(
      wad: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    lastTimeRewardApplicable(overrides?: CallOverrides): Promise<[BigNumber]>;

    lastUpdate(overrides?: CallOverrides): Promise<[BigNumber]>;

    live(overrides?: CallOverrides): Promise<[BigNumber]>;

    name(overrides?: CallOverrides): Promise<[string]>;

    operators(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    rate(overrides?: CallOverrides): Promise<[BigNumber]>;

    redeemBatch(
      accounts: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    rely(
      guy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    removeOperator(
      _operator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    replenish(
      wad: PromiseOrValue<BigNumberish>,
      newSpread: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    rewards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    setExitDelay(
      _exitDelay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setSpread(
      _spread: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    spread(overrides?: CallOverrides): Promise<[BigNumber]>;

    stakeTime(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    symbol(overrides?: CallOverrides): Promise<[string]>;

    tokensPerShare(overrides?: CallOverrides): Promise<[BigNumber]>;

    totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    tps(overrides?: CallOverrides): Promise<[BigNumber]>;

    tpsPaid(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    unstakeTime(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    wards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    withdrawn(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;
  };

  HAY(overrides?: CallOverrides): Promise<string>;

  addOperator(
    _operator: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  balanceOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  cage(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  decimals(overrides?: CallOverrides): Promise<number>;

  deny(
    guy: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  earned(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  endTime(overrides?: CallOverrides): Promise<BigNumber>;

  exit(
    wad: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  exitDelay(overrides?: CallOverrides): Promise<BigNumber>;

  extractDust(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  flashLoanDelay(overrides?: CallOverrides): Promise<BigNumber>;

  initialize(
    _name: PromiseOrValue<string>,
    _symbol: PromiseOrValue<string>,
    _hayToken: PromiseOrValue<string>,
    _spread: PromiseOrValue<BigNumberish>,
    _exitDelay: PromiseOrValue<BigNumberish>,
    _flashLoanDelay: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  join(
    wad: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  lastTimeRewardApplicable(overrides?: CallOverrides): Promise<BigNumber>;

  lastUpdate(overrides?: CallOverrides): Promise<BigNumber>;

  live(overrides?: CallOverrides): Promise<BigNumber>;

  name(overrides?: CallOverrides): Promise<string>;

  operators(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  rate(overrides?: CallOverrides): Promise<BigNumber>;

  redeemBatch(
    accounts: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  rely(
    guy: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  removeOperator(
    _operator: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  replenish(
    wad: PromiseOrValue<BigNumberish>,
    newSpread: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  rewards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  setExitDelay(
    _exitDelay: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setSpread(
    _spread: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  spread(overrides?: CallOverrides): Promise<BigNumber>;

  stakeTime(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  symbol(overrides?: CallOverrides): Promise<string>;

  tokensPerShare(overrides?: CallOverrides): Promise<BigNumber>;

  totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  tps(overrides?: CallOverrides): Promise<BigNumber>;

  tpsPaid(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  unstakeTime(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  wards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  withdrawn(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  callStatic: {
    HAY(overrides?: CallOverrides): Promise<string>;

    addOperator(_operator: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    balanceOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    cage(overrides?: CallOverrides): Promise<void>;

    decimals(overrides?: CallOverrides): Promise<number>;

    deny(guy: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    earned(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    endTime(overrides?: CallOverrides): Promise<BigNumber>;

    exit(wad: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    exitDelay(overrides?: CallOverrides): Promise<BigNumber>;

    extractDust(overrides?: CallOverrides): Promise<void>;

    flashLoanDelay(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      _name: PromiseOrValue<string>,
      _symbol: PromiseOrValue<string>,
      _hayToken: PromiseOrValue<string>,
      _spread: PromiseOrValue<BigNumberish>,
      _exitDelay: PromiseOrValue<BigNumberish>,
      _flashLoanDelay: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    join(wad: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    lastTimeRewardApplicable(overrides?: CallOverrides): Promise<BigNumber>;

    lastUpdate(overrides?: CallOverrides): Promise<BigNumber>;

    live(overrides?: CallOverrides): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<string>;

    operators(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    rate(overrides?: CallOverrides): Promise<BigNumber>;

    redeemBatch(accounts: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;

    rely(guy: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    removeOperator(_operator: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    replenish(
      wad: PromiseOrValue<BigNumberish>,
      newSpread: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    rewards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    setExitDelay(_exitDelay: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setSpread(_spread: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    spread(overrides?: CallOverrides): Promise<BigNumber>;

    stakeTime(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    symbol(overrides?: CallOverrides): Promise<string>;

    tokensPerShare(overrides?: CallOverrides): Promise<BigNumber>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    tps(overrides?: CallOverrides): Promise<BigNumber>;

    tpsPaid(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    unstakeTime(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    wards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    withdrawn(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
  };

  filters: {
    'Cage()'(): CageEventFilter;
    Cage(): CageEventFilter;

    'Exit(address,uint256)'(
      user?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null,
    ): ExitEventFilter;
    Exit(user?: PromiseOrValue<string> | null, amount?: PromiseOrValue<BigNumberish> | null): ExitEventFilter;

    'ExitDelayUpdated(uint256)'(exitDelay?: null): ExitDelayUpdatedEventFilter;
    ExitDelayUpdated(exitDelay?: null): ExitDelayUpdatedEventFilter;

    'Initialized(uint8)'(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    'Join(address,uint256)'(
      user?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null,
    ): JoinEventFilter;
    Join(user?: PromiseOrValue<string> | null, amount?: PromiseOrValue<BigNumberish> | null): JoinEventFilter;

    'OperatorSet(address)'(operator?: null): OperatorSetEventFilter;
    OperatorSet(operator?: null): OperatorSetEventFilter;

    'OperatorUnset(address)'(operator?: null): OperatorUnsetEventFilter;
    OperatorUnset(operator?: null): OperatorUnsetEventFilter;

    'Redeem(address[])'(user?: PromiseOrValue<string>[] | null): RedeemEventFilter;
    Redeem(user?: PromiseOrValue<string>[] | null): RedeemEventFilter;

    'Replenished(uint256)'(reward?: null): ReplenishedEventFilter;
    Replenished(reward?: null): ReplenishedEventFilter;

    'SpreadUpdated(uint256)'(newDuration?: null): SpreadUpdatedEventFilter;
    SpreadUpdated(newDuration?: null): SpreadUpdatedEventFilter;
  };

  estimateGas: {
    HAY(overrides?: CallOverrides): Promise<BigNumber>;

    addOperator(
      _operator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    balanceOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    cage(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    decimals(overrides?: CallOverrides): Promise<BigNumber>;

    deny(guy: PromiseOrValue<string>, overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    earned(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    endTime(overrides?: CallOverrides): Promise<BigNumber>;

    exit(
      wad: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    exitDelay(overrides?: CallOverrides): Promise<BigNumber>;

    extractDust(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    flashLoanDelay(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      _name: PromiseOrValue<string>,
      _symbol: PromiseOrValue<string>,
      _hayToken: PromiseOrValue<string>,
      _spread: PromiseOrValue<BigNumberish>,
      _exitDelay: PromiseOrValue<BigNumberish>,
      _flashLoanDelay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    join(
      wad: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    lastTimeRewardApplicable(overrides?: CallOverrides): Promise<BigNumber>;

    lastUpdate(overrides?: CallOverrides): Promise<BigNumber>;

    live(overrides?: CallOverrides): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    operators(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    rate(overrides?: CallOverrides): Promise<BigNumber>;

    redeemBatch(
      accounts: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    rely(guy: PromiseOrValue<string>, overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    removeOperator(
      _operator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    replenish(
      wad: PromiseOrValue<BigNumberish>,
      newSpread: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    rewards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    setExitDelay(
      _exitDelay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setSpread(
      _spread: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    spread(overrides?: CallOverrides): Promise<BigNumber>;

    stakeTime(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    symbol(overrides?: CallOverrides): Promise<BigNumber>;

    tokensPerShare(overrides?: CallOverrides): Promise<BigNumber>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    tps(overrides?: CallOverrides): Promise<BigNumber>;

    tpsPaid(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    unstakeTime(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    wards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    withdrawn(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    HAY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    addOperator(
      _operator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    balanceOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    cage(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    deny(
      guy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    earned(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    endTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    exit(
      wad: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    exitDelay(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    extractDust(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    flashLoanDelay(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initialize(
      _name: PromiseOrValue<string>,
      _symbol: PromiseOrValue<string>,
      _hayToken: PromiseOrValue<string>,
      _spread: PromiseOrValue<BigNumberish>,
      _exitDelay: PromiseOrValue<BigNumberish>,
      _flashLoanDelay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    join(
      wad: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    lastTimeRewardApplicable(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastUpdate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    live(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    operators(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    redeemBatch(
      accounts: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    rely(
      guy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    removeOperator(
      _operator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    replenish(
      wad: PromiseOrValue<BigNumberish>,
      newSpread: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    rewards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setExitDelay(
      _exitDelay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setSpread(
      _spread: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    spread(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    stakeTime(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokensPerShare(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tps(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tpsPaid(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    unstakeTime(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    wards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdrawn(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export declare namespace IYamato {
  export type FlashLockDataStruct = {
    lockedBlockHeight: PromiseOrValue<BigNumberish>;
  };

  export type FlashLockDataStructOutput = [BigNumber] & {
    lockedBlockHeight: BigNumber;
  };

  export type PledgeStruct = {
    coll: PromiseOrValue<BigNumberish>;
    debt: PromiseOrValue<BigNumberish>;
    isCreated: PromiseOrValue<boolean>;
    owner: PromiseOrValue<string>;
    priority: PromiseOrValue<BigNumberish>;
  };

  export type PledgeStructOutput = [BigNumber, BigNumber, boolean, string, BigNumber] & {
    coll: BigNumber;
    debt: BigNumber;
    isCreated: boolean;
    owner: string;
    priority: BigNumber;
  };
}

export interface YamatoInterface extends utils.Interface {
  functions: {
    'CHECKPOINT_BUFFER()': FunctionFragment;
    'GRR()': FunctionFragment;
    'MCR()': FunctionFragment;
    'RRR()': FunctionFragment;
    'SRR()': FunctionFragment;
    'acceptGovernance()': FunctionFragment;
    'borrow(uint256)': FunctionFragment;
    'borrower()': FunctionFragment;
    'checkFlashLock(address)': FunctionFragment;
    'collFloor()': FunctionFragment;
    'currencyOS()': FunctionFragment;
    'deposit()': FunctionFragment;
    'depositor()': FunctionFragment;
    'feePool()': FunctionFragment;
    'getDeps()': FunctionFragment;
    'getImplementation()': FunctionFragment;
    'getIndividualStates(address)': FunctionFragment;
    'getPledge(address)': FunctionFragment;
    'getStates()': FunctionFragment;
    'governance()': FunctionFragment;
    'initialize(address)': FunctionFragment;
    'maxRedeemableCount()': FunctionFragment;
    'paused()': FunctionFragment;
    'pendingGovernance()': FunctionFragment;
    'permitDeps(address)': FunctionFragment;
    'pool()': FunctionFragment;
    'priceFeed()': FunctionFragment;
    'priorityRegistry()': FunctionFragment;
    'proxiableUUID()': FunctionFragment;
    'redeem(uint256,bool)': FunctionFragment;
    'redeemer()': FunctionFragment;
    'repay(uint256)': FunctionFragment;
    'repayer()': FunctionFragment;
    'revokeGovernance()': FunctionFragment;
    'revokeTester()': FunctionFragment;
    'setDeps(address,address,address,address,address,address,address,address)': FunctionFragment;
    'setFlashLock(address)': FunctionFragment;
    'setGovernance(address)': FunctionFragment;
    'setPledge(address,(uint256,uint256,bool,address,uint256))': FunctionFragment;
    'setPledges((uint256,uint256,bool,address,uint256)[])': FunctionFragment;
    'setPriorityRegistry(address)': FunctionFragment;
    'setTotalColl(uint256)': FunctionFragment;
    'setTotalDebt(uint256)': FunctionFragment;
    'sweep()': FunctionFragment;
    'sweeper()': FunctionFragment;
    'tester()': FunctionFragment;
    'toggle()': FunctionFragment;
    'upgradeTo(address)': FunctionFragment;
    'upgradeToAndCall(address,bytes)': FunctionFragment;
    'withdraw(uint256)': FunctionFragment;
    'withdrawer()': FunctionFragment;
    'yamato()': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'CHECKPOINT_BUFFER'
      | 'GRR'
      | 'MCR'
      | 'RRR'
      | 'SRR'
      | 'acceptGovernance'
      | 'borrow'
      | 'borrower'
      | 'checkFlashLock'
      | 'collFloor'
      | 'currencyOS'
      | 'deposit'
      | 'depositor'
      | 'feePool'
      | 'getDeps'
      | 'getImplementation'
      | 'getIndividualStates'
      | 'getPledge'
      | 'getStates'
      | 'governance'
      | 'initialize'
      | 'maxRedeemableCount'
      | 'paused'
      | 'pendingGovernance'
      | 'permitDeps'
      | 'pool'
      | 'priceFeed'
      | 'priorityRegistry'
      | 'proxiableUUID'
      | 'redeem'
      | 'redeemer'
      | 'repay'
      | 'repayer'
      | 'revokeGovernance'
      | 'revokeTester'
      | 'setDeps'
      | 'setFlashLock'
      | 'setGovernance'
      | 'setPledge'
      | 'setPledges'
      | 'setPriorityRegistry'
      | 'setTotalColl'
      | 'setTotalDebt'
      | 'sweep'
      | 'sweeper'
      | 'tester'
      | 'toggle'
      | 'upgradeTo'
      | 'upgradeToAndCall'
      | 'withdraw'
      | 'withdrawer'
      | 'yamato',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'CHECKPOINT_BUFFER', values?: undefined): string;
  encodeFunctionData(functionFragment: 'GRR', values?: undefined): string;
  encodeFunctionData(functionFragment: 'MCR', values?: undefined): string;
  encodeFunctionData(functionFragment: 'RRR', values?: undefined): string;
  encodeFunctionData(functionFragment: 'SRR', values?: undefined): string;
  encodeFunctionData(functionFragment: 'acceptGovernance', values?: undefined): string;
  encodeFunctionData(functionFragment: 'borrow', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'borrower', values?: undefined): string;
  encodeFunctionData(functionFragment: 'checkFlashLock', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'collFloor', values?: undefined): string;
  encodeFunctionData(functionFragment: 'currencyOS', values?: undefined): string;
  encodeFunctionData(functionFragment: 'deposit', values?: undefined): string;
  encodeFunctionData(functionFragment: 'depositor', values?: undefined): string;
  encodeFunctionData(functionFragment: 'feePool', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getDeps', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getImplementation', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getIndividualStates', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getPledge', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getStates', values?: undefined): string;
  encodeFunctionData(functionFragment: 'governance', values?: undefined): string;
  encodeFunctionData(functionFragment: 'initialize', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'maxRedeemableCount', values?: undefined): string;
  encodeFunctionData(functionFragment: 'paused', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pendingGovernance', values?: undefined): string;
  encodeFunctionData(functionFragment: 'permitDeps', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'pool', values?: undefined): string;
  encodeFunctionData(functionFragment: 'priceFeed', values?: undefined): string;
  encodeFunctionData(functionFragment: 'priorityRegistry', values?: undefined): string;
  encodeFunctionData(functionFragment: 'proxiableUUID', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'redeem',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'redeemer', values?: undefined): string;
  encodeFunctionData(functionFragment: 'repay', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'repayer', values?: undefined): string;
  encodeFunctionData(functionFragment: 'revokeGovernance', values?: undefined): string;
  encodeFunctionData(functionFragment: 'revokeTester', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'setDeps',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'setFlashLock', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setGovernance', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setPledge', values: [PromiseOrValue<string>, IYamato.PledgeStruct]): string;
  encodeFunctionData(functionFragment: 'setPledges', values: [IYamato.PledgeStruct[]]): string;
  encodeFunctionData(functionFragment: 'setPriorityRegistry', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setTotalColl', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setTotalDebt', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'sweep', values?: undefined): string;
  encodeFunctionData(functionFragment: 'sweeper', values?: undefined): string;
  encodeFunctionData(functionFragment: 'tester', values?: undefined): string;
  encodeFunctionData(functionFragment: 'toggle', values?: undefined): string;
  encodeFunctionData(functionFragment: 'upgradeTo', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'upgradeToAndCall',
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(functionFragment: 'withdraw', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'withdrawer', values?: undefined): string;
  encodeFunctionData(functionFragment: 'yamato', values?: undefined): string;

  decodeFunctionResult(functionFragment: 'CHECKPOINT_BUFFER', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'GRR', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'MCR', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'RRR', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'SRR', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'acceptGovernance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'borrow', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'borrower', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'checkFlashLock', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'collFloor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'currencyOS', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'depositor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'feePool', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getDeps', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getImplementation', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getIndividualStates', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPledge', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getStates', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'governance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'maxRedeemableCount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'paused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pendingGovernance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'permitDeps', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pool', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'priceFeed', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'priorityRegistry', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'proxiableUUID', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'redeem', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'redeemer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'repay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'repayer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'revokeGovernance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'revokeTester', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setDeps', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setFlashLock', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setGovernance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setPledge', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setPledges', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setPriorityRegistry', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setTotalColl', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setTotalDebt', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'sweep', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'sweeper', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tester', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'toggle', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'upgradeTo', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'upgradeToAndCall', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'yamato', data: BytesLike): Result;

  events: {
    'AdminChanged(address,address)': EventFragment;
    'BeaconUpgraded(address)': EventFragment;
    'Borrowed(address,uint256,uint256)': EventFragment;
    'Deposited(address,uint256)': EventFragment;
    'Initialized(uint8)': EventFragment;
    'NewPendingGovernance(address)': EventFragment;
    'Paused(address)': EventFragment;
    'Redeemed(address,uint256,uint256,address[])': EventFragment;
    'RedeemedMeta(address,uint256,bool,uint256)': EventFragment;
    'Repaid(address,uint256)': EventFragment;
    'RevokeGovernance(address)': EventFragment;
    'Swept(address,uint256,uint256,address[])': EventFragment;
    'Unpaused(address)': EventFragment;
    'UpdateGovernance(address)': EventFragment;
    'Upgraded(address)': EventFragment;
    'Withdrawn(address,uint256)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'AdminChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'BeaconUpgraded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Borrowed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Deposited'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Initialized'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NewPendingGovernance'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Paused'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Redeemed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RedeemedMeta'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Repaid'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RevokeGovernance'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Swept'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Unpaused'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'UpdateGovernance'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Upgraded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Withdrawn'): EventFragment;
}

export interface AdminChangedEventObject {
  previousAdmin: string;
  newAdmin: string;
}
export type AdminChangedEvent = TypedEvent<[string, string], AdminChangedEventObject>;

export type AdminChangedEventFilter = TypedEventFilter<AdminChangedEvent>;

export interface BeaconUpgradedEventObject {
  beacon: string;
}
export type BeaconUpgradedEvent = TypedEvent<[string], BeaconUpgradedEventObject>;

export type BeaconUpgradedEventFilter = TypedEventFilter<BeaconUpgradedEvent>;

export interface BorrowedEventObject {
  sender: string;
  currencyAmount: BigNumber;
  fee: BigNumber;
}
export type BorrowedEvent = TypedEvent<[string, BigNumber, BigNumber], BorrowedEventObject>;

export type BorrowedEventFilter = TypedEventFilter<BorrowedEvent>;

export interface DepositedEventObject {
  sender: string;
  ethAmount: BigNumber;
}
export type DepositedEvent = TypedEvent<[string, BigNumber], DepositedEventObject>;

export type DepositedEventFilter = TypedEventFilter<DepositedEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface NewPendingGovernanceEventObject {
  _sender: string;
}
export type NewPendingGovernanceEvent = TypedEvent<[string], NewPendingGovernanceEventObject>;

export type NewPendingGovernanceEventFilter = TypedEventFilter<NewPendingGovernanceEvent>;

export interface PausedEventObject {
  account: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface RedeemedEventObject {
  sender: string;
  currencyAmount: BigNumber;
  ethAmount: BigNumber;
  pledgesOwner: string[];
}
export type RedeemedEvent = TypedEvent<[string, BigNumber, BigNumber, string[]], RedeemedEventObject>;

export type RedeemedEventFilter = TypedEventFilter<RedeemedEvent>;

export interface RedeemedMetaEventObject {
  sender: string;
  price: BigNumber;
  isCoreRedemption: boolean;
  gasCompensationAmount: BigNumber;
}
export type RedeemedMetaEvent = TypedEvent<[string, BigNumber, boolean, BigNumber], RedeemedMetaEventObject>;

export type RedeemedMetaEventFilter = TypedEventFilter<RedeemedMetaEvent>;

export interface RepaidEventObject {
  sender: string;
  currencyAmount: BigNumber;
}
export type RepaidEvent = TypedEvent<[string, BigNumber], RepaidEventObject>;

export type RepaidEventFilter = TypedEventFilter<RepaidEvent>;

export interface RevokeGovernanceEventObject {
  _sender: string;
}
export type RevokeGovernanceEvent = TypedEvent<[string], RevokeGovernanceEventObject>;

export type RevokeGovernanceEventFilter = TypedEventFilter<RevokeGovernanceEvent>;

export interface SweptEventObject {
  sender: string;
  currencyAmount: BigNumber;
  gasCompensationAmount: BigNumber;
  pledgesOwner: string[];
}
export type SweptEvent = TypedEvent<[string, BigNumber, BigNumber, string[]], SweptEventObject>;

export type SweptEventFilter = TypedEventFilter<SweptEvent>;

export interface UnpausedEventObject {
  account: string;
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface UpdateGovernanceEventObject {
  _sender: string;
}
export type UpdateGovernanceEvent = TypedEvent<[string], UpdateGovernanceEventObject>;

export type UpdateGovernanceEventFilter = TypedEventFilter<UpdateGovernanceEvent>;

export interface UpgradedEventObject {
  implementation: string;
}
export type UpgradedEvent = TypedEvent<[string], UpgradedEventObject>;

export type UpgradedEventFilter = TypedEventFilter<UpgradedEvent>;

export interface WithdrawnEventObject {
  sender: string;
  ethAmount: BigNumber;
}
export type WithdrawnEvent = TypedEvent<[string, BigNumber], WithdrawnEventObject>;

export type WithdrawnEventFilter = TypedEventFilter<WithdrawnEvent>;

export interface Yamato extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: YamatoInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    CHECKPOINT_BUFFER(overrides?: CallOverrides): Promise<[BigNumber]>;

    GRR(overrides?: CallOverrides): Promise<[number]>;

    MCR(overrides?: CallOverrides): Promise<[number]>;

    RRR(overrides?: CallOverrides): Promise<[number]>;

    SRR(overrides?: CallOverrides): Promise<[number]>;

    acceptGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    borrow(
      borrowAmountInCurrency: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    borrower(overrides?: CallOverrides): Promise<[string] & { _borrower: string }>;

    checkFlashLock(
      _owner: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean] & { _isLocked: boolean }>;

    collFloor(overrides?: CallOverrides): Promise<[BigNumber]>;

    currencyOS(overrides?: CallOverrides): Promise<[string] & { _currencyOS: string }>;

    deposit(overrides?: PayableOverrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    depositor(overrides?: CallOverrides): Promise<[string] & { _depositor: string }>;

    feePool(overrides?: CallOverrides): Promise<[string]>;

    getDeps(overrides?: CallOverrides): Promise<[string[]]>;

    getImplementation(overrides?: CallOverrides): Promise<[string]>;

    getIndividualStates(
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, boolean, IYamato.FlashLockDataStructOutput] & {
        coll: BigNumber;
        debt: BigNumber;
        isCreated: boolean;
        lock: IYamato.FlashLockDataStructOutput;
      }
    >;

    getPledge(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[IYamato.PledgeStructOutput]>;

    getStates(overrides?: CallOverrides): Promise<[BigNumber, BigNumber, number, number, number, number]>;

    governance(overrides?: CallOverrides): Promise<[string]>;

    initialize(
      _currencyOS: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    maxRedeemableCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    pendingGovernance(overrides?: CallOverrides): Promise<[string]>;

    permitDeps(_sender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    pool(overrides?: CallOverrides): Promise<[string] & { _pool: string }>;

    priceFeed(overrides?: CallOverrides): Promise<[string]>;

    priorityRegistry(overrides?: CallOverrides): Promise<[string] & { _priorityRegistry: string }>;

    proxiableUUID(overrides?: CallOverrides): Promise<[string]>;

    redeem(
      maxRedemptionCurrencyAmount: PromiseOrValue<BigNumberish>,
      isCoreRedemption: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    redeemer(overrides?: CallOverrides): Promise<[string] & { _redeemer: string }>;

    repay(
      currencyAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    repayer(overrides?: CallOverrides): Promise<[string] & { _repayer: string }>;

    revokeGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    revokeTester(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    setDeps(
      _yamatoDepositor: PromiseOrValue<string>,
      _yamatoBorrower: PromiseOrValue<string>,
      _yamatoRepayer: PromiseOrValue<string>,
      _yamatoWithdrawer: PromiseOrValue<string>,
      _yamatoRedeemer: PromiseOrValue<string>,
      _yamatoSweeper: PromiseOrValue<string>,
      _pool: PromiseOrValue<string>,
      _priorityRegistry: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setFlashLock(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setGovernance(
      _newGoverner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setPledge(
      _owner: PromiseOrValue<string>,
      _p: IYamato.PledgeStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setPledges(
      _pledges: IYamato.PledgeStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setPriorityRegistry(
      _priorityRegistry: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setTotalColl(
      _totalColl: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setTotalDebt(
      _totalDebt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    sweep(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    sweeper(overrides?: CallOverrides): Promise<[string] & { _sweeper: string }>;

    tester(overrides?: CallOverrides): Promise<[string]>;

    toggle(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    withdraw(
      ethAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    withdrawer(overrides?: CallOverrides): Promise<[string] & { _withdrawer: string }>;

    yamato(overrides?: CallOverrides): Promise<[string]>;
  };

  CHECKPOINT_BUFFER(overrides?: CallOverrides): Promise<BigNumber>;

  GRR(overrides?: CallOverrides): Promise<number>;

  MCR(overrides?: CallOverrides): Promise<number>;

  RRR(overrides?: CallOverrides): Promise<number>;

  SRR(overrides?: CallOverrides): Promise<number>;

  acceptGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  borrow(
    borrowAmountInCurrency: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  borrower(overrides?: CallOverrides): Promise<string>;

  checkFlashLock(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  collFloor(overrides?: CallOverrides): Promise<BigNumber>;

  currencyOS(overrides?: CallOverrides): Promise<string>;

  deposit(overrides?: PayableOverrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  depositor(overrides?: CallOverrides): Promise<string>;

  feePool(overrides?: CallOverrides): Promise<string>;

  getDeps(overrides?: CallOverrides): Promise<string[]>;

  getImplementation(overrides?: CallOverrides): Promise<string>;

  getIndividualStates(
    owner: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, boolean, IYamato.FlashLockDataStructOutput] & {
      coll: BigNumber;
      debt: BigNumber;
      isCreated: boolean;
      lock: IYamato.FlashLockDataStructOutput;
    }
  >;

  getPledge(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<IYamato.PledgeStructOutput>;

  getStates(overrides?: CallOverrides): Promise<[BigNumber, BigNumber, number, number, number, number]>;

  governance(overrides?: CallOverrides): Promise<string>;

  initialize(
    _currencyOS: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  maxRedeemableCount(overrides?: CallOverrides): Promise<BigNumber>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  pendingGovernance(overrides?: CallOverrides): Promise<string>;

  permitDeps(_sender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  pool(overrides?: CallOverrides): Promise<string>;

  priceFeed(overrides?: CallOverrides): Promise<string>;

  priorityRegistry(overrides?: CallOverrides): Promise<string>;

  proxiableUUID(overrides?: CallOverrides): Promise<string>;

  redeem(
    maxRedemptionCurrencyAmount: PromiseOrValue<BigNumberish>,
    isCoreRedemption: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  redeemer(overrides?: CallOverrides): Promise<string>;

  repay(
    currencyAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  repayer(overrides?: CallOverrides): Promise<string>;

  revokeGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  revokeTester(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  setDeps(
    _yamatoDepositor: PromiseOrValue<string>,
    _yamatoBorrower: PromiseOrValue<string>,
    _yamatoRepayer: PromiseOrValue<string>,
    _yamatoWithdrawer: PromiseOrValue<string>,
    _yamatoRedeemer: PromiseOrValue<string>,
    _yamatoSweeper: PromiseOrValue<string>,
    _pool: PromiseOrValue<string>,
    _priorityRegistry: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setFlashLock(
    _owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setGovernance(
    _newGoverner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setPledge(
    _owner: PromiseOrValue<string>,
    _p: IYamato.PledgeStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setPledges(
    _pledges: IYamato.PledgeStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setPriorityRegistry(
    _priorityRegistry: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setTotalColl(
    _totalColl: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setTotalDebt(
    _totalDebt: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  sweep(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  sweeper(overrides?: CallOverrides): Promise<string>;

  tester(overrides?: CallOverrides): Promise<string>;

  toggle(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  upgradeTo(
    newImplementation: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  upgradeToAndCall(
    newImplementation: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  withdraw(
    ethAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  withdrawer(overrides?: CallOverrides): Promise<string>;

  yamato(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    CHECKPOINT_BUFFER(overrides?: CallOverrides): Promise<BigNumber>;

    GRR(overrides?: CallOverrides): Promise<number>;

    MCR(overrides?: CallOverrides): Promise<number>;

    RRR(overrides?: CallOverrides): Promise<number>;

    SRR(overrides?: CallOverrides): Promise<number>;

    acceptGovernance(overrides?: CallOverrides): Promise<void>;

    borrow(borrowAmountInCurrency: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    borrower(overrides?: CallOverrides): Promise<string>;

    checkFlashLock(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    collFloor(overrides?: CallOverrides): Promise<BigNumber>;

    currencyOS(overrides?: CallOverrides): Promise<string>;

    deposit(overrides?: CallOverrides): Promise<void>;

    depositor(overrides?: CallOverrides): Promise<string>;

    feePool(overrides?: CallOverrides): Promise<string>;

    getDeps(overrides?: CallOverrides): Promise<string[]>;

    getImplementation(overrides?: CallOverrides): Promise<string>;

    getIndividualStates(
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, boolean, IYamato.FlashLockDataStructOutput] & {
        coll: BigNumber;
        debt: BigNumber;
        isCreated: boolean;
        lock: IYamato.FlashLockDataStructOutput;
      }
    >;

    getPledge(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<IYamato.PledgeStructOutput>;

    getStates(overrides?: CallOverrides): Promise<[BigNumber, BigNumber, number, number, number, number]>;

    governance(overrides?: CallOverrides): Promise<string>;

    initialize(_currencyOS: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    maxRedeemableCount(overrides?: CallOverrides): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    pendingGovernance(overrides?: CallOverrides): Promise<string>;

    permitDeps(_sender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    pool(overrides?: CallOverrides): Promise<string>;

    priceFeed(overrides?: CallOverrides): Promise<string>;

    priorityRegistry(overrides?: CallOverrides): Promise<string>;

    proxiableUUID(overrides?: CallOverrides): Promise<string>;

    redeem(
      maxRedemptionCurrencyAmount: PromiseOrValue<BigNumberish>,
      isCoreRedemption: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    redeemer(overrides?: CallOverrides): Promise<string>;

    repay(currencyAmount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    repayer(overrides?: CallOverrides): Promise<string>;

    revokeGovernance(overrides?: CallOverrides): Promise<void>;

    revokeTester(overrides?: CallOverrides): Promise<void>;

    setDeps(
      _yamatoDepositor: PromiseOrValue<string>,
      _yamatoBorrower: PromiseOrValue<string>,
      _yamatoRepayer: PromiseOrValue<string>,
      _yamatoWithdrawer: PromiseOrValue<string>,
      _yamatoRedeemer: PromiseOrValue<string>,
      _yamatoSweeper: PromiseOrValue<string>,
      _pool: PromiseOrValue<string>,
      _priorityRegistry: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setFlashLock(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setGovernance(_newGoverner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setPledge(_owner: PromiseOrValue<string>, _p: IYamato.PledgeStruct, overrides?: CallOverrides): Promise<void>;

    setPledges(_pledges: IYamato.PledgeStruct[], overrides?: CallOverrides): Promise<void>;

    setPriorityRegistry(_priorityRegistry: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setTotalColl(_totalColl: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setTotalDebt(_totalDebt: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    sweep(overrides?: CallOverrides): Promise<void>;

    sweeper(overrides?: CallOverrides): Promise<string>;

    tester(overrides?: CallOverrides): Promise<string>;

    toggle(overrides?: CallOverrides): Promise<void>;

    upgradeTo(newImplementation: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    withdraw(ethAmount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    withdrawer(overrides?: CallOverrides): Promise<string>;

    yamato(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    'AdminChanged(address,address)'(previousAdmin?: null, newAdmin?: null): AdminChangedEventFilter;
    AdminChanged(previousAdmin?: null, newAdmin?: null): AdminChangedEventFilter;

    'BeaconUpgraded(address)'(beacon?: PromiseOrValue<string> | null): BeaconUpgradedEventFilter;
    BeaconUpgraded(beacon?: PromiseOrValue<string> | null): BeaconUpgradedEventFilter;

    'Borrowed(address,uint256,uint256)'(
      sender?: PromiseOrValue<string> | null,
      currencyAmount?: null,
      fee?: null,
    ): BorrowedEventFilter;
    Borrowed(sender?: PromiseOrValue<string> | null, currencyAmount?: null, fee?: null): BorrowedEventFilter;

    'Deposited(address,uint256)'(sender?: PromiseOrValue<string> | null, ethAmount?: null): DepositedEventFilter;
    Deposited(sender?: PromiseOrValue<string> | null, ethAmount?: null): DepositedEventFilter;

    'Initialized(uint8)'(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    'NewPendingGovernance(address)'(_sender?: null): NewPendingGovernanceEventFilter;
    NewPendingGovernance(_sender?: null): NewPendingGovernanceEventFilter;

    'Paused(address)'(account?: null): PausedEventFilter;
    Paused(account?: null): PausedEventFilter;

    'Redeemed(address,uint256,uint256,address[])'(
      sender?: PromiseOrValue<string> | null,
      currencyAmount?: null,
      ethAmount?: null,
      pledgesOwner?: null,
    ): RedeemedEventFilter;
    Redeemed(
      sender?: PromiseOrValue<string> | null,
      currencyAmount?: null,
      ethAmount?: null,
      pledgesOwner?: null,
    ): RedeemedEventFilter;

    'RedeemedMeta(address,uint256,bool,uint256)'(
      sender?: PromiseOrValue<string> | null,
      price?: null,
      isCoreRedemption?: null,
      gasCompensationAmount?: null,
    ): RedeemedMetaEventFilter;
    RedeemedMeta(
      sender?: PromiseOrValue<string> | null,
      price?: null,
      isCoreRedemption?: null,
      gasCompensationAmount?: null,
    ): RedeemedMetaEventFilter;

    'Repaid(address,uint256)'(sender?: PromiseOrValue<string> | null, currencyAmount?: null): RepaidEventFilter;
    Repaid(sender?: PromiseOrValue<string> | null, currencyAmount?: null): RepaidEventFilter;

    'RevokeGovernance(address)'(_sender?: null): RevokeGovernanceEventFilter;
    RevokeGovernance(_sender?: null): RevokeGovernanceEventFilter;

    'Swept(address,uint256,uint256,address[])'(
      sender?: PromiseOrValue<string> | null,
      currencyAmount?: null,
      gasCompensationAmount?: null,
      pledgesOwner?: null,
    ): SweptEventFilter;
    Swept(
      sender?: PromiseOrValue<string> | null,
      currencyAmount?: null,
      gasCompensationAmount?: null,
      pledgesOwner?: null,
    ): SweptEventFilter;

    'Unpaused(address)'(account?: null): UnpausedEventFilter;
    Unpaused(account?: null): UnpausedEventFilter;

    'UpdateGovernance(address)'(_sender?: null): UpdateGovernanceEventFilter;
    UpdateGovernance(_sender?: null): UpdateGovernanceEventFilter;

    'Upgraded(address)'(implementation?: PromiseOrValue<string> | null): UpgradedEventFilter;
    Upgraded(implementation?: PromiseOrValue<string> | null): UpgradedEventFilter;

    'Withdrawn(address,uint256)'(sender?: PromiseOrValue<string> | null, ethAmount?: null): WithdrawnEventFilter;
    Withdrawn(sender?: PromiseOrValue<string> | null, ethAmount?: null): WithdrawnEventFilter;
  };

  estimateGas: {
    CHECKPOINT_BUFFER(overrides?: CallOverrides): Promise<BigNumber>;

    GRR(overrides?: CallOverrides): Promise<BigNumber>;

    MCR(overrides?: CallOverrides): Promise<BigNumber>;

    RRR(overrides?: CallOverrides): Promise<BigNumber>;

    SRR(overrides?: CallOverrides): Promise<BigNumber>;

    acceptGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    borrow(
      borrowAmountInCurrency: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    borrower(overrides?: CallOverrides): Promise<BigNumber>;

    checkFlashLock(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    collFloor(overrides?: CallOverrides): Promise<BigNumber>;

    currencyOS(overrides?: CallOverrides): Promise<BigNumber>;

    deposit(overrides?: PayableOverrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    depositor(overrides?: CallOverrides): Promise<BigNumber>;

    feePool(overrides?: CallOverrides): Promise<BigNumber>;

    getDeps(overrides?: CallOverrides): Promise<BigNumber>;

    getImplementation(overrides?: CallOverrides): Promise<BigNumber>;

    getIndividualStates(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getPledge(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getStates(overrides?: CallOverrides): Promise<BigNumber>;

    governance(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      _currencyOS: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    maxRedeemableCount(overrides?: CallOverrides): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    pendingGovernance(overrides?: CallOverrides): Promise<BigNumber>;

    permitDeps(_sender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    pool(overrides?: CallOverrides): Promise<BigNumber>;

    priceFeed(overrides?: CallOverrides): Promise<BigNumber>;

    priorityRegistry(overrides?: CallOverrides): Promise<BigNumber>;

    proxiableUUID(overrides?: CallOverrides): Promise<BigNumber>;

    redeem(
      maxRedemptionCurrencyAmount: PromiseOrValue<BigNumberish>,
      isCoreRedemption: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    redeemer(overrides?: CallOverrides): Promise<BigNumber>;

    repay(
      currencyAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    repayer(overrides?: CallOverrides): Promise<BigNumber>;

    revokeGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    revokeTester(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    setDeps(
      _yamatoDepositor: PromiseOrValue<string>,
      _yamatoBorrower: PromiseOrValue<string>,
      _yamatoRepayer: PromiseOrValue<string>,
      _yamatoWithdrawer: PromiseOrValue<string>,
      _yamatoRedeemer: PromiseOrValue<string>,
      _yamatoSweeper: PromiseOrValue<string>,
      _pool: PromiseOrValue<string>,
      _priorityRegistry: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setFlashLock(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setGovernance(
      _newGoverner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setPledge(
      _owner: PromiseOrValue<string>,
      _p: IYamato.PledgeStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setPledges(
      _pledges: IYamato.PledgeStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setPriorityRegistry(
      _priorityRegistry: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setTotalColl(
      _totalColl: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setTotalDebt(
      _totalDebt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    sweep(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    sweeper(overrides?: CallOverrides): Promise<BigNumber>;

    tester(overrides?: CallOverrides): Promise<BigNumber>;

    toggle(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    withdraw(
      ethAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    withdrawer(overrides?: CallOverrides): Promise<BigNumber>;

    yamato(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    CHECKPOINT_BUFFER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    GRR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MCR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    RRR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    SRR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    acceptGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    borrow(
      borrowAmountInCurrency: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    borrower(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    checkFlashLock(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    collFloor(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    currencyOS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    deposit(overrides?: PayableOverrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    depositor(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    feePool(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getDeps(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getImplementation(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getIndividualStates(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getPledge(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getStates(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    governance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initialize(
      _currencyOS: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    maxRedeemableCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingGovernance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    permitDeps(_sender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pool(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    priceFeed(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    priorityRegistry(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proxiableUUID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    redeem(
      maxRedemptionCurrencyAmount: PromiseOrValue<BigNumberish>,
      isCoreRedemption: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    redeemer(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    repay(
      currencyAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    repayer(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    revokeGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    revokeTester(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    setDeps(
      _yamatoDepositor: PromiseOrValue<string>,
      _yamatoBorrower: PromiseOrValue<string>,
      _yamatoRepayer: PromiseOrValue<string>,
      _yamatoWithdrawer: PromiseOrValue<string>,
      _yamatoRedeemer: PromiseOrValue<string>,
      _yamatoSweeper: PromiseOrValue<string>,
      _pool: PromiseOrValue<string>,
      _priorityRegistry: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setFlashLock(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setGovernance(
      _newGoverner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setPledge(
      _owner: PromiseOrValue<string>,
      _p: IYamato.PledgeStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setPledges(
      _pledges: IYamato.PledgeStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setPriorityRegistry(
      _priorityRegistry: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setTotalColl(
      _totalColl: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setTotalDebt(
      _totalDebt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    sweep(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    sweeper(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tester(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    toggle(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    withdraw(
      ethAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    withdrawer(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    yamato(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export type BalanceStruct = {
  raw: PromiseOrValue<BigNumberish>;
  weightedTimestamp: PromiseOrValue<BigNumberish>;
  timeMultiplier: PromiseOrValue<BigNumberish>;
  questMultiplier: PromiseOrValue<BigNumberish>;
  cooldownTimestamp: PromiseOrValue<BigNumberish>;
  cooldownUnits: PromiseOrValue<BigNumberish>;
};

export type BalanceStructOutput = [BigNumber, number, number, number, number, BigNumber] & {
  raw: BigNumber;
  weightedTimestamp: number;
  timeMultiplier: number;
  questMultiplier: number;
  cooldownTimestamp: number;
  cooldownUnits: BigNumber;
};

export declare namespace GamifiedVotingToken {
  export type CheckpointStruct = {
    fromBlock: PromiseOrValue<BigNumberish>;
    votes: PromiseOrValue<BigNumberish>;
  };

  export type CheckpointStructOutput = [number, BigNumber] & {
    fromBlock: number;
    votes: BigNumber;
  };
}

export interface MstableStakingV2Interface extends utils.Interface {
  functions: {
    'COOLDOWN_SECONDS()': FunctionFragment;
    'DURATION()': FunctionFragment;
    'REWARDS_TOKEN()': FunctionFragment;
    'STAKED_TOKEN()': FunctionFragment;
    'UNSTAKE_WINDOW()': FunctionFragment;
    '__StakedToken_init(bytes32,bytes32,address)': FunctionFragment;
    'applyQuestMultiplier(address,uint8)': FunctionFragment;
    'balanceData(address)': FunctionFragment;
    'balanceOf(address)': FunctionFragment;
    'blackListWrapper(address)': FunctionFragment;
    'calcRedemptionFeeRate(uint32)': FunctionFragment;
    'changeSlashingPercentage(uint256)': FunctionFragment;
    'checkpoints(address,uint32)': FunctionFragment;
    'claimReward()': FunctionFragment;
    'claimReward(address)': FunctionFragment;
    'compoundRewards()': FunctionFragment;
    'createLock(uint256,uint256)': FunctionFragment;
    'decimals()': FunctionFragment;
    'delegate(address)': FunctionFragment;
    'delegates(address)': FunctionFragment;
    'earned(address)': FunctionFragment;
    'emergencyRecollateralisation()': FunctionFragment;
    'endCooldown()': FunctionFragment;
    'exit()': FunctionFragment;
    'getPastTotalSupply(uint256)': FunctionFragment;
    'getPastVotes(address,uint256)': FunctionFragment;
    'getRewardToken()': FunctionFragment;
    'getVotes(address)': FunctionFragment;
    'globalData()': FunctionFragment;
    'hasPriceCoeff()': FunctionFragment;
    'increaseLockAmount(uint256)': FunctionFragment;
    'initialize(bytes32,bytes32,address)': FunctionFragment;
    'lastTimeRewardApplicable()': FunctionFragment;
    'name()': FunctionFragment;
    'nexus()': FunctionFragment;
    'notifyRewardAmount(uint256)': FunctionFragment;
    'numCheckpoints(address)': FunctionFragment;
    'pendingAdditionalReward()': FunctionFragment;
    'questManager()': FunctionFragment;
    'rawBalanceOf(address)': FunctionFragment;
    'reviewTimestamp(address)': FunctionFragment;
    'rewardPerToken()': FunctionFragment;
    'rewardTokenVendor()': FunctionFragment;
    'rewardsDistributor()': FunctionFragment;
    'safetyData()': FunctionFragment;
    'setGovernanceHook(address)': FunctionFragment;
    'setRewardsDistribution(address)': FunctionFragment;
    'stake(uint256,address)': FunctionFragment;
    'stake(uint256)': FunctionFragment;
    'stake(uint256,bool)': FunctionFragment;
    'startCooldown(uint256)': FunctionFragment;
    'symbol()': FunctionFragment;
    'totalSupply()': FunctionFragment;
    'userData(address)': FunctionFragment;
    'userPriceCoeff(address)': FunctionFragment;
    'whitelistWrapper(address)': FunctionFragment;
    'whitelistedWrappers(address)': FunctionFragment;
    'withdraw(uint256,address,bool,bool)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'COOLDOWN_SECONDS'
      | 'DURATION'
      | 'REWARDS_TOKEN'
      | 'STAKED_TOKEN'
      | 'UNSTAKE_WINDOW'
      | '__StakedToken_init'
      | 'applyQuestMultiplier'
      | 'balanceData'
      | 'balanceOf'
      | 'blackListWrapper'
      | 'calcRedemptionFeeRate'
      | 'changeSlashingPercentage'
      | 'checkpoints'
      | 'claimReward()'
      | 'claimReward(address)'
      | 'compoundRewards'
      | 'createLock'
      | 'decimals'
      | 'delegate'
      | 'delegates'
      | 'earned'
      | 'emergencyRecollateralisation'
      | 'endCooldown'
      | 'exit'
      | 'getPastTotalSupply'
      | 'getPastVotes'
      | 'getRewardToken'
      | 'getVotes'
      | 'globalData'
      | 'hasPriceCoeff'
      | 'increaseLockAmount'
      | 'initialize'
      | 'lastTimeRewardApplicable'
      | 'name'
      | 'nexus'
      | 'notifyRewardAmount'
      | 'numCheckpoints'
      | 'pendingAdditionalReward'
      | 'questManager'
      | 'rawBalanceOf'
      | 'reviewTimestamp'
      | 'rewardPerToken'
      | 'rewardTokenVendor'
      | 'rewardsDistributor'
      | 'safetyData'
      | 'setGovernanceHook'
      | 'setRewardsDistribution'
      | 'stake(uint256,address)'
      | 'stake(uint256)'
      | 'stake(uint256,bool)'
      | 'startCooldown'
      | 'symbol'
      | 'totalSupply'
      | 'userData'
      | 'userPriceCoeff'
      | 'whitelistWrapper'
      | 'whitelistedWrappers'
      | 'withdraw',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'COOLDOWN_SECONDS', values?: undefined): string;
  encodeFunctionData(functionFragment: 'DURATION', values?: undefined): string;
  encodeFunctionData(functionFragment: 'REWARDS_TOKEN', values?: undefined): string;
  encodeFunctionData(functionFragment: 'STAKED_TOKEN', values?: undefined): string;
  encodeFunctionData(functionFragment: 'UNSTAKE_WINDOW', values?: undefined): string;
  encodeFunctionData(
    functionFragment: '__StakedToken_init',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'applyQuestMultiplier',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'balanceData', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'balanceOf', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'blackListWrapper', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'calcRedemptionFeeRate', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'changeSlashingPercentage', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'checkpoints',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'claimReward()', values?: undefined): string;
  encodeFunctionData(functionFragment: 'claimReward(address)', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'compoundRewards', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'createLock',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'decimals', values?: undefined): string;
  encodeFunctionData(functionFragment: 'delegate', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'delegates', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'earned', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'emergencyRecollateralisation', values?: undefined): string;
  encodeFunctionData(functionFragment: 'endCooldown', values?: undefined): string;
  encodeFunctionData(functionFragment: 'exit', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getPastTotalSupply', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'getPastVotes',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'getRewardToken', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getVotes', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'globalData', values?: undefined): string;
  encodeFunctionData(functionFragment: 'hasPriceCoeff', values?: undefined): string;
  encodeFunctionData(functionFragment: 'increaseLockAmount', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'initialize',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'lastTimeRewardApplicable', values?: undefined): string;
  encodeFunctionData(functionFragment: 'name', values?: undefined): string;
  encodeFunctionData(functionFragment: 'nexus', values?: undefined): string;
  encodeFunctionData(functionFragment: 'notifyRewardAmount', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'numCheckpoints', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'pendingAdditionalReward', values?: undefined): string;
  encodeFunctionData(functionFragment: 'questManager', values?: undefined): string;
  encodeFunctionData(functionFragment: 'rawBalanceOf', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'reviewTimestamp', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'rewardPerToken', values?: undefined): string;
  encodeFunctionData(functionFragment: 'rewardTokenVendor', values?: undefined): string;
  encodeFunctionData(functionFragment: 'rewardsDistributor', values?: undefined): string;
  encodeFunctionData(functionFragment: 'safetyData', values?: undefined): string;
  encodeFunctionData(functionFragment: 'setGovernanceHook', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setRewardsDistribution', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'stake(uint256,address)',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'stake(uint256)', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'stake(uint256,bool)',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'startCooldown', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'symbol', values?: undefined): string;
  encodeFunctionData(functionFragment: 'totalSupply', values?: undefined): string;
  encodeFunctionData(functionFragment: 'userData', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'userPriceCoeff', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'whitelistWrapper', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'whitelistedWrappers', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'withdraw',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>, PromiseOrValue<boolean>, PromiseOrValue<boolean>],
  ): string;

  decodeFunctionResult(functionFragment: 'COOLDOWN_SECONDS', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'DURATION', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'REWARDS_TOKEN', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'STAKED_TOKEN', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'UNSTAKE_WINDOW', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: '__StakedToken_init', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'applyQuestMultiplier', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balanceData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'blackListWrapper', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'calcRedemptionFeeRate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'changeSlashingPercentage', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'checkpoints', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimReward()', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimReward(address)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'compoundRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'createLock', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'decimals', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'delegate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'delegates', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'earned', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'emergencyRecollateralisation', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'endCooldown', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPastTotalSupply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPastVotes', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getRewardToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getVotes', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'globalData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'hasPriceCoeff', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'increaseLockAmount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lastTimeRewardApplicable', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'name', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nexus', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'notifyRewardAmount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'numCheckpoints', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pendingAdditionalReward', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'questManager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rawBalanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'reviewTimestamp', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardPerToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardTokenVendor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardsDistributor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'safetyData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setGovernanceHook', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setRewardsDistribution', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stake(uint256,address)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stake(uint256)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stake(uint256,bool)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'startCooldown', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'symbol', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalSupply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userPriceCoeff', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'whitelistWrapper', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'whitelistedWrappers', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result;

  events: {
    'Approval(address,address,uint256)': EventFragment;
    'Cooldown(address,uint256)': EventFragment;
    'CooldownExited(address)': EventFragment;
    'DelegateChanged(address,address,address)': EventFragment;
    'DelegateVotesChanged(address,uint256,uint256)': EventFragment;
    'GovernanceHookChanged(address)': EventFragment;
    'Recollateralised()': EventFragment;
    'RewardAdded(uint256)': EventFragment;
    'RewardPaid(address,address,uint256)': EventFragment;
    'SlashRateChanged(uint256)': EventFragment;
    'Staked(address,uint256,address)': EventFragment;
    'Transfer(address,address,uint256)': EventFragment;
    'Withdraw(address,address,uint256)': EventFragment;
    'WrapperBlacklisted(address)': EventFragment;
    'WrapperWhitelisted(address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'Approval'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Cooldown'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CooldownExited'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'DelegateChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'DelegateVotesChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'GovernanceHookChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Recollateralised'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardAdded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardPaid'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SlashRateChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Staked'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Transfer'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Withdraw'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'WrapperBlacklisted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'WrapperWhitelisted'): EventFragment;
}

export interface ApprovalEventObject {
  owner: string;
  spender: string;
  value: BigNumber;
}
export type ApprovalEvent = TypedEvent<[string, string, BigNumber], ApprovalEventObject>;

export type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;

export interface CooldownEventObject {
  user: string;
  percentage: BigNumber;
}
export type CooldownEvent = TypedEvent<[string, BigNumber], CooldownEventObject>;

export type CooldownEventFilter = TypedEventFilter<CooldownEvent>;

export interface CooldownExitedEventObject {
  user: string;
}
export type CooldownExitedEvent = TypedEvent<[string], CooldownExitedEventObject>;

export type CooldownExitedEventFilter = TypedEventFilter<CooldownExitedEvent>;

export interface DelegateChangedEventObject {
  delegator: string;
  fromDelegate: string;
  toDelegate: string;
}
export type DelegateChangedEvent = TypedEvent<[string, string, string], DelegateChangedEventObject>;

export type DelegateChangedEventFilter = TypedEventFilter<DelegateChangedEvent>;

export interface DelegateVotesChangedEventObject {
  delegate: string;
  previousBalance: BigNumber;
  newBalance: BigNumber;
}
export type DelegateVotesChangedEvent = TypedEvent<[string, BigNumber, BigNumber], DelegateVotesChangedEventObject>;

export type DelegateVotesChangedEventFilter = TypedEventFilter<DelegateVotesChangedEvent>;

export interface GovernanceHookChangedEventObject {
  hook: string;
}
export type GovernanceHookChangedEvent = TypedEvent<[string], GovernanceHookChangedEventObject>;

export type GovernanceHookChangedEventFilter = TypedEventFilter<GovernanceHookChangedEvent>;

export interface RecollateralisedEventObject {}
export type RecollateralisedEvent = TypedEvent<[], RecollateralisedEventObject>;

export type RecollateralisedEventFilter = TypedEventFilter<RecollateralisedEvent>;

export interface RewardAddedEventObject {
  reward: BigNumber;
}
export type RewardAddedEvent = TypedEvent<[BigNumber], RewardAddedEventObject>;

export type RewardAddedEventFilter = TypedEventFilter<RewardAddedEvent>;

export interface RewardPaidEventObject {
  user: string;
  to: string;
  reward: BigNumber;
}
export type RewardPaidEvent = TypedEvent<[string, string, BigNumber], RewardPaidEventObject>;

export type RewardPaidEventFilter = TypedEventFilter<RewardPaidEvent>;

export interface SlashRateChangedEventObject {
  newRate: BigNumber;
}
export type SlashRateChangedEvent = TypedEvent<[BigNumber], SlashRateChangedEventObject>;

export type SlashRateChangedEventFilter = TypedEventFilter<SlashRateChangedEvent>;

export interface StakedEventObject {
  user: string;
  amount: BigNumber;
  delegatee: string;
}
export type StakedEvent = TypedEvent<[string, BigNumber, string], StakedEventObject>;

export type StakedEventFilter = TypedEventFilter<StakedEvent>;

export interface TransferEventObject {
  from: string;
  to: string;
  value: BigNumber;
}
export type TransferEvent = TypedEvent<[string, string, BigNumber], TransferEventObject>;

export type TransferEventFilter = TypedEventFilter<TransferEvent>;

export interface WithdrawEventObject {
  user: string;
  to: string;
  amount: BigNumber;
}
export type WithdrawEvent = TypedEvent<[string, string, BigNumber], WithdrawEventObject>;

export type WithdrawEventFilter = TypedEventFilter<WithdrawEvent>;

export interface WrapperBlacklistedEventObject {
  wallet: string;
}
export type WrapperBlacklistedEvent = TypedEvent<[string], WrapperBlacklistedEventObject>;

export type WrapperBlacklistedEventFilter = TypedEventFilter<WrapperBlacklistedEvent>;

export interface WrapperWhitelistedEventObject {
  wallet: string;
}
export type WrapperWhitelistedEvent = TypedEvent<[string], WrapperWhitelistedEventObject>;

export type WrapperWhitelistedEventFilter = TypedEventFilter<WrapperWhitelistedEvent>;

export interface MstableStakingV2 extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: MstableStakingV2Interface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    COOLDOWN_SECONDS(overrides?: CallOverrides): Promise<[BigNumber]>;

    DURATION(overrides?: CallOverrides): Promise<[BigNumber]>;

    REWARDS_TOKEN(overrides?: CallOverrides): Promise<[string]>;

    STAKED_TOKEN(overrides?: CallOverrides): Promise<[string]>;

    UNSTAKE_WINDOW(overrides?: CallOverrides): Promise<[BigNumber]>;

    __StakedToken_init(
      _nameArg: PromiseOrValue<BytesLike>,
      _symbolArg: PromiseOrValue<BytesLike>,
      _rewardsDistributorArg: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    applyQuestMultiplier(
      _account: PromiseOrValue<string>,
      _newMultiplier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    balanceData(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BalanceStructOutput]>;

    balanceOf(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    blackListWrapper(
      _wrapper: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    calcRedemptionFeeRate(
      _weightedTimestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { _feeRate: BigNumber }>;

    changeSlashingPercentage(
      _newRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    checkpoints(
      account: PromiseOrValue<string>,
      pos: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[GamifiedVotingToken.CheckpointStructOutput]>;

    'claimReward()'(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    'claimReward(address)'(
      _to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    compoundRewards(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    createLock(
      _value: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    decimals(overrides?: CallOverrides): Promise<[number]>;

    delegate(
      delegatee: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    delegates(delegator: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;

    earned(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    emergencyRecollateralisation(
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    endCooldown(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    exit(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    getPastTotalSupply(blockNumber: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    getPastVotes(
      account: PromiseOrValue<string>,
      blockNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    getRewardToken(overrides?: CallOverrides): Promise<[string]>;

    getVotes(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    globalData(overrides?: CallOverrides): Promise<
      [number, number, BigNumber, BigNumber] & {
        periodFinish: number;
        lastUpdateTime: number;
        rewardRate: BigNumber;
        rewardPerTokenStored: BigNumber;
      }
    >;

    hasPriceCoeff(overrides?: CallOverrides): Promise<[boolean]>;

    increaseLockAmount(
      _value: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    initialize(
      _nameArg: PromiseOrValue<BytesLike>,
      _symbolArg: PromiseOrValue<BytesLike>,
      _rewardsDistributorArg: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    lastTimeRewardApplicable(overrides?: CallOverrides): Promise<[BigNumber]>;

    name(overrides?: CallOverrides): Promise<[string]>;

    nexus(overrides?: CallOverrides): Promise<[string]>;

    notifyRewardAmount(
      _reward: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    numCheckpoints(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[number]>;

    pendingAdditionalReward(overrides?: CallOverrides): Promise<[BigNumber]>;

    questManager(overrides?: CallOverrides): Promise<[string]>;

    rawBalanceOf(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber, BigNumber]>;

    reviewTimestamp(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    rewardPerToken(overrides?: CallOverrides): Promise<[BigNumber]>;

    rewardTokenVendor(overrides?: CallOverrides): Promise<[string]>;

    rewardsDistributor(overrides?: CallOverrides): Promise<[string]>;

    safetyData(overrides?: CallOverrides): Promise<
      [BigNumber, BigNumber] & {
        collateralisationRatio: BigNumber;
        slashingPercentage: BigNumber;
      }
    >;

    setGovernanceHook(
      _newHook: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setRewardsDistribution(
      _rewardsDistributor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'stake(uint256,address)'(
      _amount: PromiseOrValue<BigNumberish>,
      _delegatee: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'stake(uint256)'(
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'stake(uint256,bool)'(
      _amount: PromiseOrValue<BigNumberish>,
      _exitCooldown: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    startCooldown(
      _units: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    symbol(overrides?: CallOverrides): Promise<[string]>;

    totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    userData(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        rewardPerTokenPaid: BigNumber;
        rewards: BigNumber;
      }
    >;

    userPriceCoeff(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    whitelistWrapper(
      _wrapper: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    whitelistedWrappers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    withdraw(
      _amount: PromiseOrValue<BigNumberish>,
      _recipient: PromiseOrValue<string>,
      _amountIncludesFee: PromiseOrValue<boolean>,
      _exitCooldown: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;
  };

  COOLDOWN_SECONDS(overrides?: CallOverrides): Promise<BigNumber>;

  DURATION(overrides?: CallOverrides): Promise<BigNumber>;

  REWARDS_TOKEN(overrides?: CallOverrides): Promise<string>;

  STAKED_TOKEN(overrides?: CallOverrides): Promise<string>;

  UNSTAKE_WINDOW(overrides?: CallOverrides): Promise<BigNumber>;

  __StakedToken_init(
    _nameArg: PromiseOrValue<BytesLike>,
    _symbolArg: PromiseOrValue<BytesLike>,
    _rewardsDistributorArg: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  applyQuestMultiplier(
    _account: PromiseOrValue<string>,
    _newMultiplier: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  balanceData(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BalanceStructOutput>;

  balanceOf(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  blackListWrapper(
    _wrapper: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  calcRedemptionFeeRate(
    _weightedTimestamp: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  changeSlashingPercentage(
    _newRate: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  checkpoints(
    account: PromiseOrValue<string>,
    pos: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<GamifiedVotingToken.CheckpointStructOutput>;

  'claimReward()'(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  'claimReward(address)'(
    _to: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  compoundRewards(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  createLock(
    _value: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  decimals(overrides?: CallOverrides): Promise<number>;

  delegate(
    delegatee: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  delegates(delegator: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  earned(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  emergencyRecollateralisation(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  endCooldown(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  exit(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  getPastTotalSupply(blockNumber: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  getPastVotes(
    account: PromiseOrValue<string>,
    blockNumber: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  getRewardToken(overrides?: CallOverrides): Promise<string>;

  getVotes(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  globalData(overrides?: CallOverrides): Promise<
    [number, number, BigNumber, BigNumber] & {
      periodFinish: number;
      lastUpdateTime: number;
      rewardRate: BigNumber;
      rewardPerTokenStored: BigNumber;
    }
  >;

  hasPriceCoeff(overrides?: CallOverrides): Promise<boolean>;

  increaseLockAmount(
    _value: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  initialize(
    _nameArg: PromiseOrValue<BytesLike>,
    _symbolArg: PromiseOrValue<BytesLike>,
    _rewardsDistributorArg: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  lastTimeRewardApplicable(overrides?: CallOverrides): Promise<BigNumber>;

  name(overrides?: CallOverrides): Promise<string>;

  nexus(overrides?: CallOverrides): Promise<string>;

  notifyRewardAmount(
    _reward: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  numCheckpoints(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<number>;

  pendingAdditionalReward(overrides?: CallOverrides): Promise<BigNumber>;

  questManager(overrides?: CallOverrides): Promise<string>;

  rawBalanceOf(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber, BigNumber]>;

  reviewTimestamp(
    _account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  rewardPerToken(overrides?: CallOverrides): Promise<BigNumber>;

  rewardTokenVendor(overrides?: CallOverrides): Promise<string>;

  rewardsDistributor(overrides?: CallOverrides): Promise<string>;

  safetyData(overrides?: CallOverrides): Promise<
    [BigNumber, BigNumber] & {
      collateralisationRatio: BigNumber;
      slashingPercentage: BigNumber;
    }
  >;

  setGovernanceHook(
    _newHook: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setRewardsDistribution(
    _rewardsDistributor: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'stake(uint256,address)'(
    _amount: PromiseOrValue<BigNumberish>,
    _delegatee: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'stake(uint256)'(
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'stake(uint256,bool)'(
    _amount: PromiseOrValue<BigNumberish>,
    _exitCooldown: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  startCooldown(
    _units: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  symbol(overrides?: CallOverrides): Promise<string>;

  totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  userData(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber] & {
      rewardPerTokenPaid: BigNumber;
      rewards: BigNumber;
    }
  >;

  userPriceCoeff(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  whitelistWrapper(
    _wrapper: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  whitelistedWrappers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  withdraw(
    _amount: PromiseOrValue<BigNumberish>,
    _recipient: PromiseOrValue<string>,
    _amountIncludesFee: PromiseOrValue<boolean>,
    _exitCooldown: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    COOLDOWN_SECONDS(overrides?: CallOverrides): Promise<BigNumber>;

    DURATION(overrides?: CallOverrides): Promise<BigNumber>;

    REWARDS_TOKEN(overrides?: CallOverrides): Promise<string>;

    STAKED_TOKEN(overrides?: CallOverrides): Promise<string>;

    UNSTAKE_WINDOW(overrides?: CallOverrides): Promise<BigNumber>;

    __StakedToken_init(
      _nameArg: PromiseOrValue<BytesLike>,
      _symbolArg: PromiseOrValue<BytesLike>,
      _rewardsDistributorArg: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    applyQuestMultiplier(
      _account: PromiseOrValue<string>,
      _newMultiplier: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    balanceData(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BalanceStructOutput>;

    balanceOf(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    blackListWrapper(_wrapper: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    calcRedemptionFeeRate(
      _weightedTimestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    changeSlashingPercentage(_newRate: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    checkpoints(
      account: PromiseOrValue<string>,
      pos: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<GamifiedVotingToken.CheckpointStructOutput>;

    'claimReward()'(overrides?: CallOverrides): Promise<void>;

    'claimReward(address)'(_to: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    compoundRewards(overrides?: CallOverrides): Promise<void>;

    createLock(
      _value: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    decimals(overrides?: CallOverrides): Promise<number>;

    delegate(delegatee: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    delegates(delegator: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    earned(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    emergencyRecollateralisation(overrides?: CallOverrides): Promise<void>;

    endCooldown(overrides?: CallOverrides): Promise<void>;

    exit(overrides?: CallOverrides): Promise<void>;

    getPastTotalSupply(blockNumber: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getPastVotes(
      account: PromiseOrValue<string>,
      blockNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getRewardToken(overrides?: CallOverrides): Promise<string>;

    getVotes(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    globalData(overrides?: CallOverrides): Promise<
      [number, number, BigNumber, BigNumber] & {
        periodFinish: number;
        lastUpdateTime: number;
        rewardRate: BigNumber;
        rewardPerTokenStored: BigNumber;
      }
    >;

    hasPriceCoeff(overrides?: CallOverrides): Promise<boolean>;

    increaseLockAmount(_value: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    initialize(
      _nameArg: PromiseOrValue<BytesLike>,
      _symbolArg: PromiseOrValue<BytesLike>,
      _rewardsDistributorArg: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    lastTimeRewardApplicable(overrides?: CallOverrides): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<string>;

    nexus(overrides?: CallOverrides): Promise<string>;

    notifyRewardAmount(_reward: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    numCheckpoints(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<number>;

    pendingAdditionalReward(overrides?: CallOverrides): Promise<BigNumber>;

    questManager(overrides?: CallOverrides): Promise<string>;

    rawBalanceOf(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber, BigNumber]>;

    reviewTimestamp(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    rewardPerToken(overrides?: CallOverrides): Promise<BigNumber>;

    rewardTokenVendor(overrides?: CallOverrides): Promise<string>;

    rewardsDistributor(overrides?: CallOverrides): Promise<string>;

    safetyData(overrides?: CallOverrides): Promise<
      [BigNumber, BigNumber] & {
        collateralisationRatio: BigNumber;
        slashingPercentage: BigNumber;
      }
    >;

    setGovernanceHook(_newHook: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setRewardsDistribution(_rewardsDistributor: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    'stake(uint256,address)'(
      _amount: PromiseOrValue<BigNumberish>,
      _delegatee: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    'stake(uint256)'(_amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    'stake(uint256,bool)'(
      _amount: PromiseOrValue<BigNumberish>,
      _exitCooldown: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    startCooldown(_units: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    symbol(overrides?: CallOverrides): Promise<string>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    userData(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        rewardPerTokenPaid: BigNumber;
        rewards: BigNumber;
      }
    >;

    userPriceCoeff(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    whitelistWrapper(_wrapper: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    whitelistedWrappers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    withdraw(
      _amount: PromiseOrValue<BigNumberish>,
      _recipient: PromiseOrValue<string>,
      _amountIncludesFee: PromiseOrValue<boolean>,
      _exitCooldown: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;
  };

  filters: {
    'Approval(address,address,uint256)'(
      owner?: PromiseOrValue<string> | null,
      spender?: PromiseOrValue<string> | null,
      value?: null,
    ): ApprovalEventFilter;
    Approval(
      owner?: PromiseOrValue<string> | null,
      spender?: PromiseOrValue<string> | null,
      value?: null,
    ): ApprovalEventFilter;

    'Cooldown(address,uint256)'(user?: PromiseOrValue<string> | null, percentage?: null): CooldownEventFilter;
    Cooldown(user?: PromiseOrValue<string> | null, percentage?: null): CooldownEventFilter;

    'CooldownExited(address)'(user?: PromiseOrValue<string> | null): CooldownExitedEventFilter;
    CooldownExited(user?: PromiseOrValue<string> | null): CooldownExitedEventFilter;

    'DelegateChanged(address,address,address)'(
      delegator?: PromiseOrValue<string> | null,
      fromDelegate?: PromiseOrValue<string> | null,
      toDelegate?: PromiseOrValue<string> | null,
    ): DelegateChangedEventFilter;
    DelegateChanged(
      delegator?: PromiseOrValue<string> | null,
      fromDelegate?: PromiseOrValue<string> | null,
      toDelegate?: PromiseOrValue<string> | null,
    ): DelegateChangedEventFilter;

    'DelegateVotesChanged(address,uint256,uint256)'(
      delegate?: PromiseOrValue<string> | null,
      previousBalance?: null,
      newBalance?: null,
    ): DelegateVotesChangedEventFilter;
    DelegateVotesChanged(
      delegate?: PromiseOrValue<string> | null,
      previousBalance?: null,
      newBalance?: null,
    ): DelegateVotesChangedEventFilter;

    'GovernanceHookChanged(address)'(hook?: PromiseOrValue<string> | null): GovernanceHookChangedEventFilter;
    GovernanceHookChanged(hook?: PromiseOrValue<string> | null): GovernanceHookChangedEventFilter;

    'Recollateralised()'(): RecollateralisedEventFilter;
    Recollateralised(): RecollateralisedEventFilter;

    'RewardAdded(uint256)'(reward?: null): RewardAddedEventFilter;
    RewardAdded(reward?: null): RewardAddedEventFilter;

    'RewardPaid(address,address,uint256)'(
      user?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      reward?: null,
    ): RewardPaidEventFilter;
    RewardPaid(
      user?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      reward?: null,
    ): RewardPaidEventFilter;

    'SlashRateChanged(uint256)'(newRate?: null): SlashRateChangedEventFilter;
    SlashRateChanged(newRate?: null): SlashRateChangedEventFilter;

    'Staked(address,uint256,address)'(
      user?: PromiseOrValue<string> | null,
      amount?: null,
      delegatee?: null,
    ): StakedEventFilter;
    Staked(user?: PromiseOrValue<string> | null, amount?: null, delegatee?: null): StakedEventFilter;

    'Transfer(address,address,uint256)'(
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      value?: null,
    ): TransferEventFilter;
    Transfer(
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      value?: null,
    ): TransferEventFilter;

    'Withdraw(address,address,uint256)'(
      user?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      amount?: null,
    ): WithdrawEventFilter;
    Withdraw(
      user?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      amount?: null,
    ): WithdrawEventFilter;

    'WrapperBlacklisted(address)'(wallet?: null): WrapperBlacklistedEventFilter;
    WrapperBlacklisted(wallet?: null): WrapperBlacklistedEventFilter;

    'WrapperWhitelisted(address)'(wallet?: null): WrapperWhitelistedEventFilter;
    WrapperWhitelisted(wallet?: null): WrapperWhitelistedEventFilter;
  };

  estimateGas: {
    COOLDOWN_SECONDS(overrides?: CallOverrides): Promise<BigNumber>;

    DURATION(overrides?: CallOverrides): Promise<BigNumber>;

    REWARDS_TOKEN(overrides?: CallOverrides): Promise<BigNumber>;

    STAKED_TOKEN(overrides?: CallOverrides): Promise<BigNumber>;

    UNSTAKE_WINDOW(overrides?: CallOverrides): Promise<BigNumber>;

    __StakedToken_init(
      _nameArg: PromiseOrValue<BytesLike>,
      _symbolArg: PromiseOrValue<BytesLike>,
      _rewardsDistributorArg: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    applyQuestMultiplier(
      _account: PromiseOrValue<string>,
      _newMultiplier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    balanceData(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    balanceOf(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    blackListWrapper(
      _wrapper: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    calcRedemptionFeeRate(
      _weightedTimestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    changeSlashingPercentage(
      _newRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    checkpoints(
      account: PromiseOrValue<string>,
      pos: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    'claimReward()'(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    'claimReward(address)'(
      _to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    compoundRewards(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    createLock(
      _value: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    decimals(overrides?: CallOverrides): Promise<BigNumber>;

    delegate(
      delegatee: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    delegates(delegator: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    earned(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    emergencyRecollateralisation(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    endCooldown(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    exit(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    getPastTotalSupply(blockNumber: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getPastVotes(
      account: PromiseOrValue<string>,
      blockNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getRewardToken(overrides?: CallOverrides): Promise<BigNumber>;

    getVotes(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    globalData(overrides?: CallOverrides): Promise<BigNumber>;

    hasPriceCoeff(overrides?: CallOverrides): Promise<BigNumber>;

    increaseLockAmount(
      _value: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    initialize(
      _nameArg: PromiseOrValue<BytesLike>,
      _symbolArg: PromiseOrValue<BytesLike>,
      _rewardsDistributorArg: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    lastTimeRewardApplicable(overrides?: CallOverrides): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    nexus(overrides?: CallOverrides): Promise<BigNumber>;

    notifyRewardAmount(
      _reward: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    numCheckpoints(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    pendingAdditionalReward(overrides?: CallOverrides): Promise<BigNumber>;

    questManager(overrides?: CallOverrides): Promise<BigNumber>;

    rawBalanceOf(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    reviewTimestamp(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    rewardPerToken(overrides?: CallOverrides): Promise<BigNumber>;

    rewardTokenVendor(overrides?: CallOverrides): Promise<BigNumber>;

    rewardsDistributor(overrides?: CallOverrides): Promise<BigNumber>;

    safetyData(overrides?: CallOverrides): Promise<BigNumber>;

    setGovernanceHook(
      _newHook: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setRewardsDistribution(
      _rewardsDistributor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'stake(uint256,address)'(
      _amount: PromiseOrValue<BigNumberish>,
      _delegatee: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'stake(uint256)'(
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'stake(uint256,bool)'(
      _amount: PromiseOrValue<BigNumberish>,
      _exitCooldown: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    startCooldown(
      _units: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    symbol(overrides?: CallOverrides): Promise<BigNumber>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    userData(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    userPriceCoeff(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    whitelistWrapper(
      _wrapper: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    whitelistedWrappers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    withdraw(
      _amount: PromiseOrValue<BigNumberish>,
      _recipient: PromiseOrValue<string>,
      _amountIncludesFee: PromiseOrValue<boolean>,
      _exitCooldown: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    COOLDOWN_SECONDS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    DURATION(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    REWARDS_TOKEN(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    STAKED_TOKEN(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    UNSTAKE_WINDOW(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    __StakedToken_init(
      _nameArg: PromiseOrValue<BytesLike>,
      _symbolArg: PromiseOrValue<BytesLike>,
      _rewardsDistributorArg: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    applyQuestMultiplier(
      _account: PromiseOrValue<string>,
      _newMultiplier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    balanceData(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    balanceOf(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    blackListWrapper(
      _wrapper: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    calcRedemptionFeeRate(
      _weightedTimestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    changeSlashingPercentage(
      _newRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    checkpoints(
      account: PromiseOrValue<string>,
      pos: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    'claimReward()'(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    'claimReward(address)'(
      _to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    compoundRewards(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    createLock(
      _value: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    delegate(
      delegatee: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    delegates(delegator: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    earned(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    emergencyRecollateralisation(
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    endCooldown(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    exit(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    getPastTotalSupply(
      blockNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getPastVotes(
      account: PromiseOrValue<string>,
      blockNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getRewardToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getVotes(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    globalData(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    hasPriceCoeff(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    increaseLockAmount(
      _value: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    initialize(
      _nameArg: PromiseOrValue<BytesLike>,
      _symbolArg: PromiseOrValue<BytesLike>,
      _rewardsDistributorArg: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    lastTimeRewardApplicable(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nexus(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    notifyRewardAmount(
      _reward: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    numCheckpoints(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingAdditionalReward(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    questManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rawBalanceOf(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    reviewTimestamp(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    rewardPerToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardTokenVendor(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardsDistributor(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    safetyData(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setGovernanceHook(
      _newHook: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setRewardsDistribution(
      _rewardsDistributor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'stake(uint256,address)'(
      _amount: PromiseOrValue<BigNumberish>,
      _delegatee: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'stake(uint256)'(
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'stake(uint256,bool)'(
      _amount: PromiseOrValue<BigNumberish>,
      _exitCooldown: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    startCooldown(
      _units: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    userData(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    userPriceCoeff(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    whitelistWrapper(
      _wrapper: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    whitelistedWrappers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdraw(
      _amount: PromiseOrValue<BigNumberish>,
      _recipient: PromiseOrValue<string>,
      _amountIncludesFee: PromiseOrValue<boolean>,
      _exitCooldown: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;
  };
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export declare namespace IStaking {
  export type StakingScheduleStruct = {
    cliff: PromiseOrValue<BigNumberish>;
    duration: PromiseOrValue<BigNumberish>;
    interval: PromiseOrValue<BigNumberish>;
    setup: PromiseOrValue<boolean>;
    isActive: PromiseOrValue<boolean>;
    hardStart: PromiseOrValue<BigNumberish>;
    isPublic: PromiseOrValue<boolean>;
  };

  export type StakingScheduleStructOutput = [BigNumber, BigNumber, BigNumber, boolean, boolean, BigNumber, boolean] & {
    cliff: BigNumber;
    duration: BigNumber;
    interval: BigNumber;
    setup: boolean;
    isActive: boolean;
    hardStart: BigNumber;
    isPublic: boolean;
  };

  export type StakingScheduleInfoStruct = {
    schedule: IStaking.StakingScheduleStruct;
    index: PromiseOrValue<BigNumberish>;
  };

  export type StakingScheduleInfoStructOutput = [IStaking.StakingScheduleStructOutput, BigNumber] & {
    schedule: IStaking.StakingScheduleStructOutput;
    index: BigNumber;
  };

  export type StakingDetailsStruct = {
    initial: PromiseOrValue<BigNumberish>;
    withdrawn: PromiseOrValue<BigNumberish>;
    slashed: PromiseOrValue<BigNumberish>;
    started: PromiseOrValue<BigNumberish>;
    scheduleIx: PromiseOrValue<BigNumberish>;
  };

  export type StakingDetailsStructOutput = [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
    initial: BigNumber;
    withdrawn: BigNumber;
    slashed: BigNumber;
    started: BigNumber;
    scheduleIx: BigNumber;
  };
}

export interface TokemakTokeStakingInterface extends utils.Interface {
  functions: {
    '_eventSend()': FunctionFragment;
    'addSchedule((uint256,uint256,uint256,bool,bool,uint256,bool),address)': FunctionFragment;
    'availableForWithdrawal(address,uint256)': FunctionFragment;
    'balanceOf(address)': FunctionFragment;
    'delegateFunction()': FunctionFragment;
    'deposit(uint256)': FunctionFragment;
    'deposit(uint256,uint256)': FunctionFragment;
    'depositFor(address,uint256,uint256)': FunctionFragment;
    'depositWithSchedule(address,uint256,(uint256,uint256,uint256,bool,bool,uint256,bool),address)': FunctionFragment;
    'destinations()': FunctionFragment;
    'getSchedules()': FunctionFragment;
    'getStakes(address)': FunctionFragment;
    'initialize(address,address,address,address)': FunctionFragment;
    'manager()': FunctionFragment;
    'nextScheduleIndex()': FunctionFragment;
    'notionalAddresses(uint256)': FunctionFragment;
    'owner()': FunctionFragment;
    'pause()': FunctionFragment;
    'paused()': FunctionFragment;
    'permissionedDepositors(address)': FunctionFragment;
    'renounceOwnership()': FunctionFragment;
    'requestWithdrawal(uint256,uint256)': FunctionFragment;
    'requestedWithdrawals(address)': FunctionFragment;
    'schedules(uint256)': FunctionFragment;
    'setDestinations(address,address)': FunctionFragment;
    'setEventSend(bool)': FunctionFragment;
    'setNotionalAddresses(uint256[],address[])': FunctionFragment;
    'setPermissionedDepositor(address,bool)': FunctionFragment;
    'setScheduleStatus(uint256,bool)': FunctionFragment;
    'setUserSchedules(address,uint256[])': FunctionFragment;
    'slash(address[],uint256[],uint256)': FunctionFragment;
    'tokeToken()': FunctionFragment;
    'transferOwnership(address)': FunctionFragment;
    'treasury()': FunctionFragment;
    'unpause()': FunctionFragment;
    'unvested(address,uint256)': FunctionFragment;
    'userStakingSchedules(address,uint256)': FunctionFragment;
    'userStakings(address,uint256)': FunctionFragment;
    'vested(address,uint256)': FunctionFragment;
    'withdraw(uint256)': FunctionFragment;
    'withdraw(uint256,uint256)': FunctionFragment;
    'withdrawalRequestsByIndex(address,uint256)': FunctionFragment;
    'withheldLiquidity()': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | '_eventSend'
      | 'addSchedule'
      | 'availableForWithdrawal'
      | 'balanceOf'
      | 'delegateFunction'
      | 'deposit(uint256)'
      | 'deposit(uint256,uint256)'
      | 'depositFor'
      | 'depositWithSchedule'
      | 'destinations'
      | 'getSchedules'
      | 'getStakes'
      | 'initialize'
      | 'manager'
      | 'nextScheduleIndex'
      | 'notionalAddresses'
      | 'owner'
      | 'pause'
      | 'paused'
      | 'permissionedDepositors'
      | 'renounceOwnership'
      | 'requestWithdrawal'
      | 'requestedWithdrawals'
      | 'schedules'
      | 'setDestinations'
      | 'setEventSend'
      | 'setNotionalAddresses'
      | 'setPermissionedDepositor'
      | 'setScheduleStatus'
      | 'setUserSchedules'
      | 'slash'
      | 'tokeToken'
      | 'transferOwnership'
      | 'treasury'
      | 'unpause'
      | 'unvested'
      | 'userStakingSchedules'
      | 'userStakings'
      | 'vested'
      | 'withdraw(uint256)'
      | 'withdraw(uint256,uint256)'
      | 'withdrawalRequestsByIndex'
      | 'withheldLiquidity',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: '_eventSend', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'addSchedule',
    values: [IStaking.StakingScheduleStruct, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'availableForWithdrawal',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'balanceOf', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'delegateFunction', values?: undefined): string;
  encodeFunctionData(functionFragment: 'deposit(uint256)', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'deposit(uint256,uint256)',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'depositFor',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'depositWithSchedule',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      IStaking.StakingScheduleStruct,
      PromiseOrValue<string>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'destinations', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getSchedules', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getStakes', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'initialize',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'manager', values?: undefined): string;
  encodeFunctionData(functionFragment: 'nextScheduleIndex', values?: undefined): string;
  encodeFunctionData(functionFragment: 'notionalAddresses', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pause', values?: undefined): string;
  encodeFunctionData(functionFragment: 'paused', values?: undefined): string;
  encodeFunctionData(functionFragment: 'permissionedDepositors', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'requestWithdrawal',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'requestedWithdrawals', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'schedules', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'setDestinations',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'setEventSend', values: [PromiseOrValue<boolean>]): string;
  encodeFunctionData(
    functionFragment: 'setNotionalAddresses',
    values: [PromiseOrValue<BigNumberish>[], PromiseOrValue<string>[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'setPermissionedDepositor',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setScheduleStatus',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setUserSchedules',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'slash',
    values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[], PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'tokeToken', values?: undefined): string;
  encodeFunctionData(functionFragment: 'transferOwnership', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'treasury', values?: undefined): string;
  encodeFunctionData(functionFragment: 'unpause', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'unvested',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'userStakingSchedules',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'userStakings',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'vested',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'withdraw(uint256)', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'withdraw(uint256,uint256)',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'withdrawalRequestsByIndex',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'withheldLiquidity', values?: undefined): string;

  decodeFunctionResult(functionFragment: '_eventSend', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addSchedule', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'availableForWithdrawal', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'delegateFunction', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deposit(uint256)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deposit(uint256,uint256)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'depositFor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'depositWithSchedule', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'destinations', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getSchedules', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getStakes', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'manager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nextScheduleIndex', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'notionalAddresses', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pause', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'paused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'permissionedDepositors', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'requestWithdrawal', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'requestedWithdrawals', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'schedules', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setDestinations', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setEventSend', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setNotionalAddresses', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setPermissionedDepositor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setScheduleStatus', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setUserSchedules', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'slash', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tokeToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'treasury', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'unpause', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'unvested', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userStakingSchedules', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userStakings', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'vested', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdraw(uint256)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdraw(uint256,uint256)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawalRequestsByIndex', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withheldLiquidity', data: BytesLike): Result;

  events: {
    'Deposited(address,uint256,uint256)': EventFragment;
    'DestinationsSet(address,address)': EventFragment;
    'EventSendSet(bool)': EventFragment;
    'NotionalAddressesSet(uint256[],address[])': EventFragment;
    'OwnershipTransferred(address,address)': EventFragment;
    'Paused(address)': EventFragment;
    'PermissionedDepositorSet(address,bool)': EventFragment;
    'QueuedTransferRejected(address,uint256,uint256,uint256,address)': EventFragment;
    'QueuedTransferRemoved(address,uint256,uint256,uint256,address)': EventFragment;
    'ScheduleAdded(uint256,uint256,uint256,uint256,bool,bool,uint256,address)': EventFragment;
    'ScheduleRemoved(uint256)': EventFragment;
    'ScheduleStatusSet(uint256,bool)': EventFragment;
    'Slashed(address,uint256,uint256)': EventFragment;
    'StakeTransferred(address,uint256,uint256,uint256,address)': EventFragment;
    'TransferApproverSet(address)': EventFragment;
    'TransferQueued(address,uint256,uint256,uint256,address)': EventFragment;
    'Unpaused(address)': EventFragment;
    'UserSchedulesSet(address,uint256[])': EventFragment;
    'WithdrawCompleted(address,uint256,uint256)': EventFragment;
    'WithdrawalRequested(address,uint256,uint256)': EventFragment;
    'ZeroSweep(address,uint256,uint256)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'Deposited'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'DestinationsSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'EventSendSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NotionalAddressesSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Paused'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'PermissionedDepositorSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'QueuedTransferRejected'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'QueuedTransferRemoved'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ScheduleAdded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ScheduleRemoved'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ScheduleStatusSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Slashed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'StakeTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TransferApproverSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TransferQueued'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Unpaused'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'UserSchedulesSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'WithdrawCompleted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'WithdrawalRequested'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ZeroSweep'): EventFragment;
}

export interface DepositedEventObject {
  account: string;
  amount: BigNumber;
  scheduleIx: BigNumber;
}
export type DepositedEvent = TypedEvent<[string, BigNumber, BigNumber], DepositedEventObject>;

export type DepositedEventFilter = TypedEventFilter<DepositedEvent>;

export interface DestinationsSetEventObject {
  fxStateSender: string;
  destinationOnL2: string;
}
export type DestinationsSetEvent = TypedEvent<[string, string], DestinationsSetEventObject>;

export type DestinationsSetEventFilter = TypedEventFilter<DestinationsSetEvent>;

export interface EventSendSetEventObject {
  eventSendSet: boolean;
}
export type EventSendSetEvent = TypedEvent<[boolean], EventSendSetEventObject>;

export type EventSendSetEventFilter = TypedEventFilter<EventSendSetEvent>;

export interface NotionalAddressesSetEventObject {
  scheduleIdxs: BigNumber[];
  addresses: string[];
}
export type NotionalAddressesSetEvent = TypedEvent<[BigNumber[], string[]], NotionalAddressesSetEventObject>;

export type NotionalAddressesSetEventFilter = TypedEventFilter<NotionalAddressesSetEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<[string, string], OwnershipTransferredEventObject>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export interface PausedEventObject {
  account: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface PermissionedDepositorSetEventObject {
  depositor: string;
  allowed: boolean;
}
export type PermissionedDepositorSetEvent = TypedEvent<[string, boolean], PermissionedDepositorSetEventObject>;

export type PermissionedDepositorSetEventFilter = TypedEventFilter<PermissionedDepositorSetEvent>;

export interface QueuedTransferRejectedEventObject {
  from: string;
  scheduleFrom: BigNumber;
  scheduleTo: BigNumber;
  amount: BigNumber;
  to: string;
}
export type QueuedTransferRejectedEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, string],
  QueuedTransferRejectedEventObject
>;

export type QueuedTransferRejectedEventFilter = TypedEventFilter<QueuedTransferRejectedEvent>;

export interface QueuedTransferRemovedEventObject {
  from: string;
  scheduleFrom: BigNumber;
  scheduleTo: BigNumber;
  amount: BigNumber;
  to: string;
}
export type QueuedTransferRemovedEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, string],
  QueuedTransferRemovedEventObject
>;

export type QueuedTransferRemovedEventFilter = TypedEventFilter<QueuedTransferRemovedEvent>;

export interface ScheduleAddedEventObject {
  scheduleIndex: BigNumber;
  cliff: BigNumber;
  duration: BigNumber;
  interval: BigNumber;
  setup: boolean;
  isActive: boolean;
  hardStart: BigNumber;
  notional: string;
}
export type ScheduleAddedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, BigNumber, boolean, boolean, BigNumber, string],
  ScheduleAddedEventObject
>;

export type ScheduleAddedEventFilter = TypedEventFilter<ScheduleAddedEvent>;

export interface ScheduleRemovedEventObject {
  scheduleIndex: BigNumber;
}
export type ScheduleRemovedEvent = TypedEvent<[BigNumber], ScheduleRemovedEventObject>;

export type ScheduleRemovedEventFilter = TypedEventFilter<ScheduleRemovedEvent>;

export interface ScheduleStatusSetEventObject {
  scheduleId: BigNumber;
  isActive: boolean;
}
export type ScheduleStatusSetEvent = TypedEvent<[BigNumber, boolean], ScheduleStatusSetEventObject>;

export type ScheduleStatusSetEventFilter = TypedEventFilter<ScheduleStatusSetEvent>;

export interface SlashedEventObject {
  account: string;
  amount: BigNumber;
  scheduleIx: BigNumber;
}
export type SlashedEvent = TypedEvent<[string, BigNumber, BigNumber], SlashedEventObject>;

export type SlashedEventFilter = TypedEventFilter<SlashedEvent>;

export interface StakeTransferredEventObject {
  from: string;
  scheduleFrom: BigNumber;
  scheduleTo: BigNumber;
  amount: BigNumber;
  to: string;
}
export type StakeTransferredEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, string],
  StakeTransferredEventObject
>;

export type StakeTransferredEventFilter = TypedEventFilter<StakeTransferredEvent>;

export interface TransferApproverSetEventObject {
  approverAddress: string;
}
export type TransferApproverSetEvent = TypedEvent<[string], TransferApproverSetEventObject>;

export type TransferApproverSetEventFilter = TypedEventFilter<TransferApproverSetEvent>;

export interface TransferQueuedEventObject {
  from: string;
  scheduleFrom: BigNumber;
  scheduleTo: BigNumber;
  amount: BigNumber;
  to: string;
}
export type TransferQueuedEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, string],
  TransferQueuedEventObject
>;

export type TransferQueuedEventFilter = TypedEventFilter<TransferQueuedEvent>;

export interface UnpausedEventObject {
  account: string;
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface UserSchedulesSetEventObject {
  account: string;
  userSchedulesIdxs: BigNumber[];
}
export type UserSchedulesSetEvent = TypedEvent<[string, BigNumber[]], UserSchedulesSetEventObject>;

export type UserSchedulesSetEventFilter = TypedEventFilter<UserSchedulesSetEvent>;

export interface WithdrawCompletedEventObject {
  account: string;
  scheduleIdx: BigNumber;
  amount: BigNumber;
}
export type WithdrawCompletedEvent = TypedEvent<[string, BigNumber, BigNumber], WithdrawCompletedEventObject>;

export type WithdrawCompletedEventFilter = TypedEventFilter<WithdrawCompletedEvent>;

export interface WithdrawalRequestedEventObject {
  account: string;
  scheduleIdx: BigNumber;
  amount: BigNumber;
}
export type WithdrawalRequestedEvent = TypedEvent<[string, BigNumber, BigNumber], WithdrawalRequestedEventObject>;

export type WithdrawalRequestedEventFilter = TypedEventFilter<WithdrawalRequestedEvent>;

export interface ZeroSweepEventObject {
  user: string;
  amount: BigNumber;
  scheduleFrom: BigNumber;
}
export type ZeroSweepEvent = TypedEvent<[string, BigNumber, BigNumber], ZeroSweepEventObject>;

export type ZeroSweepEventFilter = TypedEventFilter<ZeroSweepEvent>;

export interface TokemakTokeStaking extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: TokemakTokeStakingInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    _eventSend(overrides?: CallOverrides): Promise<[boolean]>;

    addSchedule(
      schedule: IStaking.StakingScheduleStruct,
      notional: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    availableForWithdrawal(
      account: PromiseOrValue<string>,
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber] & { value: BigNumber }>;

    delegateFunction(overrides?: CallOverrides): Promise<[string]>;

    'deposit(uint256)'(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'deposit(uint256,uint256)'(
      amount: PromiseOrValue<BigNumberish>,
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    depositFor(
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    depositWithSchedule(
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      schedule: IStaking.StakingScheduleStruct,
      notional: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    destinations(
      overrides?: CallOverrides,
    ): Promise<[string, string] & { fxStateSender: string; destinationOnL2: string }>;

    getSchedules(overrides?: CallOverrides): Promise<
      [IStaking.StakingScheduleInfoStructOutput[]] & {
        retSchedules: IStaking.StakingScheduleInfoStructOutput[];
      }
    >;

    getStakes(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [IStaking.StakingDetailsStructOutput[]] & {
        stakes: IStaking.StakingDetailsStructOutput[];
      }
    >;

    initialize(
      _tokeToken: PromiseOrValue<string>,
      _manager: PromiseOrValue<string>,
      _treasury: PromiseOrValue<string>,
      _scheduleZeroNotional: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    manager(overrides?: CallOverrides): Promise<[string]>;

    nextScheduleIndex(overrides?: CallOverrides): Promise<[BigNumber]>;

    notionalAddresses(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    permissionedDepositors(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    requestWithdrawal(
      amount: PromiseOrValue<BigNumberish>,
      scheduleIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    requestedWithdrawals(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { minCycleIndex: BigNumber; amount: BigNumber }>;

    schedules(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, boolean, boolean, BigNumber, boolean] & {
        cliff: BigNumber;
        duration: BigNumber;
        interval: BigNumber;
        setup: boolean;
        isActive: boolean;
        hardStart: BigNumber;
        isPublic: boolean;
      }
    >;

    setDestinations(
      _fxStateSender: PromiseOrValue<string>,
      _destinationOnL2: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setEventSend(
      _eventSendSet: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setNotionalAddresses(
      scheduleIdxArr: PromiseOrValue<BigNumberish>[],
      addresses: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setPermissionedDepositor(
      account: PromiseOrValue<string>,
      canDeposit: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setScheduleStatus(
      scheduleId: PromiseOrValue<BigNumberish>,
      activeBool: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setUserSchedules(
      account: PromiseOrValue<string>,
      userSchedulesIdxs: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    slash(
      accounts: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    tokeToken(overrides?: CallOverrides): Promise<[string]>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    treasury(overrides?: CallOverrides): Promise<[string]>;

    unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    unvested(
      account: PromiseOrValue<string>,
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { value: BigNumber }>;

    userStakingSchedules(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    userStakings(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        initial: BigNumber;
        withdrawn: BigNumber;
        slashed: BigNumber;
        started: BigNumber;
        scheduleIx: BigNumber;
      }
    >;

    vested(
      account: PromiseOrValue<string>,
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { value: BigNumber }>;

    'withdraw(uint256)'(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'withdraw(uint256,uint256)'(
      amount: PromiseOrValue<BigNumberish>,
      scheduleIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    withdrawalRequestsByIndex(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { minCycleIndex: BigNumber; amount: BigNumber }>;

    withheldLiquidity(overrides?: CallOverrides): Promise<[BigNumber]>;
  };

  _eventSend(overrides?: CallOverrides): Promise<boolean>;

  addSchedule(
    schedule: IStaking.StakingScheduleStruct,
    notional: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  availableForWithdrawal(
    account: PromiseOrValue<string>,
    scheduleIndex: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  delegateFunction(overrides?: CallOverrides): Promise<string>;

  'deposit(uint256)'(
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'deposit(uint256,uint256)'(
    amount: PromiseOrValue<BigNumberish>,
    scheduleIndex: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  depositFor(
    account: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    scheduleIndex: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  depositWithSchedule(
    account: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    schedule: IStaking.StakingScheduleStruct,
    notional: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  destinations(
    overrides?: CallOverrides,
  ): Promise<[string, string] & { fxStateSender: string; destinationOnL2: string }>;

  getSchedules(overrides?: CallOverrides): Promise<IStaking.StakingScheduleInfoStructOutput[]>;

  getStakes(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<IStaking.StakingDetailsStructOutput[]>;

  initialize(
    _tokeToken: PromiseOrValue<string>,
    _manager: PromiseOrValue<string>,
    _treasury: PromiseOrValue<string>,
    _scheduleZeroNotional: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  manager(overrides?: CallOverrides): Promise<string>;

  nextScheduleIndex(overrides?: CallOverrides): Promise<BigNumber>;

  notionalAddresses(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  owner(overrides?: CallOverrides): Promise<string>;

  pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  permissionedDepositors(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  requestWithdrawal(
    amount: PromiseOrValue<BigNumberish>,
    scheduleIdx: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  requestedWithdrawals(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, BigNumber] & { minCycleIndex: BigNumber; amount: BigNumber }>;

  schedules(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber, boolean, boolean, BigNumber, boolean] & {
      cliff: BigNumber;
      duration: BigNumber;
      interval: BigNumber;
      setup: boolean;
      isActive: boolean;
      hardStart: BigNumber;
      isPublic: boolean;
    }
  >;

  setDestinations(
    _fxStateSender: PromiseOrValue<string>,
    _destinationOnL2: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setEventSend(
    _eventSendSet: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setNotionalAddresses(
    scheduleIdxArr: PromiseOrValue<BigNumberish>[],
    addresses: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setPermissionedDepositor(
    account: PromiseOrValue<string>,
    canDeposit: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setScheduleStatus(
    scheduleId: PromiseOrValue<BigNumberish>,
    activeBool: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setUserSchedules(
    account: PromiseOrValue<string>,
    userSchedulesIdxs: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  slash(
    accounts: PromiseOrValue<string>[],
    amounts: PromiseOrValue<BigNumberish>[],
    scheduleIndex: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  tokeToken(overrides?: CallOverrides): Promise<string>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  treasury(overrides?: CallOverrides): Promise<string>;

  unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  unvested(
    account: PromiseOrValue<string>,
    scheduleIndex: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  userStakingSchedules(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  userStakings(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
      initial: BigNumber;
      withdrawn: BigNumber;
      slashed: BigNumber;
      started: BigNumber;
      scheduleIx: BigNumber;
    }
  >;

  vested(
    account: PromiseOrValue<string>,
    scheduleIndex: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  'withdraw(uint256)'(
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'withdraw(uint256,uint256)'(
    amount: PromiseOrValue<BigNumberish>,
    scheduleIdx: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  withdrawalRequestsByIndex(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, BigNumber] & { minCycleIndex: BigNumber; amount: BigNumber }>;

  withheldLiquidity(overrides?: CallOverrides): Promise<BigNumber>;

  callStatic: {
    _eventSend(overrides?: CallOverrides): Promise<boolean>;

    addSchedule(
      schedule: IStaking.StakingScheduleStruct,
      notional: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    availableForWithdrawal(
      account: PromiseOrValue<string>,
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    delegateFunction(overrides?: CallOverrides): Promise<string>;

    'deposit(uint256)'(amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    'deposit(uint256,uint256)'(
      amount: PromiseOrValue<BigNumberish>,
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    depositFor(
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    depositWithSchedule(
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      schedule: IStaking.StakingScheduleStruct,
      notional: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    destinations(
      overrides?: CallOverrides,
    ): Promise<[string, string] & { fxStateSender: string; destinationOnL2: string }>;

    getSchedules(overrides?: CallOverrides): Promise<IStaking.StakingScheduleInfoStructOutput[]>;

    getStakes(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<IStaking.StakingDetailsStructOutput[]>;

    initialize(
      _tokeToken: PromiseOrValue<string>,
      _manager: PromiseOrValue<string>,
      _treasury: PromiseOrValue<string>,
      _scheduleZeroNotional: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    manager(overrides?: CallOverrides): Promise<string>;

    nextScheduleIndex(overrides?: CallOverrides): Promise<BigNumber>;

    notionalAddresses(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    pause(overrides?: CallOverrides): Promise<void>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    permissionedDepositors(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    requestWithdrawal(
      amount: PromiseOrValue<BigNumberish>,
      scheduleIdx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    requestedWithdrawals(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { minCycleIndex: BigNumber; amount: BigNumber }>;

    schedules(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, boolean, boolean, BigNumber, boolean] & {
        cliff: BigNumber;
        duration: BigNumber;
        interval: BigNumber;
        setup: boolean;
        isActive: boolean;
        hardStart: BigNumber;
        isPublic: boolean;
      }
    >;

    setDestinations(
      _fxStateSender: PromiseOrValue<string>,
      _destinationOnL2: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setEventSend(_eventSendSet: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;

    setNotionalAddresses(
      scheduleIdxArr: PromiseOrValue<BigNumberish>[],
      addresses: PromiseOrValue<string>[],
      overrides?: CallOverrides,
    ): Promise<void>;

    setPermissionedDepositor(
      account: PromiseOrValue<string>,
      canDeposit: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setScheduleStatus(
      scheduleId: PromiseOrValue<BigNumberish>,
      activeBool: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setUserSchedules(
      account: PromiseOrValue<string>,
      userSchedulesIdxs: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<void>;

    slash(
      accounts: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    tokeToken(overrides?: CallOverrides): Promise<string>;

    transferOwnership(newOwner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    treasury(overrides?: CallOverrides): Promise<string>;

    unpause(overrides?: CallOverrides): Promise<void>;

    unvested(
      account: PromiseOrValue<string>,
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    userStakingSchedules(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    userStakings(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        initial: BigNumber;
        withdrawn: BigNumber;
        slashed: BigNumber;
        started: BigNumber;
        scheduleIx: BigNumber;
      }
    >;

    vested(
      account: PromiseOrValue<string>,
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    'withdraw(uint256)'(amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    'withdraw(uint256,uint256)'(
      amount: PromiseOrValue<BigNumberish>,
      scheduleIdx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    withdrawalRequestsByIndex(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { minCycleIndex: BigNumber; amount: BigNumber }>;

    withheldLiquidity(overrides?: CallOverrides): Promise<BigNumber>;
  };

  filters: {
    'Deposited(address,uint256,uint256)'(account?: null, amount?: null, scheduleIx?: null): DepositedEventFilter;
    Deposited(account?: null, amount?: null, scheduleIx?: null): DepositedEventFilter;

    'DestinationsSet(address,address)'(fxStateSender?: null, destinationOnL2?: null): DestinationsSetEventFilter;
    DestinationsSet(fxStateSender?: null, destinationOnL2?: null): DestinationsSetEventFilter;

    'EventSendSet(bool)'(eventSendSet?: null): EventSendSetEventFilter;
    EventSendSet(eventSendSet?: null): EventSendSetEventFilter;

    'NotionalAddressesSet(uint256[],address[])'(scheduleIdxs?: null, addresses?: null): NotionalAddressesSetEventFilter;
    NotionalAddressesSet(scheduleIdxs?: null, addresses?: null): NotionalAddressesSetEventFilter;

    'OwnershipTransferred(address,address)'(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;

    'Paused(address)'(account?: null): PausedEventFilter;
    Paused(account?: null): PausedEventFilter;

    'PermissionedDepositorSet(address,bool)'(depositor?: null, allowed?: null): PermissionedDepositorSetEventFilter;
    PermissionedDepositorSet(depositor?: null, allowed?: null): PermissionedDepositorSetEventFilter;

    'QueuedTransferRejected(address,uint256,uint256,uint256,address)'(
      from?: null,
      scheduleFrom?: null,
      scheduleTo?: null,
      amount?: null,
      to?: null,
    ): QueuedTransferRejectedEventFilter;
    QueuedTransferRejected(
      from?: null,
      scheduleFrom?: null,
      scheduleTo?: null,
      amount?: null,
      to?: null,
    ): QueuedTransferRejectedEventFilter;

    'QueuedTransferRemoved(address,uint256,uint256,uint256,address)'(
      from?: null,
      scheduleFrom?: null,
      scheduleTo?: null,
      amount?: null,
      to?: null,
    ): QueuedTransferRemovedEventFilter;
    QueuedTransferRemoved(
      from?: null,
      scheduleFrom?: null,
      scheduleTo?: null,
      amount?: null,
      to?: null,
    ): QueuedTransferRemovedEventFilter;

    'ScheduleAdded(uint256,uint256,uint256,uint256,bool,bool,uint256,address)'(
      scheduleIndex?: null,
      cliff?: null,
      duration?: null,
      interval?: null,
      setup?: null,
      isActive?: null,
      hardStart?: null,
      notional?: null,
    ): ScheduleAddedEventFilter;
    ScheduleAdded(
      scheduleIndex?: null,
      cliff?: null,
      duration?: null,
      interval?: null,
      setup?: null,
      isActive?: null,
      hardStart?: null,
      notional?: null,
    ): ScheduleAddedEventFilter;

    'ScheduleRemoved(uint256)'(scheduleIndex?: null): ScheduleRemovedEventFilter;
    ScheduleRemoved(scheduleIndex?: null): ScheduleRemovedEventFilter;

    'ScheduleStatusSet(uint256,bool)'(scheduleId?: null, isActive?: null): ScheduleStatusSetEventFilter;
    ScheduleStatusSet(scheduleId?: null, isActive?: null): ScheduleStatusSetEventFilter;

    'Slashed(address,uint256,uint256)'(account?: null, amount?: null, scheduleIx?: null): SlashedEventFilter;
    Slashed(account?: null, amount?: null, scheduleIx?: null): SlashedEventFilter;

    'StakeTransferred(address,uint256,uint256,uint256,address)'(
      from?: null,
      scheduleFrom?: null,
      scheduleTo?: null,
      amount?: null,
      to?: null,
    ): StakeTransferredEventFilter;
    StakeTransferred(
      from?: null,
      scheduleFrom?: null,
      scheduleTo?: null,
      amount?: null,
      to?: null,
    ): StakeTransferredEventFilter;

    'TransferApproverSet(address)'(approverAddress?: null): TransferApproverSetEventFilter;
    TransferApproverSet(approverAddress?: null): TransferApproverSetEventFilter;

    'TransferQueued(address,uint256,uint256,uint256,address)'(
      from?: null,
      scheduleFrom?: null,
      scheduleTo?: null,
      amount?: null,
      to?: null,
    ): TransferQueuedEventFilter;
    TransferQueued(
      from?: null,
      scheduleFrom?: null,
      scheduleTo?: null,
      amount?: null,
      to?: null,
    ): TransferQueuedEventFilter;

    'Unpaused(address)'(account?: null): UnpausedEventFilter;
    Unpaused(account?: null): UnpausedEventFilter;

    'UserSchedulesSet(address,uint256[])'(account?: null, userSchedulesIdxs?: null): UserSchedulesSetEventFilter;
    UserSchedulesSet(account?: null, userSchedulesIdxs?: null): UserSchedulesSetEventFilter;

    'WithdrawCompleted(address,uint256,uint256)'(
      account?: null,
      scheduleIdx?: null,
      amount?: null,
    ): WithdrawCompletedEventFilter;
    WithdrawCompleted(account?: null, scheduleIdx?: null, amount?: null): WithdrawCompletedEventFilter;

    'WithdrawalRequested(address,uint256,uint256)'(
      account?: null,
      scheduleIdx?: null,
      amount?: null,
    ): WithdrawalRequestedEventFilter;
    WithdrawalRequested(account?: null, scheduleIdx?: null, amount?: null): WithdrawalRequestedEventFilter;

    'ZeroSweep(address,uint256,uint256)'(user?: null, amount?: null, scheduleFrom?: null): ZeroSweepEventFilter;
    ZeroSweep(user?: null, amount?: null, scheduleFrom?: null): ZeroSweepEventFilter;
  };

  estimateGas: {
    _eventSend(overrides?: CallOverrides): Promise<BigNumber>;

    addSchedule(
      schedule: IStaking.StakingScheduleStruct,
      notional: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    availableForWithdrawal(
      account: PromiseOrValue<string>,
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    delegateFunction(overrides?: CallOverrides): Promise<BigNumber>;

    'deposit(uint256)'(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'deposit(uint256,uint256)'(
      amount: PromiseOrValue<BigNumberish>,
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    depositFor(
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    depositWithSchedule(
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      schedule: IStaking.StakingScheduleStruct,
      notional: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    destinations(overrides?: CallOverrides): Promise<BigNumber>;

    getSchedules(overrides?: CallOverrides): Promise<BigNumber>;

    getStakes(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      _tokeToken: PromiseOrValue<string>,
      _manager: PromiseOrValue<string>,
      _treasury: PromiseOrValue<string>,
      _scheduleZeroNotional: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    manager(overrides?: CallOverrides): Promise<BigNumber>;

    nextScheduleIndex(overrides?: CallOverrides): Promise<BigNumber>;

    notionalAddresses(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    permissionedDepositors(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    requestWithdrawal(
      amount: PromiseOrValue<BigNumberish>,
      scheduleIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    requestedWithdrawals(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    schedules(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    setDestinations(
      _fxStateSender: PromiseOrValue<string>,
      _destinationOnL2: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setEventSend(
      _eventSendSet: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setNotionalAddresses(
      scheduleIdxArr: PromiseOrValue<BigNumberish>[],
      addresses: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setPermissionedDepositor(
      account: PromiseOrValue<string>,
      canDeposit: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setScheduleStatus(
      scheduleId: PromiseOrValue<BigNumberish>,
      activeBool: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setUserSchedules(
      account: PromiseOrValue<string>,
      userSchedulesIdxs: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    slash(
      accounts: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    tokeToken(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    treasury(overrides?: CallOverrides): Promise<BigNumber>;

    unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    unvested(
      account: PromiseOrValue<string>,
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    userStakingSchedules(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    userStakings(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    vested(
      account: PromiseOrValue<string>,
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    'withdraw(uint256)'(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'withdraw(uint256,uint256)'(
      amount: PromiseOrValue<BigNumberish>,
      scheduleIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    withdrawalRequestsByIndex(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    withheldLiquidity(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    _eventSend(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    addSchedule(
      schedule: IStaking.StakingScheduleStruct,
      notional: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    availableForWithdrawal(
      account: PromiseOrValue<string>,
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    delegateFunction(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'deposit(uint256)'(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'deposit(uint256,uint256)'(
      amount: PromiseOrValue<BigNumberish>,
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    depositFor(
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    depositWithSchedule(
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      schedule: IStaking.StakingScheduleStruct,
      notional: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    destinations(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getSchedules(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getStakes(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initialize(
      _tokeToken: PromiseOrValue<string>,
      _manager: PromiseOrValue<string>,
      _treasury: PromiseOrValue<string>,
      _scheduleZeroNotional: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    manager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nextScheduleIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    notionalAddresses(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    permissionedDepositors(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    requestWithdrawal(
      amount: PromiseOrValue<BigNumberish>,
      scheduleIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    requestedWithdrawals(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    schedules(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setDestinations(
      _fxStateSender: PromiseOrValue<string>,
      _destinationOnL2: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setEventSend(
      _eventSendSet: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setNotionalAddresses(
      scheduleIdxArr: PromiseOrValue<BigNumberish>[],
      addresses: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setPermissionedDepositor(
      account: PromiseOrValue<string>,
      canDeposit: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setScheduleStatus(
      scheduleId: PromiseOrValue<BigNumberish>,
      activeBool: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setUserSchedules(
      account: PromiseOrValue<string>,
      userSchedulesIdxs: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    slash(
      accounts: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    tokeToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    treasury(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    unvested(
      account: PromiseOrValue<string>,
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    userStakingSchedules(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    userStakings(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    vested(
      account: PromiseOrValue<string>,
      scheduleIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    'withdraw(uint256)'(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'withdraw(uint256,uint256)'(
      amount: PromiseOrValue<BigNumberish>,
      scheduleIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    withdrawalRequestsByIndex(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    withheldLiquidity(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}

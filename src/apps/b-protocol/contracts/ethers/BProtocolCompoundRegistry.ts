/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export interface BProtocolCompoundRegistryInterface extends utils.Interface {
  functions: {
    'avatarImpl()': FunctionFragment;
    'avatarLength()': FunctionFragment;
    'avatarList()': FunctionFragment;
    'avatarOf(address)': FunctionFragment;
    'avatars(uint256)': FunctionFragment;
    'bComptroller()': FunctionFragment;
    'cEther()': FunctionFragment;
    'comp()': FunctionFragment;
    'compVoter()': FunctionFragment;
    'comptroller()': FunctionFragment;
    'delegate(address,address)': FunctionFragment;
    'delegateAndExecuteOnce(address,address,bytes)': FunctionFragment;
    'delegateAvatar(address)': FunctionFragment;
    'doesAvatarExist(address)': FunctionFragment;
    'doesAvatarExistFor(address)': FunctionFragment;
    'dummyCaller()': FunctionFragment;
    'getAvatar(address)': FunctionFragment;
    'isOwner()': FunctionFragment;
    'newAvatar()': FunctionFragment;
    'owner()': FunctionFragment;
    'ownerOf(address)': FunctionFragment;
    'pool()': FunctionFragment;
    'renounceOwnership()': FunctionFragment;
    'revokeDelegateAvatar(address)': FunctionFragment;
    'score()': FunctionFragment;
    'setPool(address)': FunctionFragment;
    'setScore(address)': FunctionFragment;
    'setWhitelistAvatarCall(address,bytes4,bool)': FunctionFragment;
    'transferOwnership(address)': FunctionFragment;
    'whitelistedAvatarCalls(address,bytes4)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'avatarImpl'
      | 'avatarLength'
      | 'avatarList'
      | 'avatarOf'
      | 'avatars'
      | 'bComptroller'
      | 'cEther'
      | 'comp'
      | 'compVoter'
      | 'comptroller'
      | 'delegate'
      | 'delegateAndExecuteOnce'
      | 'delegateAvatar'
      | 'doesAvatarExist'
      | 'doesAvatarExistFor'
      | 'dummyCaller'
      | 'getAvatar'
      | 'isOwner'
      | 'newAvatar'
      | 'owner'
      | 'ownerOf'
      | 'pool'
      | 'renounceOwnership'
      | 'revokeDelegateAvatar'
      | 'score'
      | 'setPool'
      | 'setScore'
      | 'setWhitelistAvatarCall'
      | 'transferOwnership'
      | 'whitelistedAvatarCalls',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'avatarImpl', values?: undefined): string;
  encodeFunctionData(functionFragment: 'avatarLength', values?: undefined): string;
  encodeFunctionData(functionFragment: 'avatarList', values?: undefined): string;
  encodeFunctionData(functionFragment: 'avatarOf', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'avatars', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'bComptroller', values?: undefined): string;
  encodeFunctionData(functionFragment: 'cEther', values?: undefined): string;
  encodeFunctionData(functionFragment: 'comp', values?: undefined): string;
  encodeFunctionData(functionFragment: 'compVoter', values?: undefined): string;
  encodeFunctionData(functionFragment: 'comptroller', values?: undefined): string;
  encodeFunctionData(functionFragment: 'delegate', values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'delegateAndExecuteOnce',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(functionFragment: 'delegateAvatar', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'doesAvatarExist', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'doesAvatarExistFor', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'dummyCaller', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getAvatar', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'isOwner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'newAvatar', values?: undefined): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'ownerOf', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'pool', values?: undefined): string;
  encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'revokeDelegateAvatar', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'score', values?: undefined): string;
  encodeFunctionData(functionFragment: 'setPool', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setScore', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'setWhitelistAvatarCall',
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'transferOwnership', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'whitelistedAvatarCalls',
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>],
  ): string;

  decodeFunctionResult(functionFragment: 'avatarImpl', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'avatarLength', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'avatarList', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'avatarOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'avatars', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'bComptroller', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cEther', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'comp', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'compVoter', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'comptroller', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'delegate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'delegateAndExecuteOnce', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'delegateAvatar', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'doesAvatarExist', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'doesAvatarExistFor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'dummyCaller', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getAvatar', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'newAvatar', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'ownerOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pool', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'revokeDelegateAvatar', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'score', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setPool', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setScore', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setWhitelistAvatarCall', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'whitelistedAvatarCalls', data: BytesLike): Result;

  events: {
    'AvatarCallWhitelisted(address,bytes4,bool)': EventFragment;
    'Delegate(address,address,address)': EventFragment;
    'NewAvatar(address,address)': EventFragment;
    'NewPool(address,address)': EventFragment;
    'NewScore(address,address)': EventFragment;
    'OwnershipTransferred(address,address)': EventFragment;
    'RevokeDelegate(address,address,address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'AvatarCallWhitelisted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Delegate'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NewAvatar'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NewPool'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NewScore'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RevokeDelegate'): EventFragment;
}

export interface AvatarCallWhitelistedEventObject {
  target: string;
  functionSig: string;
  whitelist: boolean;
}
export type AvatarCallWhitelistedEvent = TypedEvent<[string, string, boolean], AvatarCallWhitelistedEventObject>;

export type AvatarCallWhitelistedEventFilter = TypedEventFilter<AvatarCallWhitelistedEvent>;

export interface DelegateEventObject {
  delegator: string;
  avatar: string;
  delegatee: string;
}
export type DelegateEvent = TypedEvent<[string, string, string], DelegateEventObject>;

export type DelegateEventFilter = TypedEventFilter<DelegateEvent>;

export interface NewAvatarEventObject {
  avatar: string;
  owner: string;
}
export type NewAvatarEvent = TypedEvent<[string, string], NewAvatarEventObject>;

export type NewAvatarEventFilter = TypedEventFilter<NewAvatarEvent>;

export interface NewPoolEventObject {
  oldPool: string;
  newPool: string;
}
export type NewPoolEvent = TypedEvent<[string, string], NewPoolEventObject>;

export type NewPoolEventFilter = TypedEventFilter<NewPoolEvent>;

export interface NewScoreEventObject {
  oldScore: string;
  newScore: string;
}
export type NewScoreEvent = TypedEvent<[string, string], NewScoreEventObject>;

export type NewScoreEventFilter = TypedEventFilter<NewScoreEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<[string, string], OwnershipTransferredEventObject>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export interface RevokeDelegateEventObject {
  delegator: string;
  avatar: string;
  delegatee: string;
}
export type RevokeDelegateEvent = TypedEvent<[string, string, string], RevokeDelegateEventObject>;

export type RevokeDelegateEventFilter = TypedEventFilter<RevokeDelegateEvent>;

export interface BProtocolCompoundRegistry extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: BProtocolCompoundRegistryInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    avatarImpl(overrides?: CallOverrides): Promise<[string]>;

    avatarLength(overrides?: CallOverrides): Promise<[BigNumber]>;

    avatarList(overrides?: CallOverrides): Promise<[string[]]>;

    avatarOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;

    avatars(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    bComptroller(overrides?: CallOverrides): Promise<[string]>;

    cEther(overrides?: CallOverrides): Promise<[string]>;

    comp(overrides?: CallOverrides): Promise<[string]>;

    compVoter(overrides?: CallOverrides): Promise<[string]>;

    comptroller(overrides?: CallOverrides): Promise<[string]>;

    delegate(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    delegateAndExecuteOnce(
      delegatee: PromiseOrValue<string>,
      target: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    delegateAvatar(
      delegatee: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    doesAvatarExist(_avatar: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    doesAvatarExistFor(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    dummyCaller(overrides?: CallOverrides): Promise<[string]>;

    getAvatar(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    isOwner(overrides?: CallOverrides): Promise<[boolean]>;

    newAvatar(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    ownerOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;

    pool(overrides?: CallOverrides): Promise<[string]>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    revokeDelegateAvatar(
      delegatee: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    score(overrides?: CallOverrides): Promise<[string]>;

    setPool(
      newPool: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setScore(
      newScore: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setWhitelistAvatarCall(
      target: PromiseOrValue<string>,
      functionSig: PromiseOrValue<BytesLike>,
      list: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    whitelistedAvatarCalls(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;
  };

  avatarImpl(overrides?: CallOverrides): Promise<string>;

  avatarLength(overrides?: CallOverrides): Promise<BigNumber>;

  avatarList(overrides?: CallOverrides): Promise<string[]>;

  avatarOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  avatars(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  bComptroller(overrides?: CallOverrides): Promise<string>;

  cEther(overrides?: CallOverrides): Promise<string>;

  comp(overrides?: CallOverrides): Promise<string>;

  compVoter(overrides?: CallOverrides): Promise<string>;

  comptroller(overrides?: CallOverrides): Promise<string>;

  delegate(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  delegateAndExecuteOnce(
    delegatee: PromiseOrValue<string>,
    target: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  delegateAvatar(
    delegatee: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  doesAvatarExist(_avatar: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  doesAvatarExistFor(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  dummyCaller(overrides?: CallOverrides): Promise<string>;

  getAvatar(
    _owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  isOwner(overrides?: CallOverrides): Promise<boolean>;

  newAvatar(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  ownerOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  pool(overrides?: CallOverrides): Promise<string>;

  renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  revokeDelegateAvatar(
    delegatee: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  score(overrides?: CallOverrides): Promise<string>;

  setPool(
    newPool: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setScore(
    newScore: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setWhitelistAvatarCall(
    target: PromiseOrValue<string>,
    functionSig: PromiseOrValue<BytesLike>,
    list: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  whitelistedAvatarCalls(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  callStatic: {
    avatarImpl(overrides?: CallOverrides): Promise<string>;

    avatarLength(overrides?: CallOverrides): Promise<BigNumber>;

    avatarList(overrides?: CallOverrides): Promise<string[]>;

    avatarOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    avatars(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    bComptroller(overrides?: CallOverrides): Promise<string>;

    cEther(overrides?: CallOverrides): Promise<string>;

    comp(overrides?: CallOverrides): Promise<string>;

    compVoter(overrides?: CallOverrides): Promise<string>;

    comptroller(overrides?: CallOverrides): Promise<string>;

    delegate(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    delegateAndExecuteOnce(
      delegatee: PromiseOrValue<string>,
      target: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    delegateAvatar(delegatee: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    doesAvatarExist(_avatar: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    doesAvatarExistFor(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    dummyCaller(overrides?: CallOverrides): Promise<string>;

    getAvatar(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    isOwner(overrides?: CallOverrides): Promise<boolean>;

    newAvatar(overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    ownerOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    pool(overrides?: CallOverrides): Promise<string>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    revokeDelegateAvatar(delegatee: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    score(overrides?: CallOverrides): Promise<string>;

    setPool(newPool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setScore(newScore: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setWhitelistAvatarCall(
      target: PromiseOrValue<string>,
      functionSig: PromiseOrValue<BytesLike>,
      list: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    transferOwnership(newOwner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    whitelistedAvatarCalls(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<boolean>;
  };

  filters: {
    'AvatarCallWhitelisted(address,bytes4,bool)'(
      target?: null,
      functionSig?: null,
      whitelist?: null,
    ): AvatarCallWhitelistedEventFilter;
    AvatarCallWhitelisted(target?: null, functionSig?: null, whitelist?: null): AvatarCallWhitelistedEventFilter;

    'Delegate(address,address,address)'(
      delegator?: PromiseOrValue<string> | null,
      avatar?: null,
      delegatee?: null,
    ): DelegateEventFilter;
    Delegate(delegator?: PromiseOrValue<string> | null, avatar?: null, delegatee?: null): DelegateEventFilter;

    'NewAvatar(address,address)'(avatar?: PromiseOrValue<string> | null, owner?: null): NewAvatarEventFilter;
    NewAvatar(avatar?: PromiseOrValue<string> | null, owner?: null): NewAvatarEventFilter;

    'NewPool(address,address)'(oldPool?: null, newPool?: null): NewPoolEventFilter;
    NewPool(oldPool?: null, newPool?: null): NewPoolEventFilter;

    'NewScore(address,address)'(oldScore?: null, newScore?: null): NewScoreEventFilter;
    NewScore(oldScore?: null, newScore?: null): NewScoreEventFilter;

    'OwnershipTransferred(address,address)'(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;

    'RevokeDelegate(address,address,address)'(
      delegator?: PromiseOrValue<string> | null,
      avatar?: null,
      delegatee?: null,
    ): RevokeDelegateEventFilter;
    RevokeDelegate(
      delegator?: PromiseOrValue<string> | null,
      avatar?: null,
      delegatee?: null,
    ): RevokeDelegateEventFilter;
  };

  estimateGas: {
    avatarImpl(overrides?: CallOverrides): Promise<BigNumber>;

    avatarLength(overrides?: CallOverrides): Promise<BigNumber>;

    avatarList(overrides?: CallOverrides): Promise<BigNumber>;

    avatarOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    avatars(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    bComptroller(overrides?: CallOverrides): Promise<BigNumber>;

    cEther(overrides?: CallOverrides): Promise<BigNumber>;

    comp(overrides?: CallOverrides): Promise<BigNumber>;

    compVoter(overrides?: CallOverrides): Promise<BigNumber>;

    comptroller(overrides?: CallOverrides): Promise<BigNumber>;

    delegate(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    delegateAndExecuteOnce(
      delegatee: PromiseOrValue<string>,
      target: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    delegateAvatar(
      delegatee: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    doesAvatarExist(_avatar: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    doesAvatarExistFor(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    dummyCaller(overrides?: CallOverrides): Promise<BigNumber>;

    getAvatar(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    isOwner(overrides?: CallOverrides): Promise<BigNumber>;

    newAvatar(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    ownerOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    pool(overrides?: CallOverrides): Promise<BigNumber>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    revokeDelegateAvatar(
      delegatee: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    score(overrides?: CallOverrides): Promise<BigNumber>;

    setPool(
      newPool: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setScore(
      newScore: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setWhitelistAvatarCall(
      target: PromiseOrValue<string>,
      functionSig: PromiseOrValue<BytesLike>,
      list: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    whitelistedAvatarCalls(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    avatarImpl(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    avatarLength(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    avatarList(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    avatarOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    avatars(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bComptroller(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    cEther(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    comp(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    compVoter(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    comptroller(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    delegate(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    delegateAndExecuteOnce(
      delegatee: PromiseOrValue<string>,
      target: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    delegateAvatar(
      delegatee: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    doesAvatarExist(_avatar: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    doesAvatarExistFor(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    dummyCaller(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getAvatar(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    isOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    newAvatar(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ownerOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pool(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    revokeDelegateAvatar(
      delegatee: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    score(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setPool(
      newPool: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setScore(
      newScore: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setWhitelistAvatarCall(
      target: PromiseOrValue<string>,
      functionSig: PromiseOrValue<BytesLike>,
      list: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    whitelistedAvatarCalls(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;
  };
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export interface PolygonStakeManagerInterface extends utils.Interface {
  functions: {
    'CHECKPOINT_REWARD()': FunctionFragment;
    'NFTContract()': FunctionFragment;
    'NFTCounter()': FunctionFragment;
    'WITHDRAWAL_DELAY()': FunctionFragment;
    'accountStateRoot()': FunctionFragment;
    'auctionPeriod()': FunctionFragment;
    'changeRootChain(address)': FunctionFragment;
    'checkPointBlockInterval()': FunctionFragment;
    'checkSignatures(uint256,bytes32,bytes32,address,uint256[3][])': FunctionFragment;
    'checkpointRewardDelta()': FunctionFragment;
    'claimFee(uint256,uint256,bytes)': FunctionFragment;
    'confirmAuctionBid(uint256,uint256)': FunctionFragment;
    'currentEpoch()': FunctionFragment;
    'currentValidatorSetSize()': FunctionFragment;
    'currentValidatorSetTotalStake()': FunctionFragment;
    'decreaseValidatorDelegatedAmount(uint256,uint256)': FunctionFragment;
    'delegatedAmount(uint256)': FunctionFragment;
    'delegationDeposit(uint256,uint256,address)': FunctionFragment;
    'delegationEnabled()': FunctionFragment;
    'delegatorsReward(uint256)': FunctionFragment;
    'dethroneAndStake(address,uint256,uint256,uint256,bool,bytes)': FunctionFragment;
    'drain(address,uint256)': FunctionFragment;
    'drainValidatorShares(uint256,address,address,uint256)': FunctionFragment;
    'dynasty()': FunctionFragment;
    'epoch()': FunctionFragment;
    'eventsHub()': FunctionFragment;
    'extensionCode()': FunctionFragment;
    'forceUnstake(uint256)': FunctionFragment;
    'getRegistry()': FunctionFragment;
    'getValidatorContract(uint256)': FunctionFragment;
    'getValidatorId(address)': FunctionFragment;
    'governance()': FunctionFragment;
    'initialize(address,address,address,address,address,address,address,address,address)': FunctionFragment;
    'insertSigners(address[])': FunctionFragment;
    'isOwner()': FunctionFragment;
    'isValidator(uint256)': FunctionFragment;
    'latestSignerUpdateEpoch(uint256)': FunctionFragment;
    'lock()': FunctionFragment;
    'locked()': FunctionFragment;
    'logger()': FunctionFragment;
    'maxRewardedCheckpoints()': FunctionFragment;
    'migrateDelegation(uint256,uint256,uint256)': FunctionFragment;
    'migrateValidatorsData(uint256,uint256)': FunctionFragment;
    'minDeposit()': FunctionFragment;
    'minHeimdallFee()': FunctionFragment;
    'owner()': FunctionFragment;
    'ownerOf(uint256)': FunctionFragment;
    'prevBlockInterval()': FunctionFragment;
    'proposerBonus()': FunctionFragment;
    'registry()': FunctionFragment;
    'reinitialize(address,address,address,address)': FunctionFragment;
    'renounceOwnership()': FunctionFragment;
    'replacementCoolDown()': FunctionFragment;
    'restake(uint256,uint256,bool)': FunctionFragment;
    'rewardDecreasePerCheckpoint()': FunctionFragment;
    'rewardPerStake()': FunctionFragment;
    'rootChain()': FunctionFragment;
    'setCurrentEpoch(uint256)': FunctionFragment;
    'setDelegationEnabled(bool)': FunctionFragment;
    'setStakingToken(address)': FunctionFragment;
    'signerToValidator(address)': FunctionFragment;
    'signerUpdateLimit()': FunctionFragment;
    'signers(uint256)': FunctionFragment;
    'slash(bytes)': FunctionFragment;
    'stakeFor(address,uint256,uint256,bool,bytes)': FunctionFragment;
    'startAuction(uint256,uint256,bool,bytes)': FunctionFragment;
    'stopAuctions(uint256)': FunctionFragment;
    'token()': FunctionFragment;
    'topUpForFee(address,uint256)': FunctionFragment;
    'totalHeimdallFee()': FunctionFragment;
    'totalRewards()': FunctionFragment;
    'totalRewardsLiquidated()': FunctionFragment;
    'totalStaked()': FunctionFragment;
    'totalStakedFor(address)': FunctionFragment;
    'transferFunds(uint256,uint256,address)': FunctionFragment;
    'transferOwnership(address)': FunctionFragment;
    'unjail(uint256)': FunctionFragment;
    'unlock()': FunctionFragment;
    'unstake(uint256)': FunctionFragment;
    'unstakeClaim(uint256)': FunctionFragment;
    'updateCheckPointBlockInterval(uint256)': FunctionFragment;
    'updateCheckpointReward(uint256)': FunctionFragment;
    'updateCheckpointRewardParams(uint256,uint256,uint256)': FunctionFragment;
    'updateCommissionRate(uint256,uint256)': FunctionFragment;
    'updateDynastyValue(uint256)': FunctionFragment;
    'updateMinAmounts(uint256,uint256)': FunctionFragment;
    'updateProposerBonus(uint256)': FunctionFragment;
    'updateSigner(uint256,bytes)': FunctionFragment;
    'updateSignerUpdateLimit(uint256)': FunctionFragment;
    'updateValidatorContractAddress(uint256,address)': FunctionFragment;
    'updateValidatorDelegation(bool)': FunctionFragment;
    'updateValidatorState(uint256,int256)': FunctionFragment;
    'updateValidatorThreshold(uint256)': FunctionFragment;
    'userFeeExit(address)': FunctionFragment;
    'validatorAuction(uint256)': FunctionFragment;
    'validatorReward(uint256)': FunctionFragment;
    'validatorShareFactory()': FunctionFragment;
    'validatorStake(uint256)': FunctionFragment;
    'validatorState()': FunctionFragment;
    'validatorStateChanges(uint256)': FunctionFragment;
    'validatorThreshold()': FunctionFragment;
    'validators(uint256)': FunctionFragment;
    'withdrawDelegatorsReward(uint256)': FunctionFragment;
    'withdrawRewards(uint256)': FunctionFragment;
    'withdrawalDelay()': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'CHECKPOINT_REWARD'
      | 'NFTContract'
      | 'NFTCounter'
      | 'WITHDRAWAL_DELAY'
      | 'accountStateRoot'
      | 'auctionPeriod'
      | 'changeRootChain'
      | 'checkPointBlockInterval'
      | 'checkSignatures'
      | 'checkpointRewardDelta'
      | 'claimFee'
      | 'confirmAuctionBid'
      | 'currentEpoch'
      | 'currentValidatorSetSize'
      | 'currentValidatorSetTotalStake'
      | 'decreaseValidatorDelegatedAmount'
      | 'delegatedAmount'
      | 'delegationDeposit'
      | 'delegationEnabled'
      | 'delegatorsReward'
      | 'dethroneAndStake'
      | 'drain'
      | 'drainValidatorShares'
      | 'dynasty'
      | 'epoch'
      | 'eventsHub'
      | 'extensionCode'
      | 'forceUnstake'
      | 'getRegistry'
      | 'getValidatorContract'
      | 'getValidatorId'
      | 'governance'
      | 'initialize'
      | 'insertSigners'
      | 'isOwner'
      | 'isValidator'
      | 'latestSignerUpdateEpoch'
      | 'lock'
      | 'locked'
      | 'logger'
      | 'maxRewardedCheckpoints'
      | 'migrateDelegation'
      | 'migrateValidatorsData'
      | 'minDeposit'
      | 'minHeimdallFee'
      | 'owner'
      | 'ownerOf'
      | 'prevBlockInterval'
      | 'proposerBonus'
      | 'registry'
      | 'reinitialize'
      | 'renounceOwnership'
      | 'replacementCoolDown'
      | 'restake'
      | 'rewardDecreasePerCheckpoint'
      | 'rewardPerStake'
      | 'rootChain'
      | 'setCurrentEpoch'
      | 'setDelegationEnabled'
      | 'setStakingToken'
      | 'signerToValidator'
      | 'signerUpdateLimit'
      | 'signers'
      | 'slash'
      | 'stakeFor'
      | 'startAuction'
      | 'stopAuctions'
      | 'token'
      | 'topUpForFee'
      | 'totalHeimdallFee'
      | 'totalRewards'
      | 'totalRewardsLiquidated'
      | 'totalStaked'
      | 'totalStakedFor'
      | 'transferFunds'
      | 'transferOwnership'
      | 'unjail'
      | 'unlock'
      | 'unstake'
      | 'unstakeClaim'
      | 'updateCheckPointBlockInterval'
      | 'updateCheckpointReward'
      | 'updateCheckpointRewardParams'
      | 'updateCommissionRate'
      | 'updateDynastyValue'
      | 'updateMinAmounts'
      | 'updateProposerBonus'
      | 'updateSigner'
      | 'updateSignerUpdateLimit'
      | 'updateValidatorContractAddress'
      | 'updateValidatorDelegation'
      | 'updateValidatorState'
      | 'updateValidatorThreshold'
      | 'userFeeExit'
      | 'validatorAuction'
      | 'validatorReward'
      | 'validatorShareFactory'
      | 'validatorStake'
      | 'validatorState'
      | 'validatorStateChanges'
      | 'validatorThreshold'
      | 'validators'
      | 'withdrawDelegatorsReward'
      | 'withdrawRewards'
      | 'withdrawalDelay',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'CHECKPOINT_REWARD', values?: undefined): string;
  encodeFunctionData(functionFragment: 'NFTContract', values?: undefined): string;
  encodeFunctionData(functionFragment: 'NFTCounter', values?: undefined): string;
  encodeFunctionData(functionFragment: 'WITHDRAWAL_DELAY', values?: undefined): string;
  encodeFunctionData(functionFragment: 'accountStateRoot', values?: undefined): string;
  encodeFunctionData(functionFragment: 'auctionPeriod', values?: undefined): string;
  encodeFunctionData(functionFragment: 'changeRootChain', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'checkPointBlockInterval', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'checkSignatures',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>][],
    ],
  ): string;
  encodeFunctionData(functionFragment: 'checkpointRewardDelta', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'claimFee',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'confirmAuctionBid',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'currentEpoch', values?: undefined): string;
  encodeFunctionData(functionFragment: 'currentValidatorSetSize', values?: undefined): string;
  encodeFunctionData(functionFragment: 'currentValidatorSetTotalStake', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'decreaseValidatorDelegatedAmount',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'delegatedAmount', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'delegationDeposit',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'delegationEnabled', values?: undefined): string;
  encodeFunctionData(functionFragment: 'delegatorsReward', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'dethroneAndStake',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'drain', values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'drainValidatorShares',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'dynasty', values?: undefined): string;
  encodeFunctionData(functionFragment: 'epoch', values?: undefined): string;
  encodeFunctionData(functionFragment: 'eventsHub', values?: undefined): string;
  encodeFunctionData(functionFragment: 'extensionCode', values?: undefined): string;
  encodeFunctionData(functionFragment: 'forceUnstake', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getRegistry', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getValidatorContract', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getValidatorId', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'governance', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'initialize',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'insertSigners', values: [PromiseOrValue<string>[]]): string;
  encodeFunctionData(functionFragment: 'isOwner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'isValidator', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'latestSignerUpdateEpoch', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'lock', values?: undefined): string;
  encodeFunctionData(functionFragment: 'locked', values?: undefined): string;
  encodeFunctionData(functionFragment: 'logger', values?: undefined): string;
  encodeFunctionData(functionFragment: 'maxRewardedCheckpoints', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'migrateDelegation',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'migrateValidatorsData',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'minDeposit', values?: undefined): string;
  encodeFunctionData(functionFragment: 'minHeimdallFee', values?: undefined): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'ownerOf', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'prevBlockInterval', values?: undefined): string;
  encodeFunctionData(functionFragment: 'proposerBonus', values?: undefined): string;
  encodeFunctionData(functionFragment: 'registry', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'reinitialize',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'replacementCoolDown', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'restake',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'rewardDecreasePerCheckpoint', values?: undefined): string;
  encodeFunctionData(functionFragment: 'rewardPerStake', values?: undefined): string;
  encodeFunctionData(functionFragment: 'rootChain', values?: undefined): string;
  encodeFunctionData(functionFragment: 'setCurrentEpoch', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setDelegationEnabled', values: [PromiseOrValue<boolean>]): string;
  encodeFunctionData(functionFragment: 'setStakingToken', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'signerToValidator', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'signerUpdateLimit', values?: undefined): string;
  encodeFunctionData(functionFragment: 'signers', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'slash', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(
    functionFragment: 'stakeFor',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'startAuction',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'stopAuctions', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'token', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'topUpForFee',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'totalHeimdallFee', values?: undefined): string;
  encodeFunctionData(functionFragment: 'totalRewards', values?: undefined): string;
  encodeFunctionData(functionFragment: 'totalRewardsLiquidated', values?: undefined): string;
  encodeFunctionData(functionFragment: 'totalStaked', values?: undefined): string;
  encodeFunctionData(functionFragment: 'totalStakedFor', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'transferFunds',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'transferOwnership', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'unjail', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'unlock', values?: undefined): string;
  encodeFunctionData(functionFragment: 'unstake', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'unstakeClaim', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'updateCheckPointBlockInterval', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'updateCheckpointReward', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'updateCheckpointRewardParams',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'updateCommissionRate',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'updateDynastyValue', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'updateMinAmounts',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'updateProposerBonus', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'updateSigner',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(functionFragment: 'updateSignerUpdateLimit', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'updateValidatorContractAddress',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'updateValidatorDelegation', values: [PromiseOrValue<boolean>]): string;
  encodeFunctionData(
    functionFragment: 'updateValidatorState',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'updateValidatorThreshold', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'userFeeExit', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'validatorAuction', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'validatorReward', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'validatorShareFactory', values?: undefined): string;
  encodeFunctionData(functionFragment: 'validatorStake', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'validatorState', values?: undefined): string;
  encodeFunctionData(functionFragment: 'validatorStateChanges', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'validatorThreshold', values?: undefined): string;
  encodeFunctionData(functionFragment: 'validators', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'withdrawDelegatorsReward', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'withdrawRewards', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'withdrawalDelay', values?: undefined): string;

  decodeFunctionResult(functionFragment: 'CHECKPOINT_REWARD', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'NFTContract', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'NFTCounter', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'WITHDRAWAL_DELAY', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'accountStateRoot', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'auctionPeriod', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'changeRootChain', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'checkPointBlockInterval', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'checkSignatures', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'checkpointRewardDelta', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimFee', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'confirmAuctionBid', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'currentEpoch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'currentValidatorSetSize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'currentValidatorSetTotalStake', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'decreaseValidatorDelegatedAmount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'delegatedAmount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'delegationDeposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'delegationEnabled', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'delegatorsReward', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'dethroneAndStake', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'drain', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'drainValidatorShares', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'dynasty', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'epoch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'eventsHub', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'extensionCode', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'forceUnstake', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getRegistry', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getValidatorContract', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getValidatorId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'governance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'insertSigners', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isValidator', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'latestSignerUpdateEpoch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lock', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'locked', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'logger', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'maxRewardedCheckpoints', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'migrateDelegation', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'migrateValidatorsData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'minDeposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'minHeimdallFee', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'ownerOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'prevBlockInterval', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'proposerBonus', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'registry', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'reinitialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'replacementCoolDown', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'restake', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardDecreasePerCheckpoint', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardPerStake', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rootChain', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setCurrentEpoch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setDelegationEnabled', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setStakingToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'signerToValidator', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'signerUpdateLimit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'signers', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'slash', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stakeFor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'startAuction', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stopAuctions', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'token', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'topUpForFee', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalHeimdallFee', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalRewardsLiquidated', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalStaked', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalStakedFor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferFunds', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'unjail', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'unlock', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'unstake', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'unstakeClaim', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateCheckPointBlockInterval', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateCheckpointReward', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateCheckpointRewardParams', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateCommissionRate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateDynastyValue', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateMinAmounts', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateProposerBonus', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateSigner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateSignerUpdateLimit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateValidatorContractAddress', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateValidatorDelegation', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateValidatorState', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateValidatorThreshold', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userFeeExit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'validatorAuction', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'validatorReward', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'validatorShareFactory', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'validatorStake', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'validatorState', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'validatorStateChanges', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'validatorThreshold', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'validators', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawDelegatorsReward', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawalDelay', data: BytesLike): Result;

  events: {
    'OwnershipTransferred(address,address)': EventFragment;
    'RootChainChanged(address,address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RootChainChanged'): EventFragment;
}

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<[string, string], OwnershipTransferredEventObject>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export interface RootChainChangedEventObject {
  previousRootChain: string;
  newRootChain: string;
}
export type RootChainChangedEvent = TypedEvent<[string, string], RootChainChangedEventObject>;

export type RootChainChangedEventFilter = TypedEventFilter<RootChainChangedEvent>;

export interface PolygonStakeManager extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: PolygonStakeManagerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    CHECKPOINT_REWARD(overrides?: CallOverrides): Promise<[BigNumber]>;

    NFTContract(overrides?: CallOverrides): Promise<[string]>;

    NFTCounter(overrides?: CallOverrides): Promise<[BigNumber]>;

    WITHDRAWAL_DELAY(overrides?: CallOverrides): Promise<[BigNumber]>;

    accountStateRoot(overrides?: CallOverrides): Promise<[string]>;

    auctionPeriod(overrides?: CallOverrides): Promise<[BigNumber]>;

    changeRootChain(
      newRootChain: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    checkPointBlockInterval(overrides?: CallOverrides): Promise<[BigNumber]>;

    checkSignatures(
      blockInterval: PromiseOrValue<BigNumberish>,
      voteHash: PromiseOrValue<BytesLike>,
      stateRoot: PromiseOrValue<BytesLike>,
      proposer: PromiseOrValue<string>,
      sigs: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>][],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    checkpointRewardDelta(overrides?: CallOverrides): Promise<[BigNumber]>;

    claimFee(
      accumFeeAmount: PromiseOrValue<BigNumberish>,
      index: PromiseOrValue<BigNumberish>,
      proof: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    confirmAuctionBid(
      validatorId: PromiseOrValue<BigNumberish>,
      heimdallFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    currentEpoch(overrides?: CallOverrides): Promise<[BigNumber]>;

    currentValidatorSetSize(overrides?: CallOverrides): Promise<[BigNumber]>;

    currentValidatorSetTotalStake(overrides?: CallOverrides): Promise<[BigNumber]>;

    decreaseValidatorDelegatedAmount(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    delegatedAmount(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    delegationDeposit(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      delegator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    delegationEnabled(overrides?: CallOverrides): Promise<[boolean]>;

    delegatorsReward(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    dethroneAndStake(
      auctionUser: PromiseOrValue<string>,
      heimdallFee: PromiseOrValue<BigNumberish>,
      validatorId: PromiseOrValue<BigNumberish>,
      auctionAmount: PromiseOrValue<BigNumberish>,
      acceptDelegation: PromiseOrValue<boolean>,
      signerPubkey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    drain(
      destination: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    drainValidatorShares(
      validatorId: PromiseOrValue<BigNumberish>,
      tokenAddr: PromiseOrValue<string>,
      destination: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    dynasty(overrides?: CallOverrides): Promise<[BigNumber]>;

    epoch(overrides?: CallOverrides): Promise<[BigNumber]>;

    eventsHub(overrides?: CallOverrides): Promise<[string]>;

    extensionCode(overrides?: CallOverrides): Promise<[string]>;

    forceUnstake(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    getRegistry(overrides?: CallOverrides): Promise<[string]>;

    getValidatorContract(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    getValidatorId(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    governance(overrides?: CallOverrides): Promise<[string]>;

    initialize(
      _registry: PromiseOrValue<string>,
      _rootchain: PromiseOrValue<string>,
      _token: PromiseOrValue<string>,
      _NFTContract: PromiseOrValue<string>,
      _stakingLogger: PromiseOrValue<string>,
      _validatorShareFactory: PromiseOrValue<string>,
      _governance: PromiseOrValue<string>,
      _owner: PromiseOrValue<string>,
      _extensionCode: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    insertSigners(
      _signers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    isOwner(overrides?: CallOverrides): Promise<[boolean]>;

    isValidator(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[boolean]>;

    latestSignerUpdateEpoch(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    lock(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    locked(overrides?: CallOverrides): Promise<[boolean]>;

    logger(overrides?: CallOverrides): Promise<[string]>;

    maxRewardedCheckpoints(overrides?: CallOverrides): Promise<[BigNumber]>;

    migrateDelegation(
      fromValidatorId: PromiseOrValue<BigNumberish>,
      toValidatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    migrateValidatorsData(
      validatorIdFrom: PromiseOrValue<BigNumberish>,
      validatorIdTo: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    minDeposit(overrides?: CallOverrides): Promise<[BigNumber]>;

    minHeimdallFee(overrides?: CallOverrides): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    ownerOf(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    prevBlockInterval(overrides?: CallOverrides): Promise<[BigNumber]>;

    proposerBonus(overrides?: CallOverrides): Promise<[BigNumber]>;

    registry(overrides?: CallOverrides): Promise<[string]>;

    reinitialize(
      _NFTContract: PromiseOrValue<string>,
      _stakingLogger: PromiseOrValue<string>,
      _validatorShareFactory: PromiseOrValue<string>,
      _extensionCode: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    replacementCoolDown(overrides?: CallOverrides): Promise<[BigNumber]>;

    restake(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      stakeRewards: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    rewardDecreasePerCheckpoint(overrides?: CallOverrides): Promise<[BigNumber]>;

    rewardPerStake(overrides?: CallOverrides): Promise<[BigNumber]>;

    rootChain(overrides?: CallOverrides): Promise<[string]>;

    setCurrentEpoch(
      _currentEpoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setDelegationEnabled(
      enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setStakingToken(
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    signerToValidator(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    signerUpdateLimit(overrides?: CallOverrides): Promise<[BigNumber]>;

    signers(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    slash(
      _slashingInfoList: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    stakeFor(
      user: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      heimdallFee: PromiseOrValue<BigNumberish>,
      acceptDelegation: PromiseOrValue<boolean>,
      signerPubkey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    startAuction(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      _acceptDelegation: PromiseOrValue<boolean>,
      _signerPubkey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    stopAuctions(
      forNCheckpoints: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    token(overrides?: CallOverrides): Promise<[string]>;

    topUpForFee(
      user: PromiseOrValue<string>,
      heimdallFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    totalHeimdallFee(overrides?: CallOverrides): Promise<[BigNumber]>;

    totalRewards(overrides?: CallOverrides): Promise<[BigNumber]>;

    totalRewardsLiquidated(overrides?: CallOverrides): Promise<[BigNumber]>;

    totalStaked(overrides?: CallOverrides): Promise<[BigNumber]>;

    totalStakedFor(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    transferFunds(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      delegator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    unjail(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    unlock(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    unstake(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    unstakeClaim(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateCheckPointBlockInterval(
      _blocks: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateCheckpointReward(
      newReward: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateCheckpointRewardParams(
      _rewardDecreasePerCheckpoint: PromiseOrValue<BigNumberish>,
      _maxRewardedCheckpoints: PromiseOrValue<BigNumberish>,
      _checkpointRewardDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateCommissionRate(
      validatorId: PromiseOrValue<BigNumberish>,
      newCommissionRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateDynastyValue(
      newDynasty: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateMinAmounts(
      _minDeposit: PromiseOrValue<BigNumberish>,
      _minHeimdallFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateProposerBonus(
      newProposerBonus: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateSigner(
      validatorId: PromiseOrValue<BigNumberish>,
      signerPubkey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateSignerUpdateLimit(
      _limit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateValidatorContractAddress(
      validatorId: PromiseOrValue<BigNumberish>,
      newContractAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateValidatorDelegation(
      delegation: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateValidatorState(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateValidatorThreshold(
      newThreshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    userFeeExit(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    validatorAuction(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, string, boolean, string] & {
        amount: BigNumber;
        startEpoch: BigNumber;
        user: string;
        acceptDelegation: boolean;
        signerPubkey: string;
      }
    >;

    validatorReward(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    validatorShareFactory(overrides?: CallOverrides): Promise<[string]>;

    validatorStake(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    validatorState(
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { amount: BigNumber; stakerCount: BigNumber }>;

    validatorStateChanges(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { amount: BigNumber; stakerCount: BigNumber }>;

    validatorThreshold(overrides?: CallOverrides): Promise<[BigNumber]>;

    validators(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        string,
        string,
        number,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
      ] & {
        amount: BigNumber;
        reward: BigNumber;
        activationEpoch: BigNumber;
        deactivationEpoch: BigNumber;
        jailTime: BigNumber;
        signer: string;
        contractAddress: string;
        status: number;
        commissionRate: BigNumber;
        lastCommissionUpdate: BigNumber;
        delegatorsReward: BigNumber;
        delegatedAmount: BigNumber;
        initialRewardPerStake: BigNumber;
      }
    >;

    withdrawDelegatorsReward(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    withdrawRewards(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    withdrawalDelay(overrides?: CallOverrides): Promise<[BigNumber]>;
  };

  CHECKPOINT_REWARD(overrides?: CallOverrides): Promise<BigNumber>;

  NFTContract(overrides?: CallOverrides): Promise<string>;

  NFTCounter(overrides?: CallOverrides): Promise<BigNumber>;

  WITHDRAWAL_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

  accountStateRoot(overrides?: CallOverrides): Promise<string>;

  auctionPeriod(overrides?: CallOverrides): Promise<BigNumber>;

  changeRootChain(
    newRootChain: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  checkPointBlockInterval(overrides?: CallOverrides): Promise<BigNumber>;

  checkSignatures(
    blockInterval: PromiseOrValue<BigNumberish>,
    voteHash: PromiseOrValue<BytesLike>,
    stateRoot: PromiseOrValue<BytesLike>,
    proposer: PromiseOrValue<string>,
    sigs: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>][],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  checkpointRewardDelta(overrides?: CallOverrides): Promise<BigNumber>;

  claimFee(
    accumFeeAmount: PromiseOrValue<BigNumberish>,
    index: PromiseOrValue<BigNumberish>,
    proof: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  confirmAuctionBid(
    validatorId: PromiseOrValue<BigNumberish>,
    heimdallFee: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  currentEpoch(overrides?: CallOverrides): Promise<BigNumber>;

  currentValidatorSetSize(overrides?: CallOverrides): Promise<BigNumber>;

  currentValidatorSetTotalStake(overrides?: CallOverrides): Promise<BigNumber>;

  decreaseValidatorDelegatedAmount(
    validatorId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  delegatedAmount(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  delegationDeposit(
    validatorId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    delegator: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  delegationEnabled(overrides?: CallOverrides): Promise<boolean>;

  delegatorsReward(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  dethroneAndStake(
    auctionUser: PromiseOrValue<string>,
    heimdallFee: PromiseOrValue<BigNumberish>,
    validatorId: PromiseOrValue<BigNumberish>,
    auctionAmount: PromiseOrValue<BigNumberish>,
    acceptDelegation: PromiseOrValue<boolean>,
    signerPubkey: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  drain(
    destination: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  drainValidatorShares(
    validatorId: PromiseOrValue<BigNumberish>,
    tokenAddr: PromiseOrValue<string>,
    destination: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  dynasty(overrides?: CallOverrides): Promise<BigNumber>;

  epoch(overrides?: CallOverrides): Promise<BigNumber>;

  eventsHub(overrides?: CallOverrides): Promise<string>;

  extensionCode(overrides?: CallOverrides): Promise<string>;

  forceUnstake(
    validatorId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  getRegistry(overrides?: CallOverrides): Promise<string>;

  getValidatorContract(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  getValidatorId(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  governance(overrides?: CallOverrides): Promise<string>;

  initialize(
    _registry: PromiseOrValue<string>,
    _rootchain: PromiseOrValue<string>,
    _token: PromiseOrValue<string>,
    _NFTContract: PromiseOrValue<string>,
    _stakingLogger: PromiseOrValue<string>,
    _validatorShareFactory: PromiseOrValue<string>,
    _governance: PromiseOrValue<string>,
    _owner: PromiseOrValue<string>,
    _extensionCode: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  insertSigners(
    _signers: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  isOwner(overrides?: CallOverrides): Promise<boolean>;

  isValidator(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>;

  latestSignerUpdateEpoch(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  lock(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  locked(overrides?: CallOverrides): Promise<boolean>;

  logger(overrides?: CallOverrides): Promise<string>;

  maxRewardedCheckpoints(overrides?: CallOverrides): Promise<BigNumber>;

  migrateDelegation(
    fromValidatorId: PromiseOrValue<BigNumberish>,
    toValidatorId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  migrateValidatorsData(
    validatorIdFrom: PromiseOrValue<BigNumberish>,
    validatorIdTo: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  minDeposit(overrides?: CallOverrides): Promise<BigNumber>;

  minHeimdallFee(overrides?: CallOverrides): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  ownerOf(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  prevBlockInterval(overrides?: CallOverrides): Promise<BigNumber>;

  proposerBonus(overrides?: CallOverrides): Promise<BigNumber>;

  registry(overrides?: CallOverrides): Promise<string>;

  reinitialize(
    _NFTContract: PromiseOrValue<string>,
    _stakingLogger: PromiseOrValue<string>,
    _validatorShareFactory: PromiseOrValue<string>,
    _extensionCode: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  replacementCoolDown(overrides?: CallOverrides): Promise<BigNumber>;

  restake(
    validatorId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    stakeRewards: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  rewardDecreasePerCheckpoint(overrides?: CallOverrides): Promise<BigNumber>;

  rewardPerStake(overrides?: CallOverrides): Promise<BigNumber>;

  rootChain(overrides?: CallOverrides): Promise<string>;

  setCurrentEpoch(
    _currentEpoch: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setDelegationEnabled(
    enabled: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setStakingToken(
    _token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  signerToValidator(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  signerUpdateLimit(overrides?: CallOverrides): Promise<BigNumber>;

  signers(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  slash(
    _slashingInfoList: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  stakeFor(
    user: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    heimdallFee: PromiseOrValue<BigNumberish>,
    acceptDelegation: PromiseOrValue<boolean>,
    signerPubkey: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  startAuction(
    validatorId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    _acceptDelegation: PromiseOrValue<boolean>,
    _signerPubkey: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  stopAuctions(
    forNCheckpoints: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  token(overrides?: CallOverrides): Promise<string>;

  topUpForFee(
    user: PromiseOrValue<string>,
    heimdallFee: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  totalHeimdallFee(overrides?: CallOverrides): Promise<BigNumber>;

  totalRewards(overrides?: CallOverrides): Promise<BigNumber>;

  totalRewardsLiquidated(overrides?: CallOverrides): Promise<BigNumber>;

  totalStaked(overrides?: CallOverrides): Promise<BigNumber>;

  totalStakedFor(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  transferFunds(
    validatorId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    delegator: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  unjail(
    validatorId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  unlock(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  unstake(
    validatorId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  unstakeClaim(
    validatorId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateCheckPointBlockInterval(
    _blocks: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateCheckpointReward(
    newReward: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateCheckpointRewardParams(
    _rewardDecreasePerCheckpoint: PromiseOrValue<BigNumberish>,
    _maxRewardedCheckpoints: PromiseOrValue<BigNumberish>,
    _checkpointRewardDelta: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateCommissionRate(
    validatorId: PromiseOrValue<BigNumberish>,
    newCommissionRate: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateDynastyValue(
    newDynasty: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateMinAmounts(
    _minDeposit: PromiseOrValue<BigNumberish>,
    _minHeimdallFee: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateProposerBonus(
    newProposerBonus: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateSigner(
    validatorId: PromiseOrValue<BigNumberish>,
    signerPubkey: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateSignerUpdateLimit(
    _limit: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateValidatorContractAddress(
    validatorId: PromiseOrValue<BigNumberish>,
    newContractAddress: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateValidatorDelegation(
    delegation: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateValidatorState(
    validatorId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateValidatorThreshold(
    newThreshold: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  userFeeExit(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  validatorAuction(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, string, boolean, string] & {
      amount: BigNumber;
      startEpoch: BigNumber;
      user: string;
      acceptDelegation: boolean;
      signerPubkey: string;
    }
  >;

  validatorReward(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  validatorShareFactory(overrides?: CallOverrides): Promise<string>;

  validatorStake(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  validatorState(
    overrides?: CallOverrides,
  ): Promise<[BigNumber, BigNumber] & { amount: BigNumber; stakerCount: BigNumber }>;

  validatorStateChanges(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, BigNumber] & { amount: BigNumber; stakerCount: BigNumber }>;

  validatorThreshold(overrides?: CallOverrides): Promise<BigNumber>;

  validators(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      string,
      string,
      number,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
    ] & {
      amount: BigNumber;
      reward: BigNumber;
      activationEpoch: BigNumber;
      deactivationEpoch: BigNumber;
      jailTime: BigNumber;
      signer: string;
      contractAddress: string;
      status: number;
      commissionRate: BigNumber;
      lastCommissionUpdate: BigNumber;
      delegatorsReward: BigNumber;
      delegatedAmount: BigNumber;
      initialRewardPerStake: BigNumber;
    }
  >;

  withdrawDelegatorsReward(
    validatorId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  withdrawRewards(
    validatorId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  withdrawalDelay(overrides?: CallOverrides): Promise<BigNumber>;

  callStatic: {
    CHECKPOINT_REWARD(overrides?: CallOverrides): Promise<BigNumber>;

    NFTContract(overrides?: CallOverrides): Promise<string>;

    NFTCounter(overrides?: CallOverrides): Promise<BigNumber>;

    WITHDRAWAL_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

    accountStateRoot(overrides?: CallOverrides): Promise<string>;

    auctionPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    changeRootChain(newRootChain: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    checkPointBlockInterval(overrides?: CallOverrides): Promise<BigNumber>;

    checkSignatures(
      blockInterval: PromiseOrValue<BigNumberish>,
      voteHash: PromiseOrValue<BytesLike>,
      stateRoot: PromiseOrValue<BytesLike>,
      proposer: PromiseOrValue<string>,
      sigs: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>][],
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    checkpointRewardDelta(overrides?: CallOverrides): Promise<BigNumber>;

    claimFee(
      accumFeeAmount: PromiseOrValue<BigNumberish>,
      index: PromiseOrValue<BigNumberish>,
      proof: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    confirmAuctionBid(
      validatorId: PromiseOrValue<BigNumberish>,
      heimdallFee: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    currentEpoch(overrides?: CallOverrides): Promise<BigNumber>;

    currentValidatorSetSize(overrides?: CallOverrides): Promise<BigNumber>;

    currentValidatorSetTotalStake(overrides?: CallOverrides): Promise<BigNumber>;

    decreaseValidatorDelegatedAmount(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    delegatedAmount(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    delegationDeposit(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      delegator: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    delegationEnabled(overrides?: CallOverrides): Promise<boolean>;

    delegatorsReward(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    dethroneAndStake(
      auctionUser: PromiseOrValue<string>,
      heimdallFee: PromiseOrValue<BigNumberish>,
      validatorId: PromiseOrValue<BigNumberish>,
      auctionAmount: PromiseOrValue<BigNumberish>,
      acceptDelegation: PromiseOrValue<boolean>,
      signerPubkey: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    drain(
      destination: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    drainValidatorShares(
      validatorId: PromiseOrValue<BigNumberish>,
      tokenAddr: PromiseOrValue<string>,
      destination: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    dynasty(overrides?: CallOverrides): Promise<BigNumber>;

    epoch(overrides?: CallOverrides): Promise<BigNumber>;

    eventsHub(overrides?: CallOverrides): Promise<string>;

    extensionCode(overrides?: CallOverrides): Promise<string>;

    forceUnstake(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    getRegistry(overrides?: CallOverrides): Promise<string>;

    getValidatorContract(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    getValidatorId(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    governance(overrides?: CallOverrides): Promise<string>;

    initialize(
      _registry: PromiseOrValue<string>,
      _rootchain: PromiseOrValue<string>,
      _token: PromiseOrValue<string>,
      _NFTContract: PromiseOrValue<string>,
      _stakingLogger: PromiseOrValue<string>,
      _validatorShareFactory: PromiseOrValue<string>,
      _governance: PromiseOrValue<string>,
      _owner: PromiseOrValue<string>,
      _extensionCode: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    insertSigners(_signers: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;

    isOwner(overrides?: CallOverrides): Promise<boolean>;

    isValidator(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>;

    latestSignerUpdateEpoch(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    lock(overrides?: CallOverrides): Promise<void>;

    locked(overrides?: CallOverrides): Promise<boolean>;

    logger(overrides?: CallOverrides): Promise<string>;

    maxRewardedCheckpoints(overrides?: CallOverrides): Promise<BigNumber>;

    migrateDelegation(
      fromValidatorId: PromiseOrValue<BigNumberish>,
      toValidatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    migrateValidatorsData(
      validatorIdFrom: PromiseOrValue<BigNumberish>,
      validatorIdTo: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    minDeposit(overrides?: CallOverrides): Promise<BigNumber>;

    minHeimdallFee(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    ownerOf(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    prevBlockInterval(overrides?: CallOverrides): Promise<BigNumber>;

    proposerBonus(overrides?: CallOverrides): Promise<BigNumber>;

    registry(overrides?: CallOverrides): Promise<string>;

    reinitialize(
      _NFTContract: PromiseOrValue<string>,
      _stakingLogger: PromiseOrValue<string>,
      _validatorShareFactory: PromiseOrValue<string>,
      _extensionCode: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    replacementCoolDown(overrides?: CallOverrides): Promise<BigNumber>;

    restake(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      stakeRewards: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    rewardDecreasePerCheckpoint(overrides?: CallOverrides): Promise<BigNumber>;

    rewardPerStake(overrides?: CallOverrides): Promise<BigNumber>;

    rootChain(overrides?: CallOverrides): Promise<string>;

    setCurrentEpoch(_currentEpoch: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setDelegationEnabled(enabled: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;

    setStakingToken(_token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    signerToValidator(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    signerUpdateLimit(overrides?: CallOverrides): Promise<BigNumber>;

    signers(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    slash(_slashingInfoList: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    stakeFor(
      user: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      heimdallFee: PromiseOrValue<BigNumberish>,
      acceptDelegation: PromiseOrValue<boolean>,
      signerPubkey: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    startAuction(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      _acceptDelegation: PromiseOrValue<boolean>,
      _signerPubkey: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    stopAuctions(forNCheckpoints: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    token(overrides?: CallOverrides): Promise<string>;

    topUpForFee(
      user: PromiseOrValue<string>,
      heimdallFee: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    totalHeimdallFee(overrides?: CallOverrides): Promise<BigNumber>;

    totalRewards(overrides?: CallOverrides): Promise<BigNumber>;

    totalRewardsLiquidated(overrides?: CallOverrides): Promise<BigNumber>;

    totalStaked(overrides?: CallOverrides): Promise<BigNumber>;

    totalStakedFor(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    transferFunds(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      delegator: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    transferOwnership(newOwner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    unjail(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    unlock(overrides?: CallOverrides): Promise<void>;

    unstake(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    unstakeClaim(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    updateCheckPointBlockInterval(_blocks: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    updateCheckpointReward(newReward: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    updateCheckpointRewardParams(
      _rewardDecreasePerCheckpoint: PromiseOrValue<BigNumberish>,
      _maxRewardedCheckpoints: PromiseOrValue<BigNumberish>,
      _checkpointRewardDelta: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    updateCommissionRate(
      validatorId: PromiseOrValue<BigNumberish>,
      newCommissionRate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    updateDynastyValue(newDynasty: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    updateMinAmounts(
      _minDeposit: PromiseOrValue<BigNumberish>,
      _minHeimdallFee: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    updateProposerBonus(newProposerBonus: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    updateSigner(
      validatorId: PromiseOrValue<BigNumberish>,
      signerPubkey: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    updateSignerUpdateLimit(_limit: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    updateValidatorContractAddress(
      validatorId: PromiseOrValue<BigNumberish>,
      newContractAddress: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    updateValidatorDelegation(delegation: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;

    updateValidatorState(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    updateValidatorThreshold(newThreshold: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    userFeeExit(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    validatorAuction(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, string, boolean, string] & {
        amount: BigNumber;
        startEpoch: BigNumber;
        user: string;
        acceptDelegation: boolean;
        signerPubkey: string;
      }
    >;

    validatorReward(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    validatorShareFactory(overrides?: CallOverrides): Promise<string>;

    validatorStake(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    validatorState(
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { amount: BigNumber; stakerCount: BigNumber }>;

    validatorStateChanges(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { amount: BigNumber; stakerCount: BigNumber }>;

    validatorThreshold(overrides?: CallOverrides): Promise<BigNumber>;

    validators(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        string,
        string,
        number,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
      ] & {
        amount: BigNumber;
        reward: BigNumber;
        activationEpoch: BigNumber;
        deactivationEpoch: BigNumber;
        jailTime: BigNumber;
        signer: string;
        contractAddress: string;
        status: number;
        commissionRate: BigNumber;
        lastCommissionUpdate: BigNumber;
        delegatorsReward: BigNumber;
        delegatedAmount: BigNumber;
        initialRewardPerStake: BigNumber;
      }
    >;

    withdrawDelegatorsReward(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    withdrawRewards(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    withdrawalDelay(overrides?: CallOverrides): Promise<BigNumber>;
  };

  filters: {
    'OwnershipTransferred(address,address)'(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;

    'RootChainChanged(address,address)'(
      previousRootChain?: PromiseOrValue<string> | null,
      newRootChain?: PromiseOrValue<string> | null,
    ): RootChainChangedEventFilter;
    RootChainChanged(
      previousRootChain?: PromiseOrValue<string> | null,
      newRootChain?: PromiseOrValue<string> | null,
    ): RootChainChangedEventFilter;
  };

  estimateGas: {
    CHECKPOINT_REWARD(overrides?: CallOverrides): Promise<BigNumber>;

    NFTContract(overrides?: CallOverrides): Promise<BigNumber>;

    NFTCounter(overrides?: CallOverrides): Promise<BigNumber>;

    WITHDRAWAL_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

    accountStateRoot(overrides?: CallOverrides): Promise<BigNumber>;

    auctionPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    changeRootChain(
      newRootChain: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    checkPointBlockInterval(overrides?: CallOverrides): Promise<BigNumber>;

    checkSignatures(
      blockInterval: PromiseOrValue<BigNumberish>,
      voteHash: PromiseOrValue<BytesLike>,
      stateRoot: PromiseOrValue<BytesLike>,
      proposer: PromiseOrValue<string>,
      sigs: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>][],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    checkpointRewardDelta(overrides?: CallOverrides): Promise<BigNumber>;

    claimFee(
      accumFeeAmount: PromiseOrValue<BigNumberish>,
      index: PromiseOrValue<BigNumberish>,
      proof: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    confirmAuctionBid(
      validatorId: PromiseOrValue<BigNumberish>,
      heimdallFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    currentEpoch(overrides?: CallOverrides): Promise<BigNumber>;

    currentValidatorSetSize(overrides?: CallOverrides): Promise<BigNumber>;

    currentValidatorSetTotalStake(overrides?: CallOverrides): Promise<BigNumber>;

    decreaseValidatorDelegatedAmount(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    delegatedAmount(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    delegationDeposit(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      delegator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    delegationEnabled(overrides?: CallOverrides): Promise<BigNumber>;

    delegatorsReward(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    dethroneAndStake(
      auctionUser: PromiseOrValue<string>,
      heimdallFee: PromiseOrValue<BigNumberish>,
      validatorId: PromiseOrValue<BigNumberish>,
      auctionAmount: PromiseOrValue<BigNumberish>,
      acceptDelegation: PromiseOrValue<boolean>,
      signerPubkey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    drain(
      destination: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    drainValidatorShares(
      validatorId: PromiseOrValue<BigNumberish>,
      tokenAddr: PromiseOrValue<string>,
      destination: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    dynasty(overrides?: CallOverrides): Promise<BigNumber>;

    epoch(overrides?: CallOverrides): Promise<BigNumber>;

    eventsHub(overrides?: CallOverrides): Promise<BigNumber>;

    extensionCode(overrides?: CallOverrides): Promise<BigNumber>;

    forceUnstake(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    getRegistry(overrides?: CallOverrides): Promise<BigNumber>;

    getValidatorContract(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getValidatorId(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    governance(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      _registry: PromiseOrValue<string>,
      _rootchain: PromiseOrValue<string>,
      _token: PromiseOrValue<string>,
      _NFTContract: PromiseOrValue<string>,
      _stakingLogger: PromiseOrValue<string>,
      _validatorShareFactory: PromiseOrValue<string>,
      _governance: PromiseOrValue<string>,
      _owner: PromiseOrValue<string>,
      _extensionCode: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    insertSigners(
      _signers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    isOwner(overrides?: CallOverrides): Promise<BigNumber>;

    isValidator(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    latestSignerUpdateEpoch(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    lock(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    locked(overrides?: CallOverrides): Promise<BigNumber>;

    logger(overrides?: CallOverrides): Promise<BigNumber>;

    maxRewardedCheckpoints(overrides?: CallOverrides): Promise<BigNumber>;

    migrateDelegation(
      fromValidatorId: PromiseOrValue<BigNumberish>,
      toValidatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    migrateValidatorsData(
      validatorIdFrom: PromiseOrValue<BigNumberish>,
      validatorIdTo: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    minDeposit(overrides?: CallOverrides): Promise<BigNumber>;

    minHeimdallFee(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    ownerOf(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    prevBlockInterval(overrides?: CallOverrides): Promise<BigNumber>;

    proposerBonus(overrides?: CallOverrides): Promise<BigNumber>;

    registry(overrides?: CallOverrides): Promise<BigNumber>;

    reinitialize(
      _NFTContract: PromiseOrValue<string>,
      _stakingLogger: PromiseOrValue<string>,
      _validatorShareFactory: PromiseOrValue<string>,
      _extensionCode: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    replacementCoolDown(overrides?: CallOverrides): Promise<BigNumber>;

    restake(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      stakeRewards: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    rewardDecreasePerCheckpoint(overrides?: CallOverrides): Promise<BigNumber>;

    rewardPerStake(overrides?: CallOverrides): Promise<BigNumber>;

    rootChain(overrides?: CallOverrides): Promise<BigNumber>;

    setCurrentEpoch(
      _currentEpoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setDelegationEnabled(
      enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setStakingToken(
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    signerToValidator(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    signerUpdateLimit(overrides?: CallOverrides): Promise<BigNumber>;

    signers(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    slash(
      _slashingInfoList: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    stakeFor(
      user: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      heimdallFee: PromiseOrValue<BigNumberish>,
      acceptDelegation: PromiseOrValue<boolean>,
      signerPubkey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    startAuction(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      _acceptDelegation: PromiseOrValue<boolean>,
      _signerPubkey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    stopAuctions(
      forNCheckpoints: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    token(overrides?: CallOverrides): Promise<BigNumber>;

    topUpForFee(
      user: PromiseOrValue<string>,
      heimdallFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    totalHeimdallFee(overrides?: CallOverrides): Promise<BigNumber>;

    totalRewards(overrides?: CallOverrides): Promise<BigNumber>;

    totalRewardsLiquidated(overrides?: CallOverrides): Promise<BigNumber>;

    totalStaked(overrides?: CallOverrides): Promise<BigNumber>;

    totalStakedFor(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    transferFunds(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      delegator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    unjail(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    unlock(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    unstake(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    unstakeClaim(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateCheckPointBlockInterval(
      _blocks: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateCheckpointReward(
      newReward: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateCheckpointRewardParams(
      _rewardDecreasePerCheckpoint: PromiseOrValue<BigNumberish>,
      _maxRewardedCheckpoints: PromiseOrValue<BigNumberish>,
      _checkpointRewardDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateCommissionRate(
      validatorId: PromiseOrValue<BigNumberish>,
      newCommissionRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateDynastyValue(
      newDynasty: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateMinAmounts(
      _minDeposit: PromiseOrValue<BigNumberish>,
      _minHeimdallFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateProposerBonus(
      newProposerBonus: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateSigner(
      validatorId: PromiseOrValue<BigNumberish>,
      signerPubkey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateSignerUpdateLimit(
      _limit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateValidatorContractAddress(
      validatorId: PromiseOrValue<BigNumberish>,
      newContractAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateValidatorDelegation(
      delegation: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateValidatorState(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateValidatorThreshold(
      newThreshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    userFeeExit(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    validatorAuction(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    validatorReward(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    validatorShareFactory(overrides?: CallOverrides): Promise<BigNumber>;

    validatorStake(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    validatorState(overrides?: CallOverrides): Promise<BigNumber>;

    validatorStateChanges(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    validatorThreshold(overrides?: CallOverrides): Promise<BigNumber>;

    validators(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    withdrawDelegatorsReward(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    withdrawRewards(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    withdrawalDelay(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    CHECKPOINT_REWARD(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    NFTContract(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    NFTCounter(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    WITHDRAWAL_DELAY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    accountStateRoot(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    auctionPeriod(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    changeRootChain(
      newRootChain: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    checkPointBlockInterval(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    checkSignatures(
      blockInterval: PromiseOrValue<BigNumberish>,
      voteHash: PromiseOrValue<BytesLike>,
      stateRoot: PromiseOrValue<BytesLike>,
      proposer: PromiseOrValue<string>,
      sigs: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>][],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    checkpointRewardDelta(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    claimFee(
      accumFeeAmount: PromiseOrValue<BigNumberish>,
      index: PromiseOrValue<BigNumberish>,
      proof: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    confirmAuctionBid(
      validatorId: PromiseOrValue<BigNumberish>,
      heimdallFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    currentEpoch(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    currentValidatorSetSize(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    currentValidatorSetTotalStake(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    decreaseValidatorDelegatedAmount(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    delegatedAmount(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    delegationDeposit(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      delegator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    delegationEnabled(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    delegatorsReward(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    dethroneAndStake(
      auctionUser: PromiseOrValue<string>,
      heimdallFee: PromiseOrValue<BigNumberish>,
      validatorId: PromiseOrValue<BigNumberish>,
      auctionAmount: PromiseOrValue<BigNumberish>,
      acceptDelegation: PromiseOrValue<boolean>,
      signerPubkey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    drain(
      destination: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    drainValidatorShares(
      validatorId: PromiseOrValue<BigNumberish>,
      tokenAddr: PromiseOrValue<string>,
      destination: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    dynasty(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    epoch(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    eventsHub(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    extensionCode(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    forceUnstake(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    getRegistry(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getValidatorContract(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getValidatorId(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    governance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initialize(
      _registry: PromiseOrValue<string>,
      _rootchain: PromiseOrValue<string>,
      _token: PromiseOrValue<string>,
      _NFTContract: PromiseOrValue<string>,
      _stakingLogger: PromiseOrValue<string>,
      _validatorShareFactory: PromiseOrValue<string>,
      _governance: PromiseOrValue<string>,
      _owner: PromiseOrValue<string>,
      _extensionCode: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    insertSigners(
      _signers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    isOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isValidator(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    latestSignerUpdateEpoch(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    lock(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    locked(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    logger(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    maxRewardedCheckpoints(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    migrateDelegation(
      fromValidatorId: PromiseOrValue<BigNumberish>,
      toValidatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    migrateValidatorsData(
      validatorIdFrom: PromiseOrValue<BigNumberish>,
      validatorIdTo: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    minDeposit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minHeimdallFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ownerOf(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    prevBlockInterval(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proposerBonus(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    registry(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    reinitialize(
      _NFTContract: PromiseOrValue<string>,
      _stakingLogger: PromiseOrValue<string>,
      _validatorShareFactory: PromiseOrValue<string>,
      _extensionCode: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    replacementCoolDown(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    restake(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      stakeRewards: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    rewardDecreasePerCheckpoint(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardPerStake(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rootChain(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setCurrentEpoch(
      _currentEpoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setDelegationEnabled(
      enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setStakingToken(
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    signerToValidator(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    signerUpdateLimit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    signers(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    slash(
      _slashingInfoList: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    stakeFor(
      user: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      heimdallFee: PromiseOrValue<BigNumberish>,
      acceptDelegation: PromiseOrValue<boolean>,
      signerPubkey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    startAuction(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      _acceptDelegation: PromiseOrValue<boolean>,
      _signerPubkey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    stopAuctions(
      forNCheckpoints: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    token(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    topUpForFee(
      user: PromiseOrValue<string>,
      heimdallFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    totalHeimdallFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalRewards(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalRewardsLiquidated(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalStaked(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalStakedFor(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferFunds(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      delegator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    unjail(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    unlock(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    unstake(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    unstakeClaim(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateCheckPointBlockInterval(
      _blocks: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateCheckpointReward(
      newReward: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateCheckpointRewardParams(
      _rewardDecreasePerCheckpoint: PromiseOrValue<BigNumberish>,
      _maxRewardedCheckpoints: PromiseOrValue<BigNumberish>,
      _checkpointRewardDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateCommissionRate(
      validatorId: PromiseOrValue<BigNumberish>,
      newCommissionRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateDynastyValue(
      newDynasty: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateMinAmounts(
      _minDeposit: PromiseOrValue<BigNumberish>,
      _minHeimdallFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateProposerBonus(
      newProposerBonus: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateSigner(
      validatorId: PromiseOrValue<BigNumberish>,
      signerPubkey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateSignerUpdateLimit(
      _limit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateValidatorContractAddress(
      validatorId: PromiseOrValue<BigNumberish>,
      newContractAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateValidatorDelegation(
      delegation: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateValidatorState(
      validatorId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateValidatorThreshold(
      newThreshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    userFeeExit(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    validatorAuction(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    validatorReward(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    validatorShareFactory(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    validatorStake(validatorId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    validatorState(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    validatorStateChanges(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    validatorThreshold(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    validators(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdrawDelegatorsReward(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    withdrawRewards(
      validatorId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    withdrawalDelay(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}

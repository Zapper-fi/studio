/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export declare namespace AuraLocker {
  export type DelegateeCheckpointStruct = {
    votes: PromiseOrValue<BigNumberish>;
    epochStart: PromiseOrValue<BigNumberish>;
  };

  export type DelegateeCheckpointStructOutput = [BigNumber, number] & {
    votes: BigNumber;
    epochStart: number;
  };

  export type EarnedDataStruct = {
    token: PromiseOrValue<string>;
    amount: PromiseOrValue<BigNumberish>;
  };

  export type EarnedDataStructOutput = [string, BigNumber] & {
    token: string;
    amount: BigNumber;
  };

  export type LockedBalanceStruct = {
    amount: PromiseOrValue<BigNumberish>;
    unlockTime: PromiseOrValue<BigNumberish>;
  };

  export type LockedBalanceStructOutput = [BigNumber, number] & {
    amount: BigNumber;
    unlockTime: number;
  };
}

export interface AuraLockerInterface extends utils.Interface {
  functions: {
    'addReward(address,address)': FunctionFragment;
    'approveRewardDistributor(address,address,bool)': FunctionFragment;
    'balanceAtEpochOf(uint256,address)': FunctionFragment;
    'balanceOf(address)': FunctionFragment;
    'balances(address)': FunctionFragment;
    'blacklist(address)': FunctionFragment;
    'checkpointEpoch()': FunctionFragment;
    'checkpoints(address,uint32)': FunctionFragment;
    'claimableRewards(address)': FunctionFragment;
    'cvxCrv()': FunctionFragment;
    'cvxcrvStaking()': FunctionFragment;
    'decimals()': FunctionFragment;
    'delegate(address)': FunctionFragment;
    'delegateeUnlocks(address,uint256)': FunctionFragment;
    'delegates(address)': FunctionFragment;
    'denominator()': FunctionFragment;
    'emergencyWithdraw()': FunctionFragment;
    'epochCount()': FunctionFragment;
    'epochs(uint256)': FunctionFragment;
    'findEpochId(uint256)': FunctionFragment;
    'getPastTotalSupply(uint256)': FunctionFragment;
    'getPastVotes(address,uint256)': FunctionFragment;
    'getReward(address,bool)': FunctionFragment;
    'getReward(address)': FunctionFragment;
    'getReward(address,bool[])': FunctionFragment;
    'getVotes(address)': FunctionFragment;
    'isShutdown()': FunctionFragment;
    'kickExpiredLocks(address)': FunctionFragment;
    'kickRewardEpochDelay()': FunctionFragment;
    'kickRewardPerEpoch()': FunctionFragment;
    'lastTimeRewardApplicable(address)': FunctionFragment;
    'lock(address,uint256)': FunctionFragment;
    'lockDuration()': FunctionFragment;
    'lockedBalances(address)': FunctionFragment;
    'lockedSupply()': FunctionFragment;
    'modifyBlacklist(address,bool)': FunctionFragment;
    'name()': FunctionFragment;
    'newRewardRatio()': FunctionFragment;
    'numCheckpoints(address)': FunctionFragment;
    'owner()': FunctionFragment;
    'processExpiredLocks(bool)': FunctionFragment;
    'queueNewRewards(address,uint256)': FunctionFragment;
    'queuedRewards(address)': FunctionFragment;
    'recoverERC20(address,uint256)': FunctionFragment;
    'renounceOwnership()': FunctionFragment;
    'rewardData(address)': FunctionFragment;
    'rewardDistributors(address,address)': FunctionFragment;
    'rewardPerToken(address)': FunctionFragment;
    'rewardTokens(uint256)': FunctionFragment;
    'rewardsDuration()': FunctionFragment;
    'setApprovals()': FunctionFragment;
    'setKickIncentive(uint256,uint256)': FunctionFragment;
    'shutdown()': FunctionFragment;
    'stakingToken()': FunctionFragment;
    'symbol()': FunctionFragment;
    'totalSupply()': FunctionFragment;
    'totalSupplyAtEpoch(uint256)': FunctionFragment;
    'transferOwnership(address)': FunctionFragment;
    'userData(address,address)': FunctionFragment;
    'userLocks(address,uint256)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'addReward'
      | 'approveRewardDistributor'
      | 'balanceAtEpochOf'
      | 'balanceOf'
      | 'balances'
      | 'blacklist'
      | 'checkpointEpoch'
      | 'checkpoints'
      | 'claimableRewards'
      | 'cvxCrv'
      | 'cvxcrvStaking'
      | 'decimals'
      | 'delegate'
      | 'delegateeUnlocks'
      | 'delegates'
      | 'denominator'
      | 'emergencyWithdraw'
      | 'epochCount'
      | 'epochs'
      | 'findEpochId'
      | 'getPastTotalSupply'
      | 'getPastVotes'
      | 'getReward(address,bool)'
      | 'getReward(address)'
      | 'getReward(address,bool[])'
      | 'getVotes'
      | 'isShutdown'
      | 'kickExpiredLocks'
      | 'kickRewardEpochDelay'
      | 'kickRewardPerEpoch'
      | 'lastTimeRewardApplicable'
      | 'lock'
      | 'lockDuration'
      | 'lockedBalances'
      | 'lockedSupply'
      | 'modifyBlacklist'
      | 'name'
      | 'newRewardRatio'
      | 'numCheckpoints'
      | 'owner'
      | 'processExpiredLocks'
      | 'queueNewRewards'
      | 'queuedRewards'
      | 'recoverERC20'
      | 'renounceOwnership'
      | 'rewardData'
      | 'rewardDistributors'
      | 'rewardPerToken'
      | 'rewardTokens'
      | 'rewardsDuration'
      | 'setApprovals'
      | 'setKickIncentive'
      | 'shutdown'
      | 'stakingToken'
      | 'symbol'
      | 'totalSupply'
      | 'totalSupplyAtEpoch'
      | 'transferOwnership'
      | 'userData'
      | 'userLocks',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'addReward', values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'approveRewardDistributor',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'balanceAtEpochOf',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'balanceOf', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'balances', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'blacklist', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'checkpointEpoch', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'checkpoints',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'claimableRewards', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'cvxCrv', values?: undefined): string;
  encodeFunctionData(functionFragment: 'cvxcrvStaking', values?: undefined): string;
  encodeFunctionData(functionFragment: 'decimals', values?: undefined): string;
  encodeFunctionData(functionFragment: 'delegate', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'delegateeUnlocks',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'delegates', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'denominator', values?: undefined): string;
  encodeFunctionData(functionFragment: 'emergencyWithdraw', values?: undefined): string;
  encodeFunctionData(functionFragment: 'epochCount', values?: undefined): string;
  encodeFunctionData(functionFragment: 'epochs', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'findEpochId', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getPastTotalSupply', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'getPastVotes',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getReward(address,bool)',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'getReward(address)', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'getReward(address,bool[])',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>[]],
  ): string;
  encodeFunctionData(functionFragment: 'getVotes', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'isShutdown', values?: undefined): string;
  encodeFunctionData(functionFragment: 'kickExpiredLocks', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'kickRewardEpochDelay', values?: undefined): string;
  encodeFunctionData(functionFragment: 'kickRewardPerEpoch', values?: undefined): string;
  encodeFunctionData(functionFragment: 'lastTimeRewardApplicable', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'lock', values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'lockDuration', values?: undefined): string;
  encodeFunctionData(functionFragment: 'lockedBalances', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'lockedSupply', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'modifyBlacklist',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'name', values?: undefined): string;
  encodeFunctionData(functionFragment: 'newRewardRatio', values?: undefined): string;
  encodeFunctionData(functionFragment: 'numCheckpoints', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'processExpiredLocks', values: [PromiseOrValue<boolean>]): string;
  encodeFunctionData(
    functionFragment: 'queueNewRewards',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'queuedRewards', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'recoverERC20',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'rewardData', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'rewardDistributors',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'rewardPerToken', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'rewardTokens', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'rewardsDuration', values?: undefined): string;
  encodeFunctionData(functionFragment: 'setApprovals', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'setKickIncentive',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'shutdown', values?: undefined): string;
  encodeFunctionData(functionFragment: 'stakingToken', values?: undefined): string;
  encodeFunctionData(functionFragment: 'symbol', values?: undefined): string;
  encodeFunctionData(functionFragment: 'totalSupply', values?: undefined): string;
  encodeFunctionData(functionFragment: 'totalSupplyAtEpoch', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'transferOwnership', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'userData', values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'userLocks',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;

  decodeFunctionResult(functionFragment: 'addReward', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'approveRewardDistributor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balanceAtEpochOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balances', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'blacklist', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'checkpointEpoch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'checkpoints', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimableRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cvxCrv', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cvxcrvStaking', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'decimals', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'delegate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'delegateeUnlocks', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'delegates', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'denominator', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'emergencyWithdraw', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'epochCount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'epochs', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'findEpochId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPastTotalSupply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPastVotes', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReward(address,bool)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReward(address)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReward(address,bool[])', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getVotes', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isShutdown', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'kickExpiredLocks', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'kickRewardEpochDelay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'kickRewardPerEpoch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lastTimeRewardApplicable', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lock', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lockDuration', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lockedBalances', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lockedSupply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'modifyBlacklist', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'name', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'newRewardRatio', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'numCheckpoints', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'processExpiredLocks', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'queueNewRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'queuedRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'recoverERC20', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardDistributors', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardPerToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardsDuration', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setApprovals', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setKickIncentive', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'shutdown', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stakingToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'symbol', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalSupply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalSupplyAtEpoch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userLocks', data: BytesLike): Result;

  events: {
    'BlacklistModified(address,bool)': EventFragment;
    'DelegateChanged(address,address,address)': EventFragment;
    'DelegateCheckpointed(address)': EventFragment;
    'KickIncentiveSet(uint256,uint256)': EventFragment;
    'KickReward(address,address,uint256)': EventFragment;
    'OwnershipTransferred(address,address)': EventFragment;
    'Recovered(address,uint256)': EventFragment;
    'RewardAdded(address,uint256)': EventFragment;
    'RewardPaid(address,address,uint256)': EventFragment;
    'Shutdown()': EventFragment;
    'Staked(address,uint256,uint256)': EventFragment;
    'Withdrawn(address,uint256,bool)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'BlacklistModified'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'DelegateChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'DelegateCheckpointed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'KickIncentiveSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'KickReward'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Recovered'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardAdded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardPaid'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Shutdown'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Staked'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Withdrawn'): EventFragment;
}

export interface BlacklistModifiedEventObject {
  account: string;
  blacklisted: boolean;
}
export type BlacklistModifiedEvent = TypedEvent<[string, boolean], BlacklistModifiedEventObject>;

export type BlacklistModifiedEventFilter = TypedEventFilter<BlacklistModifiedEvent>;

export interface DelegateChangedEventObject {
  delegator: string;
  fromDelegate: string;
  toDelegate: string;
}
export type DelegateChangedEvent = TypedEvent<[string, string, string], DelegateChangedEventObject>;

export type DelegateChangedEventFilter = TypedEventFilter<DelegateChangedEvent>;

export interface DelegateCheckpointedEventObject {
  delegate: string;
}
export type DelegateCheckpointedEvent = TypedEvent<[string], DelegateCheckpointedEventObject>;

export type DelegateCheckpointedEventFilter = TypedEventFilter<DelegateCheckpointedEvent>;

export interface KickIncentiveSetEventObject {
  rate: BigNumber;
  delay: BigNumber;
}
export type KickIncentiveSetEvent = TypedEvent<[BigNumber, BigNumber], KickIncentiveSetEventObject>;

export type KickIncentiveSetEventFilter = TypedEventFilter<KickIncentiveSetEvent>;

export interface KickRewardEventObject {
  _user: string;
  _kicked: string;
  _reward: BigNumber;
}
export type KickRewardEvent = TypedEvent<[string, string, BigNumber], KickRewardEventObject>;

export type KickRewardEventFilter = TypedEventFilter<KickRewardEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<[string, string], OwnershipTransferredEventObject>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export interface RecoveredEventObject {
  _token: string;
  _amount: BigNumber;
}
export type RecoveredEvent = TypedEvent<[string, BigNumber], RecoveredEventObject>;

export type RecoveredEventFilter = TypedEventFilter<RecoveredEvent>;

export interface RewardAddedEventObject {
  _token: string;
  _reward: BigNumber;
}
export type RewardAddedEvent = TypedEvent<[string, BigNumber], RewardAddedEventObject>;

export type RewardAddedEventFilter = TypedEventFilter<RewardAddedEvent>;

export interface RewardPaidEventObject {
  _user: string;
  _rewardsToken: string;
  _reward: BigNumber;
}
export type RewardPaidEvent = TypedEvent<[string, string, BigNumber], RewardPaidEventObject>;

export type RewardPaidEventFilter = TypedEventFilter<RewardPaidEvent>;

export interface ShutdownEventObject {}
export type ShutdownEvent = TypedEvent<[], ShutdownEventObject>;

export type ShutdownEventFilter = TypedEventFilter<ShutdownEvent>;

export interface StakedEventObject {
  _user: string;
  _paidAmount: BigNumber;
  _lockedAmount: BigNumber;
}
export type StakedEvent = TypedEvent<[string, BigNumber, BigNumber], StakedEventObject>;

export type StakedEventFilter = TypedEventFilter<StakedEvent>;

export interface WithdrawnEventObject {
  _user: string;
  _amount: BigNumber;
  _relocked: boolean;
}
export type WithdrawnEvent = TypedEvent<[string, BigNumber, boolean], WithdrawnEventObject>;

export type WithdrawnEventFilter = TypedEventFilter<WithdrawnEvent>;

export interface AuraLocker extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: AuraLockerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    addReward(
      _rewardsToken: PromiseOrValue<string>,
      _distributor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    approveRewardDistributor(
      _rewardsToken: PromiseOrValue<string>,
      _distributor: PromiseOrValue<string>,
      _approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    balanceAtEpochOf(
      _epoch: PromiseOrValue<BigNumberish>,
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { amount: BigNumber }>;

    balanceOf(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber] & { amount: BigNumber }>;

    balances(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, number] & { locked: BigNumber; nextUnlockIndex: number }>;

    blacklist(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    checkpointEpoch(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    checkpoints(
      account: PromiseOrValue<string>,
      pos: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[AuraLocker.DelegateeCheckpointStructOutput]>;

    claimableRewards(
      _account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [AuraLocker.EarnedDataStructOutput[]] & {
        userRewards: AuraLocker.EarnedDataStructOutput[];
      }
    >;

    cvxCrv(overrides?: CallOverrides): Promise<[string]>;

    cvxcrvStaking(overrides?: CallOverrides): Promise<[string]>;

    decimals(overrides?: CallOverrides): Promise<[number]>;

    delegate(
      newDelegatee: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    delegateeUnlocks(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    delegates(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;

    denominator(overrides?: CallOverrides): Promise<[BigNumber]>;

    emergencyWithdraw(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    epochCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    epochs(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, number] & { supply: BigNumber; date: number }>;

    findEpochId(
      _time: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { epoch: BigNumber }>;

    getPastTotalSupply(timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    getPastVotes(
      account: PromiseOrValue<string>,
      timestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { votes: BigNumber }>;

    'getReward(address,bool)'(
      _account: PromiseOrValue<string>,
      _stake: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'getReward(address)'(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'getReward(address,bool[])'(
      _account: PromiseOrValue<string>,
      _skipIdx: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    getVotes(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    isShutdown(overrides?: CallOverrides): Promise<[boolean]>;

    kickExpiredLocks(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    kickRewardEpochDelay(overrides?: CallOverrides): Promise<[BigNumber]>;

    kickRewardPerEpoch(overrides?: CallOverrides): Promise<[BigNumber]>;

    lastTimeRewardApplicable(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    lock(
      _account: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    lockDuration(overrides?: CallOverrides): Promise<[BigNumber]>;

    lockedBalances(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, AuraLocker.LockedBalanceStructOutput[]] & {
        total: BigNumber;
        unlockable: BigNumber;
        locked: BigNumber;
        lockData: AuraLocker.LockedBalanceStructOutput[];
      }
    >;

    lockedSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    modifyBlacklist(
      _account: PromiseOrValue<string>,
      _blacklisted: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    name(overrides?: CallOverrides): Promise<[string]>;

    newRewardRatio(overrides?: CallOverrides): Promise<[BigNumber]>;

    numCheckpoints(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[number]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    processExpiredLocks(
      _relock: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    queueNewRewards(
      _rewardsToken: PromiseOrValue<string>,
      _rewards: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    queuedRewards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    recoverERC20(
      _tokenAddress: PromiseOrValue<string>,
      _tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    rewardData(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [number, number, BigNumber, BigNumber] & {
        periodFinish: number;
        lastUpdateTime: number;
        rewardRate: BigNumber;
        rewardPerTokenStored: BigNumber;
      }
    >;

    rewardDistributors(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    rewardPerToken(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    rewardTokens(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    rewardsDuration(overrides?: CallOverrides): Promise<[BigNumber]>;

    setApprovals(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    setKickIncentive(
      _rate: PromiseOrValue<BigNumberish>,
      _delay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    shutdown(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    stakingToken(overrides?: CallOverrides): Promise<[string]>;

    symbol(overrides?: CallOverrides): Promise<[string]>;

    totalSupply(overrides?: CallOverrides): Promise<[BigNumber] & { supply: BigNumber }>;

    totalSupplyAtEpoch(
      _epoch: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { supply: BigNumber }>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    userData(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        rewardPerTokenPaid: BigNumber;
        rewards: BigNumber;
      }
    >;

    userLocks(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, number] & { amount: BigNumber; unlockTime: number }>;
  };

  addReward(
    _rewardsToken: PromiseOrValue<string>,
    _distributor: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  approveRewardDistributor(
    _rewardsToken: PromiseOrValue<string>,
    _distributor: PromiseOrValue<string>,
    _approved: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  balanceAtEpochOf(
    _epoch: PromiseOrValue<BigNumberish>,
    _user: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  balanceOf(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  balances(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, number] & { locked: BigNumber; nextUnlockIndex: number }>;

  blacklist(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  checkpointEpoch(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  checkpoints(
    account: PromiseOrValue<string>,
    pos: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<AuraLocker.DelegateeCheckpointStructOutput>;

  claimableRewards(
    _account: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<AuraLocker.EarnedDataStructOutput[]>;

  cvxCrv(overrides?: CallOverrides): Promise<string>;

  cvxcrvStaking(overrides?: CallOverrides): Promise<string>;

  decimals(overrides?: CallOverrides): Promise<number>;

  delegate(
    newDelegatee: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  delegateeUnlocks(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  delegates(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  denominator(overrides?: CallOverrides): Promise<BigNumber>;

  emergencyWithdraw(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  epochCount(overrides?: CallOverrides): Promise<BigNumber>;

  epochs(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, number] & { supply: BigNumber; date: number }>;

  findEpochId(_time: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  getPastTotalSupply(timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  getPastVotes(
    account: PromiseOrValue<string>,
    timestamp: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  'getReward(address,bool)'(
    _account: PromiseOrValue<string>,
    _stake: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'getReward(address)'(
    _account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'getReward(address,bool[])'(
    _account: PromiseOrValue<string>,
    _skipIdx: PromiseOrValue<boolean>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  getVotes(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  isShutdown(overrides?: CallOverrides): Promise<boolean>;

  kickExpiredLocks(
    _account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  kickRewardEpochDelay(overrides?: CallOverrides): Promise<BigNumber>;

  kickRewardPerEpoch(overrides?: CallOverrides): Promise<BigNumber>;

  lastTimeRewardApplicable(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  lock(
    _account: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  lockDuration(overrides?: CallOverrides): Promise<BigNumber>;

  lockedBalances(
    _user: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber, AuraLocker.LockedBalanceStructOutput[]] & {
      total: BigNumber;
      unlockable: BigNumber;
      locked: BigNumber;
      lockData: AuraLocker.LockedBalanceStructOutput[];
    }
  >;

  lockedSupply(overrides?: CallOverrides): Promise<BigNumber>;

  modifyBlacklist(
    _account: PromiseOrValue<string>,
    _blacklisted: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  name(overrides?: CallOverrides): Promise<string>;

  newRewardRatio(overrides?: CallOverrides): Promise<BigNumber>;

  numCheckpoints(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<number>;

  owner(overrides?: CallOverrides): Promise<string>;

  processExpiredLocks(
    _relock: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  queueNewRewards(
    _rewardsToken: PromiseOrValue<string>,
    _rewards: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  queuedRewards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  recoverERC20(
    _tokenAddress: PromiseOrValue<string>,
    _tokenAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  rewardData(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [number, number, BigNumber, BigNumber] & {
      periodFinish: number;
      lastUpdateTime: number;
      rewardRate: BigNumber;
      rewardPerTokenStored: BigNumber;
    }
  >;

  rewardDistributors(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  rewardPerToken(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  rewardTokens(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  rewardsDuration(overrides?: CallOverrides): Promise<BigNumber>;

  setApprovals(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  setKickIncentive(
    _rate: PromiseOrValue<BigNumberish>,
    _delay: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  shutdown(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  stakingToken(overrides?: CallOverrides): Promise<string>;

  symbol(overrides?: CallOverrides): Promise<string>;

  totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  totalSupplyAtEpoch(_epoch: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  userData(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber] & {
      rewardPerTokenPaid: BigNumber;
      rewards: BigNumber;
    }
  >;

  userLocks(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, number] & { amount: BigNumber; unlockTime: number }>;

  callStatic: {
    addReward(
      _rewardsToken: PromiseOrValue<string>,
      _distributor: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    approveRewardDistributor(
      _rewardsToken: PromiseOrValue<string>,
      _distributor: PromiseOrValue<string>,
      _approved: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    balanceAtEpochOf(
      _epoch: PromiseOrValue<BigNumberish>,
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    balanceOf(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    balances(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, number] & { locked: BigNumber; nextUnlockIndex: number }>;

    blacklist(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    checkpointEpoch(overrides?: CallOverrides): Promise<void>;

    checkpoints(
      account: PromiseOrValue<string>,
      pos: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<AuraLocker.DelegateeCheckpointStructOutput>;

    claimableRewards(
      _account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<AuraLocker.EarnedDataStructOutput[]>;

    cvxCrv(overrides?: CallOverrides): Promise<string>;

    cvxcrvStaking(overrides?: CallOverrides): Promise<string>;

    decimals(overrides?: CallOverrides): Promise<number>;

    delegate(newDelegatee: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    delegateeUnlocks(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    delegates(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    denominator(overrides?: CallOverrides): Promise<BigNumber>;

    emergencyWithdraw(overrides?: CallOverrides): Promise<void>;

    epochCount(overrides?: CallOverrides): Promise<BigNumber>;

    epochs(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, number] & { supply: BigNumber; date: number }>;

    findEpochId(_time: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getPastTotalSupply(timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getPastVotes(
      account: PromiseOrValue<string>,
      timestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    'getReward(address,bool)'(
      _account: PromiseOrValue<string>,
      _stake: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    'getReward(address)'(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    'getReward(address,bool[])'(
      _account: PromiseOrValue<string>,
      _skipIdx: PromiseOrValue<boolean>[],
      overrides?: CallOverrides,
    ): Promise<void>;

    getVotes(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    isShutdown(overrides?: CallOverrides): Promise<boolean>;

    kickExpiredLocks(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    kickRewardEpochDelay(overrides?: CallOverrides): Promise<BigNumber>;

    kickRewardPerEpoch(overrides?: CallOverrides): Promise<BigNumber>;

    lastTimeRewardApplicable(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    lock(
      _account: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    lockDuration(overrides?: CallOverrides): Promise<BigNumber>;

    lockedBalances(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, AuraLocker.LockedBalanceStructOutput[]] & {
        total: BigNumber;
        unlockable: BigNumber;
        locked: BigNumber;
        lockData: AuraLocker.LockedBalanceStructOutput[];
      }
    >;

    lockedSupply(overrides?: CallOverrides): Promise<BigNumber>;

    modifyBlacklist(
      _account: PromiseOrValue<string>,
      _blacklisted: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    name(overrides?: CallOverrides): Promise<string>;

    newRewardRatio(overrides?: CallOverrides): Promise<BigNumber>;

    numCheckpoints(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<number>;

    owner(overrides?: CallOverrides): Promise<string>;

    processExpiredLocks(_relock: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;

    queueNewRewards(
      _rewardsToken: PromiseOrValue<string>,
      _rewards: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    queuedRewards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    recoverERC20(
      _tokenAddress: PromiseOrValue<string>,
      _tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    rewardData(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [number, number, BigNumber, BigNumber] & {
        periodFinish: number;
        lastUpdateTime: number;
        rewardRate: BigNumber;
        rewardPerTokenStored: BigNumber;
      }
    >;

    rewardDistributors(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    rewardPerToken(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    rewardTokens(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    rewardsDuration(overrides?: CallOverrides): Promise<BigNumber>;

    setApprovals(overrides?: CallOverrides): Promise<void>;

    setKickIncentive(
      _rate: PromiseOrValue<BigNumberish>,
      _delay: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    shutdown(overrides?: CallOverrides): Promise<void>;

    stakingToken(overrides?: CallOverrides): Promise<string>;

    symbol(overrides?: CallOverrides): Promise<string>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    totalSupplyAtEpoch(_epoch: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(newOwner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    userData(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        rewardPerTokenPaid: BigNumber;
        rewards: BigNumber;
      }
    >;

    userLocks(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, number] & { amount: BigNumber; unlockTime: number }>;
  };

  filters: {
    'BlacklistModified(address,bool)'(account?: null, blacklisted?: null): BlacklistModifiedEventFilter;
    BlacklistModified(account?: null, blacklisted?: null): BlacklistModifiedEventFilter;

    'DelegateChanged(address,address,address)'(
      delegator?: PromiseOrValue<string> | null,
      fromDelegate?: PromiseOrValue<string> | null,
      toDelegate?: PromiseOrValue<string> | null,
    ): DelegateChangedEventFilter;
    DelegateChanged(
      delegator?: PromiseOrValue<string> | null,
      fromDelegate?: PromiseOrValue<string> | null,
      toDelegate?: PromiseOrValue<string> | null,
    ): DelegateChangedEventFilter;

    'DelegateCheckpointed(address)'(delegate?: PromiseOrValue<string> | null): DelegateCheckpointedEventFilter;
    DelegateCheckpointed(delegate?: PromiseOrValue<string> | null): DelegateCheckpointedEventFilter;

    'KickIncentiveSet(uint256,uint256)'(rate?: null, delay?: null): KickIncentiveSetEventFilter;
    KickIncentiveSet(rate?: null, delay?: null): KickIncentiveSetEventFilter;

    'KickReward(address,address,uint256)'(
      _user?: PromiseOrValue<string> | null,
      _kicked?: PromiseOrValue<string> | null,
      _reward?: null,
    ): KickRewardEventFilter;
    KickReward(
      _user?: PromiseOrValue<string> | null,
      _kicked?: PromiseOrValue<string> | null,
      _reward?: null,
    ): KickRewardEventFilter;

    'OwnershipTransferred(address,address)'(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;

    'Recovered(address,uint256)'(_token?: null, _amount?: null): RecoveredEventFilter;
    Recovered(_token?: null, _amount?: null): RecoveredEventFilter;

    'RewardAdded(address,uint256)'(_token?: PromiseOrValue<string> | null, _reward?: null): RewardAddedEventFilter;
    RewardAdded(_token?: PromiseOrValue<string> | null, _reward?: null): RewardAddedEventFilter;

    'RewardPaid(address,address,uint256)'(
      _user?: PromiseOrValue<string> | null,
      _rewardsToken?: PromiseOrValue<string> | null,
      _reward?: null,
    ): RewardPaidEventFilter;
    RewardPaid(
      _user?: PromiseOrValue<string> | null,
      _rewardsToken?: PromiseOrValue<string> | null,
      _reward?: null,
    ): RewardPaidEventFilter;

    'Shutdown()'(): ShutdownEventFilter;
    Shutdown(): ShutdownEventFilter;

    'Staked(address,uint256,uint256)'(
      _user?: PromiseOrValue<string> | null,
      _paidAmount?: null,
      _lockedAmount?: null,
    ): StakedEventFilter;
    Staked(_user?: PromiseOrValue<string> | null, _paidAmount?: null, _lockedAmount?: null): StakedEventFilter;

    'Withdrawn(address,uint256,bool)'(
      _user?: PromiseOrValue<string> | null,
      _amount?: null,
      _relocked?: null,
    ): WithdrawnEventFilter;
    Withdrawn(_user?: PromiseOrValue<string> | null, _amount?: null, _relocked?: null): WithdrawnEventFilter;
  };

  estimateGas: {
    addReward(
      _rewardsToken: PromiseOrValue<string>,
      _distributor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    approveRewardDistributor(
      _rewardsToken: PromiseOrValue<string>,
      _distributor: PromiseOrValue<string>,
      _approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    balanceAtEpochOf(
      _epoch: PromiseOrValue<BigNumberish>,
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    balanceOf(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    balances(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    blacklist(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    checkpointEpoch(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    checkpoints(
      account: PromiseOrValue<string>,
      pos: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    claimableRewards(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    cvxCrv(overrides?: CallOverrides): Promise<BigNumber>;

    cvxcrvStaking(overrides?: CallOverrides): Promise<BigNumber>;

    decimals(overrides?: CallOverrides): Promise<BigNumber>;

    delegate(
      newDelegatee: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    delegateeUnlocks(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    delegates(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    denominator(overrides?: CallOverrides): Promise<BigNumber>;

    emergencyWithdraw(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    epochCount(overrides?: CallOverrides): Promise<BigNumber>;

    epochs(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    findEpochId(_time: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getPastTotalSupply(timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getPastVotes(
      account: PromiseOrValue<string>,
      timestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    'getReward(address,bool)'(
      _account: PromiseOrValue<string>,
      _stake: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'getReward(address)'(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'getReward(address,bool[])'(
      _account: PromiseOrValue<string>,
      _skipIdx: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    getVotes(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    isShutdown(overrides?: CallOverrides): Promise<BigNumber>;

    kickExpiredLocks(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    kickRewardEpochDelay(overrides?: CallOverrides): Promise<BigNumber>;

    kickRewardPerEpoch(overrides?: CallOverrides): Promise<BigNumber>;

    lastTimeRewardApplicable(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    lock(
      _account: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    lockDuration(overrides?: CallOverrides): Promise<BigNumber>;

    lockedBalances(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    lockedSupply(overrides?: CallOverrides): Promise<BigNumber>;

    modifyBlacklist(
      _account: PromiseOrValue<string>,
      _blacklisted: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    newRewardRatio(overrides?: CallOverrides): Promise<BigNumber>;

    numCheckpoints(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    processExpiredLocks(
      _relock: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    queueNewRewards(
      _rewardsToken: PromiseOrValue<string>,
      _rewards: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    queuedRewards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    recoverERC20(
      _tokenAddress: PromiseOrValue<string>,
      _tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    rewardData(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    rewardDistributors(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    rewardPerToken(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    rewardTokens(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    rewardsDuration(overrides?: CallOverrides): Promise<BigNumber>;

    setApprovals(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    setKickIncentive(
      _rate: PromiseOrValue<BigNumberish>,
      _delay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    shutdown(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    stakingToken(overrides?: CallOverrides): Promise<BigNumber>;

    symbol(overrides?: CallOverrides): Promise<BigNumber>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    totalSupplyAtEpoch(_epoch: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    userData(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    userLocks(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    addReward(
      _rewardsToken: PromiseOrValue<string>,
      _distributor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    approveRewardDistributor(
      _rewardsToken: PromiseOrValue<string>,
      _distributor: PromiseOrValue<string>,
      _approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    balanceAtEpochOf(
      _epoch: PromiseOrValue<BigNumberish>,
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    balanceOf(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    balances(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    blacklist(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    checkpointEpoch(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    checkpoints(
      account: PromiseOrValue<string>,
      pos: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    claimableRewards(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    cvxCrv(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    cvxcrvStaking(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    delegate(
      newDelegatee: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    delegateeUnlocks(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    delegates(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    denominator(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    emergencyWithdraw(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    epochCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    epochs(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    findEpochId(_time: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getPastTotalSupply(
      timestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getPastVotes(
      account: PromiseOrValue<string>,
      timestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    'getReward(address,bool)'(
      _account: PromiseOrValue<string>,
      _stake: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'getReward(address)'(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'getReward(address,bool[])'(
      _account: PromiseOrValue<string>,
      _skipIdx: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    getVotes(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isShutdown(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    kickExpiredLocks(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    kickRewardEpochDelay(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    kickRewardPerEpoch(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastTimeRewardApplicable(
      _rewardsToken: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    lock(
      _account: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    lockDuration(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lockedBalances(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lockedSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    modifyBlacklist(
      _account: PromiseOrValue<string>,
      _blacklisted: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    newRewardRatio(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    numCheckpoints(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    processExpiredLocks(
      _relock: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    queueNewRewards(
      _rewardsToken: PromiseOrValue<string>,
      _rewards: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    queuedRewards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    recoverERC20(
      _tokenAddress: PromiseOrValue<string>,
      _tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    rewardData(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardDistributors(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    rewardPerToken(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardTokens(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardsDuration(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setApprovals(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    setKickIncentive(
      _rate: PromiseOrValue<BigNumberish>,
      _delay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    shutdown(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    stakingToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalSupplyAtEpoch(_epoch: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    userData(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    userLocks(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;
  };
}

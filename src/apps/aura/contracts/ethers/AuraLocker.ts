/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from './common';

export declare namespace AuraLocker {
  export type DelegateeCheckpointStruct = {
    votes: BigNumberish;
    epochStart: BigNumberish;
  };

  export type DelegateeCheckpointStructOutput = [BigNumber, number] & {
    votes: BigNumber;
    epochStart: number;
  };

  export type EarnedDataStruct = { token: string; amount: BigNumberish };

  export type EarnedDataStructOutput = [string, BigNumber] & {
    token: string;
    amount: BigNumber;
  };

  export type LockedBalanceStruct = {
    amount: BigNumberish;
    unlockTime: BigNumberish;
  };

  export type LockedBalanceStructOutput = [BigNumber, number] & {
    amount: BigNumber;
    unlockTime: number;
  };
}

export interface AuraLockerInterface extends utils.Interface {
  functions: {
    'addReward(address,address)': FunctionFragment;
    'approveRewardDistributor(address,address,bool)': FunctionFragment;
    'balanceAtEpochOf(uint256,address)': FunctionFragment;
    'balanceOf(address)': FunctionFragment;
    'balances(address)': FunctionFragment;
    'blacklist(address)': FunctionFragment;
    'checkpointEpoch()': FunctionFragment;
    'checkpoints(address,uint32)': FunctionFragment;
    'claimableRewards(address)': FunctionFragment;
    'cvxCrv()': FunctionFragment;
    'cvxcrvStaking()': FunctionFragment;
    'decimals()': FunctionFragment;
    'delegate(address)': FunctionFragment;
    'delegateeUnlocks(address,uint256)': FunctionFragment;
    'delegates(address)': FunctionFragment;
    'denominator()': FunctionFragment;
    'emergencyWithdraw()': FunctionFragment;
    'epochCount()': FunctionFragment;
    'epochs(uint256)': FunctionFragment;
    'findEpochId(uint256)': FunctionFragment;
    'getPastTotalSupply(uint256)': FunctionFragment;
    'getPastVotes(address,uint256)': FunctionFragment;
    'getReward(address,bool)': FunctionFragment;
    'getReward(address)': FunctionFragment;
    'getReward(address,bool[])': FunctionFragment;
    'getVotes(address)': FunctionFragment;
    'isShutdown()': FunctionFragment;
    'kickExpiredLocks(address)': FunctionFragment;
    'kickRewardEpochDelay()': FunctionFragment;
    'kickRewardPerEpoch()': FunctionFragment;
    'lastTimeRewardApplicable(address)': FunctionFragment;
    'lock(address,uint256)': FunctionFragment;
    'lockDuration()': FunctionFragment;
    'lockedBalances(address)': FunctionFragment;
    'lockedSupply()': FunctionFragment;
    'modifyBlacklist(address,bool)': FunctionFragment;
    'name()': FunctionFragment;
    'newRewardRatio()': FunctionFragment;
    'numCheckpoints(address)': FunctionFragment;
    'owner()': FunctionFragment;
    'processExpiredLocks(bool)': FunctionFragment;
    'queueNewRewards(address,uint256)': FunctionFragment;
    'queuedRewards(address)': FunctionFragment;
    'recoverERC20(address,uint256)': FunctionFragment;
    'renounceOwnership()': FunctionFragment;
    'rewardData(address)': FunctionFragment;
    'rewardDistributors(address,address)': FunctionFragment;
    'rewardPerToken(address)': FunctionFragment;
    'rewardTokens(uint256)': FunctionFragment;
    'rewardsDuration()': FunctionFragment;
    'setApprovals()': FunctionFragment;
    'setKickIncentive(uint256,uint256)': FunctionFragment;
    'shutdown()': FunctionFragment;
    'stakingToken()': FunctionFragment;
    'symbol()': FunctionFragment;
    'totalSupply()': FunctionFragment;
    'totalSupplyAtEpoch(uint256)': FunctionFragment;
    'transferOwnership(address)': FunctionFragment;
    'userData(address,address)': FunctionFragment;
    'userLocks(address,uint256)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'addReward'
      | 'approveRewardDistributor'
      | 'balanceAtEpochOf'
      | 'balanceOf'
      | 'balances'
      | 'blacklist'
      | 'checkpointEpoch'
      | 'checkpoints'
      | 'claimableRewards'
      | 'cvxCrv'
      | 'cvxcrvStaking'
      | 'decimals'
      | 'delegate'
      | 'delegateeUnlocks'
      | 'delegates'
      | 'denominator'
      | 'emergencyWithdraw'
      | 'epochCount'
      | 'epochs'
      | 'findEpochId'
      | 'getPastTotalSupply'
      | 'getPastVotes'
      | 'getReward(address,bool)'
      | 'getReward(address)'
      | 'getReward(address,bool[])'
      | 'getVotes'
      | 'isShutdown'
      | 'kickExpiredLocks'
      | 'kickRewardEpochDelay'
      | 'kickRewardPerEpoch'
      | 'lastTimeRewardApplicable'
      | 'lock'
      | 'lockDuration'
      | 'lockedBalances'
      | 'lockedSupply'
      | 'modifyBlacklist'
      | 'name'
      | 'newRewardRatio'
      | 'numCheckpoints'
      | 'owner'
      | 'processExpiredLocks'
      | 'queueNewRewards'
      | 'queuedRewards'
      | 'recoverERC20'
      | 'renounceOwnership'
      | 'rewardData'
      | 'rewardDistributors'
      | 'rewardPerToken'
      | 'rewardTokens'
      | 'rewardsDuration'
      | 'setApprovals'
      | 'setKickIncentive'
      | 'shutdown'
      | 'stakingToken'
      | 'symbol'
      | 'totalSupply'
      | 'totalSupplyAtEpoch'
      | 'transferOwnership'
      | 'userData'
      | 'userLocks',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'addReward', values: [string, string]): string;
  encodeFunctionData(functionFragment: 'approveRewardDistributor', values: [string, string, boolean]): string;
  encodeFunctionData(functionFragment: 'balanceAtEpochOf', values: [BigNumberish, string]): string;
  encodeFunctionData(functionFragment: 'balanceOf', values: [string]): string;
  encodeFunctionData(functionFragment: 'balances', values: [string]): string;
  encodeFunctionData(functionFragment: 'blacklist', values: [string]): string;
  encodeFunctionData(functionFragment: 'checkpointEpoch', values?: undefined): string;
  encodeFunctionData(functionFragment: 'checkpoints', values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'claimableRewards', values: [string]): string;
  encodeFunctionData(functionFragment: 'cvxCrv', values?: undefined): string;
  encodeFunctionData(functionFragment: 'cvxcrvStaking', values?: undefined): string;
  encodeFunctionData(functionFragment: 'decimals', values?: undefined): string;
  encodeFunctionData(functionFragment: 'delegate', values: [string]): string;
  encodeFunctionData(functionFragment: 'delegateeUnlocks', values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'delegates', values: [string]): string;
  encodeFunctionData(functionFragment: 'denominator', values?: undefined): string;
  encodeFunctionData(functionFragment: 'emergencyWithdraw', values?: undefined): string;
  encodeFunctionData(functionFragment: 'epochCount', values?: undefined): string;
  encodeFunctionData(functionFragment: 'epochs', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'findEpochId', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'getPastTotalSupply', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'getPastVotes', values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'getReward(address,bool)', values: [string, boolean]): string;
  encodeFunctionData(functionFragment: 'getReward(address)', values: [string]): string;
  encodeFunctionData(functionFragment: 'getReward(address,bool[])', values: [string, boolean[]]): string;
  encodeFunctionData(functionFragment: 'getVotes', values: [string]): string;
  encodeFunctionData(functionFragment: 'isShutdown', values?: undefined): string;
  encodeFunctionData(functionFragment: 'kickExpiredLocks', values: [string]): string;
  encodeFunctionData(functionFragment: 'kickRewardEpochDelay', values?: undefined): string;
  encodeFunctionData(functionFragment: 'kickRewardPerEpoch', values?: undefined): string;
  encodeFunctionData(functionFragment: 'lastTimeRewardApplicable', values: [string]): string;
  encodeFunctionData(functionFragment: 'lock', values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'lockDuration', values?: undefined): string;
  encodeFunctionData(functionFragment: 'lockedBalances', values: [string]): string;
  encodeFunctionData(functionFragment: 'lockedSupply', values?: undefined): string;
  encodeFunctionData(functionFragment: 'modifyBlacklist', values: [string, boolean]): string;
  encodeFunctionData(functionFragment: 'name', values?: undefined): string;
  encodeFunctionData(functionFragment: 'newRewardRatio', values?: undefined): string;
  encodeFunctionData(functionFragment: 'numCheckpoints', values: [string]): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'processExpiredLocks', values: [boolean]): string;
  encodeFunctionData(functionFragment: 'queueNewRewards', values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'queuedRewards', values: [string]): string;
  encodeFunctionData(functionFragment: 'recoverERC20', values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'rewardData', values: [string]): string;
  encodeFunctionData(functionFragment: 'rewardDistributors', values: [string, string]): string;
  encodeFunctionData(functionFragment: 'rewardPerToken', values: [string]): string;
  encodeFunctionData(functionFragment: 'rewardTokens', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'rewardsDuration', values?: undefined): string;
  encodeFunctionData(functionFragment: 'setApprovals', values?: undefined): string;
  encodeFunctionData(functionFragment: 'setKickIncentive', values: [BigNumberish, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'shutdown', values?: undefined): string;
  encodeFunctionData(functionFragment: 'stakingToken', values?: undefined): string;
  encodeFunctionData(functionFragment: 'symbol', values?: undefined): string;
  encodeFunctionData(functionFragment: 'totalSupply', values?: undefined): string;
  encodeFunctionData(functionFragment: 'totalSupplyAtEpoch', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'transferOwnership', values: [string]): string;
  encodeFunctionData(functionFragment: 'userData', values: [string, string]): string;
  encodeFunctionData(functionFragment: 'userLocks', values: [string, BigNumberish]): string;

  decodeFunctionResult(functionFragment: 'addReward', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'approveRewardDistributor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balanceAtEpochOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balances', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'blacklist', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'checkpointEpoch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'checkpoints', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimableRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cvxCrv', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cvxcrvStaking', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'decimals', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'delegate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'delegateeUnlocks', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'delegates', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'denominator', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'emergencyWithdraw', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'epochCount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'epochs', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'findEpochId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPastTotalSupply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPastVotes', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReward(address,bool)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReward(address)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReward(address,bool[])', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getVotes', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isShutdown', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'kickExpiredLocks', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'kickRewardEpochDelay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'kickRewardPerEpoch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lastTimeRewardApplicable', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lock', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lockDuration', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lockedBalances', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lockedSupply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'modifyBlacklist', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'name', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'newRewardRatio', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'numCheckpoints', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'processExpiredLocks', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'queueNewRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'queuedRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'recoverERC20', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardDistributors', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardPerToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardsDuration', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setApprovals', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setKickIncentive', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'shutdown', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stakingToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'symbol', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalSupply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalSupplyAtEpoch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userLocks', data: BytesLike): Result;

  events: {
    'BlacklistModified(address,bool)': EventFragment;
    'DelegateChanged(address,address,address)': EventFragment;
    'DelegateCheckpointed(address)': EventFragment;
    'KickIncentiveSet(uint256,uint256)': EventFragment;
    'KickReward(address,address,uint256)': EventFragment;
    'OwnershipTransferred(address,address)': EventFragment;
    'Recovered(address,uint256)': EventFragment;
    'RewardAdded(address,uint256)': EventFragment;
    'RewardPaid(address,address,uint256)': EventFragment;
    'Shutdown()': EventFragment;
    'Staked(address,uint256,uint256)': EventFragment;
    'Withdrawn(address,uint256,bool)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'BlacklistModified'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'DelegateChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'DelegateCheckpointed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'KickIncentiveSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'KickReward'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Recovered'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardAdded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardPaid'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Shutdown'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Staked'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Withdrawn'): EventFragment;
}

export interface BlacklistModifiedEventObject {
  account: string;
  blacklisted: boolean;
}
export type BlacklistModifiedEvent = TypedEvent<[string, boolean], BlacklistModifiedEventObject>;

export type BlacklistModifiedEventFilter = TypedEventFilter<BlacklistModifiedEvent>;

export interface DelegateChangedEventObject {
  delegator: string;
  fromDelegate: string;
  toDelegate: string;
}
export type DelegateChangedEvent = TypedEvent<[string, string, string], DelegateChangedEventObject>;

export type DelegateChangedEventFilter = TypedEventFilter<DelegateChangedEvent>;

export interface DelegateCheckpointedEventObject {
  delegate: string;
}
export type DelegateCheckpointedEvent = TypedEvent<[string], DelegateCheckpointedEventObject>;

export type DelegateCheckpointedEventFilter = TypedEventFilter<DelegateCheckpointedEvent>;

export interface KickIncentiveSetEventObject {
  rate: BigNumber;
  delay: BigNumber;
}
export type KickIncentiveSetEvent = TypedEvent<[BigNumber, BigNumber], KickIncentiveSetEventObject>;

export type KickIncentiveSetEventFilter = TypedEventFilter<KickIncentiveSetEvent>;

export interface KickRewardEventObject {
  _user: string;
  _kicked: string;
  _reward: BigNumber;
}
export type KickRewardEvent = TypedEvent<[string, string, BigNumber], KickRewardEventObject>;

export type KickRewardEventFilter = TypedEventFilter<KickRewardEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<[string, string], OwnershipTransferredEventObject>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export interface RecoveredEventObject {
  _token: string;
  _amount: BigNumber;
}
export type RecoveredEvent = TypedEvent<[string, BigNumber], RecoveredEventObject>;

export type RecoveredEventFilter = TypedEventFilter<RecoveredEvent>;

export interface RewardAddedEventObject {
  _token: string;
  _reward: BigNumber;
}
export type RewardAddedEvent = TypedEvent<[string, BigNumber], RewardAddedEventObject>;

export type RewardAddedEventFilter = TypedEventFilter<RewardAddedEvent>;

export interface RewardPaidEventObject {
  _user: string;
  _rewardsToken: string;
  _reward: BigNumber;
}
export type RewardPaidEvent = TypedEvent<[string, string, BigNumber], RewardPaidEventObject>;

export type RewardPaidEventFilter = TypedEventFilter<RewardPaidEvent>;

export interface ShutdownEventObject {}
export type ShutdownEvent = TypedEvent<[], ShutdownEventObject>;

export type ShutdownEventFilter = TypedEventFilter<ShutdownEvent>;

export interface StakedEventObject {
  _user: string;
  _paidAmount: BigNumber;
  _lockedAmount: BigNumber;
}
export type StakedEvent = TypedEvent<[string, BigNumber, BigNumber], StakedEventObject>;

export type StakedEventFilter = TypedEventFilter<StakedEvent>;

export interface WithdrawnEventObject {
  _user: string;
  _amount: BigNumber;
  _relocked: boolean;
}
export type WithdrawnEvent = TypedEvent<[string, BigNumber, boolean], WithdrawnEventObject>;

export type WithdrawnEventFilter = TypedEventFilter<WithdrawnEvent>;

export interface AuraLocker extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: AuraLockerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    addReward(
      _rewardsToken: string,
      _distributor: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    approveRewardDistributor(
      _rewardsToken: string,
      _distributor: string,
      _approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    balanceAtEpochOf(
      _epoch: BigNumberish,
      _user: string,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { amount: BigNumber }>;

    balanceOf(_user: string, overrides?: CallOverrides): Promise<[BigNumber] & { amount: BigNumber }>;

    balances(
      arg0: string,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, number] & { locked: BigNumber; nextUnlockIndex: number }>;

    blacklist(arg0: string, overrides?: CallOverrides): Promise<[boolean]>;

    checkpointEpoch(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    checkpoints(
      account: string,
      pos: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<[AuraLocker.DelegateeCheckpointStructOutput]>;

    claimableRewards(
      _account: string,
      overrides?: CallOverrides,
    ): Promise<
      [AuraLocker.EarnedDataStructOutput[]] & {
        userRewards: AuraLocker.EarnedDataStructOutput[];
      }
    >;

    cvxCrv(overrides?: CallOverrides): Promise<[string]>;

    cvxcrvStaking(overrides?: CallOverrides): Promise<[string]>;

    decimals(overrides?: CallOverrides): Promise<[number]>;

    delegate(
      newDelegatee: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    delegateeUnlocks(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;

    delegates(account: string, overrides?: CallOverrides): Promise<[string]>;

    denominator(overrides?: CallOverrides): Promise<[BigNumber]>;

    emergencyWithdraw(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    epochCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    epochs(
      arg0: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, number] & { supply: BigNumber; date: number }>;

    findEpochId(_time: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber] & { epoch: BigNumber }>;

    getPastTotalSupply(timestamp: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;

    getPastVotes(
      account: string,
      timestamp: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { votes: BigNumber }>;

    'getReward(address,bool)'(
      _account: string,
      _stake: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    'getReward(address)'(
      _account: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    'getReward(address,bool[])'(
      _account: string,
      _skipIdx: boolean[],
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    getVotes(account: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    isShutdown(overrides?: CallOverrides): Promise<[boolean]>;

    kickExpiredLocks(
      _account: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    kickRewardEpochDelay(overrides?: CallOverrides): Promise<[BigNumber]>;

    kickRewardPerEpoch(overrides?: CallOverrides): Promise<[BigNumber]>;

    lastTimeRewardApplicable(_rewardsToken: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    lock(
      _account: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    lockDuration(overrides?: CallOverrides): Promise<[BigNumber]>;

    lockedBalances(
      _user: string,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, AuraLocker.LockedBalanceStructOutput[]] & {
        total: BigNumber;
        unlockable: BigNumber;
        locked: BigNumber;
        lockData: AuraLocker.LockedBalanceStructOutput[];
      }
    >;

    lockedSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    modifyBlacklist(
      _account: string,
      _blacklisted: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    name(overrides?: CallOverrides): Promise<[string]>;

    newRewardRatio(overrides?: CallOverrides): Promise<[BigNumber]>;

    numCheckpoints(account: string, overrides?: CallOverrides): Promise<[number]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    processExpiredLocks(
      _relock: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    queueNewRewards(
      _rewardsToken: string,
      _rewards: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    queuedRewards(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    recoverERC20(
      _tokenAddress: string,
      _tokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    rewardData(
      arg0: string,
      overrides?: CallOverrides,
    ): Promise<
      [number, number, BigNumber, BigNumber] & {
        periodFinish: number;
        lastUpdateTime: number;
        rewardRate: BigNumber;
        rewardPerTokenStored: BigNumber;
      }
    >;

    rewardDistributors(arg0: string, arg1: string, overrides?: CallOverrides): Promise<[boolean]>;

    rewardPerToken(_rewardsToken: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    rewardTokens(arg0: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    rewardsDuration(overrides?: CallOverrides): Promise<[BigNumber]>;

    setApprovals(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    setKickIncentive(
      _rate: BigNumberish,
      _delay: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    shutdown(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    stakingToken(overrides?: CallOverrides): Promise<[string]>;

    symbol(overrides?: CallOverrides): Promise<[string]>;

    totalSupply(overrides?: CallOverrides): Promise<[BigNumber] & { supply: BigNumber }>;

    totalSupplyAtEpoch(_epoch: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber] & { supply: BigNumber }>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    userData(
      arg0: string,
      arg1: string,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        rewardPerTokenPaid: BigNumber;
        rewards: BigNumber;
      }
    >;

    userLocks(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, number] & { amount: BigNumber; unlockTime: number }>;
  };

  addReward(
    _rewardsToken: string,
    _distributor: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  approveRewardDistributor(
    _rewardsToken: string,
    _distributor: string,
    _approved: boolean,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  balanceAtEpochOf(_epoch: BigNumberish, _user: string, overrides?: CallOverrides): Promise<BigNumber>;

  balanceOf(_user: string, overrides?: CallOverrides): Promise<BigNumber>;

  balances(
    arg0: string,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, number] & { locked: BigNumber; nextUnlockIndex: number }>;

  blacklist(arg0: string, overrides?: CallOverrides): Promise<boolean>;

  checkpointEpoch(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  checkpoints(
    account: string,
    pos: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<AuraLocker.DelegateeCheckpointStructOutput>;

  claimableRewards(_account: string, overrides?: CallOverrides): Promise<AuraLocker.EarnedDataStructOutput[]>;

  cvxCrv(overrides?: CallOverrides): Promise<string>;

  cvxcrvStaking(overrides?: CallOverrides): Promise<string>;

  decimals(overrides?: CallOverrides): Promise<number>;

  delegate(
    newDelegatee: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  delegateeUnlocks(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  delegates(account: string, overrides?: CallOverrides): Promise<string>;

  denominator(overrides?: CallOverrides): Promise<BigNumber>;

  emergencyWithdraw(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  epochCount(overrides?: CallOverrides): Promise<BigNumber>;

  epochs(
    arg0: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, number] & { supply: BigNumber; date: number }>;

  findEpochId(_time: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  getPastTotalSupply(timestamp: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  getPastVotes(account: string, timestamp: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  'getReward(address,bool)'(
    _account: string,
    _stake: boolean,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  'getReward(address)'(
    _account: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  'getReward(address,bool[])'(
    _account: string,
    _skipIdx: boolean[],
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  getVotes(account: string, overrides?: CallOverrides): Promise<BigNumber>;

  isShutdown(overrides?: CallOverrides): Promise<boolean>;

  kickExpiredLocks(
    _account: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  kickRewardEpochDelay(overrides?: CallOverrides): Promise<BigNumber>;

  kickRewardPerEpoch(overrides?: CallOverrides): Promise<BigNumber>;

  lastTimeRewardApplicable(_rewardsToken: string, overrides?: CallOverrides): Promise<BigNumber>;

  lock(
    _account: string,
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  lockDuration(overrides?: CallOverrides): Promise<BigNumber>;

  lockedBalances(
    _user: string,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber, AuraLocker.LockedBalanceStructOutput[]] & {
      total: BigNumber;
      unlockable: BigNumber;
      locked: BigNumber;
      lockData: AuraLocker.LockedBalanceStructOutput[];
    }
  >;

  lockedSupply(overrides?: CallOverrides): Promise<BigNumber>;

  modifyBlacklist(
    _account: string,
    _blacklisted: boolean,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  name(overrides?: CallOverrides): Promise<string>;

  newRewardRatio(overrides?: CallOverrides): Promise<BigNumber>;

  numCheckpoints(account: string, overrides?: CallOverrides): Promise<number>;

  owner(overrides?: CallOverrides): Promise<string>;

  processExpiredLocks(
    _relock: boolean,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  queueNewRewards(
    _rewardsToken: string,
    _rewards: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  queuedRewards(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  recoverERC20(
    _tokenAddress: string,
    _tokenAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  renounceOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  rewardData(
    arg0: string,
    overrides?: CallOverrides,
  ): Promise<
    [number, number, BigNumber, BigNumber] & {
      periodFinish: number;
      lastUpdateTime: number;
      rewardRate: BigNumber;
      rewardPerTokenStored: BigNumber;
    }
  >;

  rewardDistributors(arg0: string, arg1: string, overrides?: CallOverrides): Promise<boolean>;

  rewardPerToken(_rewardsToken: string, overrides?: CallOverrides): Promise<BigNumber>;

  rewardTokens(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

  rewardsDuration(overrides?: CallOverrides): Promise<BigNumber>;

  setApprovals(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  setKickIncentive(
    _rate: BigNumberish,
    _delay: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  shutdown(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  stakingToken(overrides?: CallOverrides): Promise<string>;

  symbol(overrides?: CallOverrides): Promise<string>;

  totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  totalSupplyAtEpoch(_epoch: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  userData(
    arg0: string,
    arg1: string,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber] & {
      rewardPerTokenPaid: BigNumber;
      rewards: BigNumber;
    }
  >;

  userLocks(
    arg0: string,
    arg1: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, number] & { amount: BigNumber; unlockTime: number }>;

  callStatic: {
    addReward(_rewardsToken: string, _distributor: string, overrides?: CallOverrides): Promise<void>;

    approveRewardDistributor(
      _rewardsToken: string,
      _distributor: string,
      _approved: boolean,
      overrides?: CallOverrides,
    ): Promise<void>;

    balanceAtEpochOf(_epoch: BigNumberish, _user: string, overrides?: CallOverrides): Promise<BigNumber>;

    balanceOf(_user: string, overrides?: CallOverrides): Promise<BigNumber>;

    balances(
      arg0: string,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, number] & { locked: BigNumber; nextUnlockIndex: number }>;

    blacklist(arg0: string, overrides?: CallOverrides): Promise<boolean>;

    checkpointEpoch(overrides?: CallOverrides): Promise<void>;

    checkpoints(
      account: string,
      pos: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<AuraLocker.DelegateeCheckpointStructOutput>;

    claimableRewards(_account: string, overrides?: CallOverrides): Promise<AuraLocker.EarnedDataStructOutput[]>;

    cvxCrv(overrides?: CallOverrides): Promise<string>;

    cvxcrvStaking(overrides?: CallOverrides): Promise<string>;

    decimals(overrides?: CallOverrides): Promise<number>;

    delegate(newDelegatee: string, overrides?: CallOverrides): Promise<void>;

    delegateeUnlocks(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    delegates(account: string, overrides?: CallOverrides): Promise<string>;

    denominator(overrides?: CallOverrides): Promise<BigNumber>;

    emergencyWithdraw(overrides?: CallOverrides): Promise<void>;

    epochCount(overrides?: CallOverrides): Promise<BigNumber>;

    epochs(
      arg0: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, number] & { supply: BigNumber; date: number }>;

    findEpochId(_time: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    getPastTotalSupply(timestamp: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    getPastVotes(account: string, timestamp: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    'getReward(address,bool)'(_account: string, _stake: boolean, overrides?: CallOverrides): Promise<void>;

    'getReward(address)'(_account: string, overrides?: CallOverrides): Promise<void>;

    'getReward(address,bool[])'(_account: string, _skipIdx: boolean[], overrides?: CallOverrides): Promise<void>;

    getVotes(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    isShutdown(overrides?: CallOverrides): Promise<boolean>;

    kickExpiredLocks(_account: string, overrides?: CallOverrides): Promise<void>;

    kickRewardEpochDelay(overrides?: CallOverrides): Promise<BigNumber>;

    kickRewardPerEpoch(overrides?: CallOverrides): Promise<BigNumber>;

    lastTimeRewardApplicable(_rewardsToken: string, overrides?: CallOverrides): Promise<BigNumber>;

    lock(_account: string, _amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

    lockDuration(overrides?: CallOverrides): Promise<BigNumber>;

    lockedBalances(
      _user: string,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, AuraLocker.LockedBalanceStructOutput[]] & {
        total: BigNumber;
        unlockable: BigNumber;
        locked: BigNumber;
        lockData: AuraLocker.LockedBalanceStructOutput[];
      }
    >;

    lockedSupply(overrides?: CallOverrides): Promise<BigNumber>;

    modifyBlacklist(_account: string, _blacklisted: boolean, overrides?: CallOverrides): Promise<void>;

    name(overrides?: CallOverrides): Promise<string>;

    newRewardRatio(overrides?: CallOverrides): Promise<BigNumber>;

    numCheckpoints(account: string, overrides?: CallOverrides): Promise<number>;

    owner(overrides?: CallOverrides): Promise<string>;

    processExpiredLocks(_relock: boolean, overrides?: CallOverrides): Promise<void>;

    queueNewRewards(_rewardsToken: string, _rewards: BigNumberish, overrides?: CallOverrides): Promise<void>;

    queuedRewards(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    recoverERC20(_tokenAddress: string, _tokenAmount: BigNumberish, overrides?: CallOverrides): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    rewardData(
      arg0: string,
      overrides?: CallOverrides,
    ): Promise<
      [number, number, BigNumber, BigNumber] & {
        periodFinish: number;
        lastUpdateTime: number;
        rewardRate: BigNumber;
        rewardPerTokenStored: BigNumber;
      }
    >;

    rewardDistributors(arg0: string, arg1: string, overrides?: CallOverrides): Promise<boolean>;

    rewardPerToken(_rewardsToken: string, overrides?: CallOverrides): Promise<BigNumber>;

    rewardTokens(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

    rewardsDuration(overrides?: CallOverrides): Promise<BigNumber>;

    setApprovals(overrides?: CallOverrides): Promise<void>;

    setKickIncentive(_rate: BigNumberish, _delay: BigNumberish, overrides?: CallOverrides): Promise<void>;

    shutdown(overrides?: CallOverrides): Promise<void>;

    stakingToken(overrides?: CallOverrides): Promise<string>;

    symbol(overrides?: CallOverrides): Promise<string>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    totalSupplyAtEpoch(_epoch: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(newOwner: string, overrides?: CallOverrides): Promise<void>;

    userData(
      arg0: string,
      arg1: string,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        rewardPerTokenPaid: BigNumber;
        rewards: BigNumber;
      }
    >;

    userLocks(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, number] & { amount: BigNumber; unlockTime: number }>;
  };

  filters: {
    'BlacklistModified(address,bool)'(account?: null, blacklisted?: null): BlacklistModifiedEventFilter;
    BlacklistModified(account?: null, blacklisted?: null): BlacklistModifiedEventFilter;

    'DelegateChanged(address,address,address)'(
      delegator?: string | null,
      fromDelegate?: string | null,
      toDelegate?: string | null,
    ): DelegateChangedEventFilter;
    DelegateChanged(
      delegator?: string | null,
      fromDelegate?: string | null,
      toDelegate?: string | null,
    ): DelegateChangedEventFilter;

    'DelegateCheckpointed(address)'(delegate?: string | null): DelegateCheckpointedEventFilter;
    DelegateCheckpointed(delegate?: string | null): DelegateCheckpointedEventFilter;

    'KickIncentiveSet(uint256,uint256)'(rate?: null, delay?: null): KickIncentiveSetEventFilter;
    KickIncentiveSet(rate?: null, delay?: null): KickIncentiveSetEventFilter;

    'KickReward(address,address,uint256)'(
      _user?: string | null,
      _kicked?: string | null,
      _reward?: null,
    ): KickRewardEventFilter;
    KickReward(_user?: string | null, _kicked?: string | null, _reward?: null): KickRewardEventFilter;

    'OwnershipTransferred(address,address)'(
      previousOwner?: string | null,
      newOwner?: string | null,
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter;

    'Recovered(address,uint256)'(_token?: null, _amount?: null): RecoveredEventFilter;
    Recovered(_token?: null, _amount?: null): RecoveredEventFilter;

    'RewardAdded(address,uint256)'(_token?: string | null, _reward?: null): RewardAddedEventFilter;
    RewardAdded(_token?: string | null, _reward?: null): RewardAddedEventFilter;

    'RewardPaid(address,address,uint256)'(
      _user?: string | null,
      _rewardsToken?: string | null,
      _reward?: null,
    ): RewardPaidEventFilter;
    RewardPaid(_user?: string | null, _rewardsToken?: string | null, _reward?: null): RewardPaidEventFilter;

    'Shutdown()'(): ShutdownEventFilter;
    Shutdown(): ShutdownEventFilter;

    'Staked(address,uint256,uint256)'(
      _user?: string | null,
      _paidAmount?: null,
      _lockedAmount?: null,
    ): StakedEventFilter;
    Staked(_user?: string | null, _paidAmount?: null, _lockedAmount?: null): StakedEventFilter;

    'Withdrawn(address,uint256,bool)'(_user?: string | null, _amount?: null, _relocked?: null): WithdrawnEventFilter;
    Withdrawn(_user?: string | null, _amount?: null, _relocked?: null): WithdrawnEventFilter;
  };

  estimateGas: {
    addReward(
      _rewardsToken: string,
      _distributor: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    approveRewardDistributor(
      _rewardsToken: string,
      _distributor: string,
      _approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    balanceAtEpochOf(_epoch: BigNumberish, _user: string, overrides?: CallOverrides): Promise<BigNumber>;

    balanceOf(_user: string, overrides?: CallOverrides): Promise<BigNumber>;

    balances(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    blacklist(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    checkpointEpoch(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    checkpoints(account: string, pos: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    claimableRewards(_account: string, overrides?: CallOverrides): Promise<BigNumber>;

    cvxCrv(overrides?: CallOverrides): Promise<BigNumber>;

    cvxcrvStaking(overrides?: CallOverrides): Promise<BigNumber>;

    decimals(overrides?: CallOverrides): Promise<BigNumber>;

    delegate(newDelegatee: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    delegateeUnlocks(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    delegates(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    denominator(overrides?: CallOverrides): Promise<BigNumber>;

    emergencyWithdraw(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    epochCount(overrides?: CallOverrides): Promise<BigNumber>;

    epochs(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    findEpochId(_time: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    getPastTotalSupply(timestamp: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    getPastVotes(account: string, timestamp: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    'getReward(address,bool)'(
      _account: string,
      _stake: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    'getReward(address)'(
      _account: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    'getReward(address,bool[])'(
      _account: string,
      _skipIdx: boolean[],
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    getVotes(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    isShutdown(overrides?: CallOverrides): Promise<BigNumber>;

    kickExpiredLocks(_account: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    kickRewardEpochDelay(overrides?: CallOverrides): Promise<BigNumber>;

    kickRewardPerEpoch(overrides?: CallOverrides): Promise<BigNumber>;

    lastTimeRewardApplicable(_rewardsToken: string, overrides?: CallOverrides): Promise<BigNumber>;

    lock(
      _account: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    lockDuration(overrides?: CallOverrides): Promise<BigNumber>;

    lockedBalances(_user: string, overrides?: CallOverrides): Promise<BigNumber>;

    lockedSupply(overrides?: CallOverrides): Promise<BigNumber>;

    modifyBlacklist(
      _account: string,
      _blacklisted: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    newRewardRatio(overrides?: CallOverrides): Promise<BigNumber>;

    numCheckpoints(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    processExpiredLocks(
      _relock: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    queueNewRewards(
      _rewardsToken: string,
      _rewards: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    queuedRewards(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    recoverERC20(
      _tokenAddress: string,
      _tokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    renounceOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    rewardData(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    rewardDistributors(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;

    rewardPerToken(_rewardsToken: string, overrides?: CallOverrides): Promise<BigNumber>;

    rewardTokens(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    rewardsDuration(overrides?: CallOverrides): Promise<BigNumber>;

    setApprovals(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    setKickIncentive(
      _rate: BigNumberish,
      _delay: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    shutdown(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    stakingToken(overrides?: CallOverrides): Promise<BigNumber>;

    symbol(overrides?: CallOverrides): Promise<BigNumber>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    totalSupplyAtEpoch(_epoch: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    userData(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;

    userLocks(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    addReward(
      _rewardsToken: string,
      _distributor: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    approveRewardDistributor(
      _rewardsToken: string,
      _distributor: string,
      _approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    balanceAtEpochOf(_epoch: BigNumberish, _user: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    balanceOf(_user: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    balances(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    blacklist(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    checkpointEpoch(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    checkpoints(account: string, pos: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    claimableRewards(_account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    cvxCrv(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    cvxcrvStaking(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    delegate(
      newDelegatee: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    delegateeUnlocks(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    delegates(account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    denominator(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    emergencyWithdraw(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    epochCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    epochs(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    findEpochId(_time: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getPastTotalSupply(timestamp: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getPastVotes(account: string, timestamp: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'getReward(address,bool)'(
      _account: string,
      _stake: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    'getReward(address)'(
      _account: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    'getReward(address,bool[])'(
      _account: string,
      _skipIdx: boolean[],
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    getVotes(account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isShutdown(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    kickExpiredLocks(
      _account: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    kickRewardEpochDelay(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    kickRewardPerEpoch(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastTimeRewardApplicable(_rewardsToken: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lock(
      _account: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    lockDuration(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lockedBalances(_user: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lockedSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    modifyBlacklist(
      _account: string,
      _blacklisted: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    newRewardRatio(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    numCheckpoints(account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    processExpiredLocks(
      _relock: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    queueNewRewards(
      _rewardsToken: string,
      _rewards: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    queuedRewards(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    recoverERC20(
      _tokenAddress: string,
      _tokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    rewardData(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardDistributors(arg0: string, arg1: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardPerToken(_rewardsToken: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardTokens(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardsDuration(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setApprovals(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    setKickIncentive(
      _rate: BigNumberish,
      _delay: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    shutdown(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    stakingToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalSupplyAtEpoch(_epoch: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    userData(arg0: string, arg1: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    userLocks(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}

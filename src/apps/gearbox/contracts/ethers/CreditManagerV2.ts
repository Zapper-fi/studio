/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export interface CreditManagerV2Interface extends utils.Interface {
  functions: {
    '_accountFactory()': FunctionFragment;
    '_acl()': FunctionFragment;
    'adapterToContract(address)': FunctionFragment;
    'addCollateral(address,address,address,uint256)': FunctionFragment;
    'addEmergencyLiquidator(address)': FunctionFragment;
    'addToken(address)': FunctionFragment;
    'approveCreditAccount(address,address,address,uint256)': FunctionFragment;
    'calcClosePayments(uint256,uint8,uint256,uint256)': FunctionFragment;
    'calcCreditAccountAccruedInterest(address)': FunctionFragment;
    'canLiquidateWhilePaused(address)': FunctionFragment;
    'changeContractAllowance(address,address)': FunctionFragment;
    'checkAndEnableToken(address,address)': FunctionFragment;
    'checkAndOptimizeEnabledTokens(address)': FunctionFragment;
    'checkEmergencyPausable(address,bool)': FunctionFragment;
    'closeCreditAccount(address,uint8,uint256,address,address,uint256,bool)': FunctionFragment;
    'collateralTokens(uint256)': FunctionFragment;
    'collateralTokensByMask(uint256)': FunctionFragment;
    'collateralTokensCount()': FunctionFragment;
    'contractToAdapter(address)': FunctionFragment;
    'creditAccounts(address)': FunctionFragment;
    'creditConfigurator()': FunctionFragment;
    'creditFacade()': FunctionFragment;
    'cumulativeDropAtFastCheckRAY(address)': FunctionFragment;
    'disableToken(address,address)': FunctionFragment;
    'emergencyLiquidation()': FunctionFragment;
    'enabledTokensMap(address)': FunctionFragment;
    'executeOrder(address,address,bytes)': FunctionFragment;
    'fastCollateralCheck(address,address,address,uint256,uint256)': FunctionFragment;
    'fees()': FunctionFragment;
    'forbiddenTokenMask()': FunctionFragment;
    'fullCollateralCheck(address)': FunctionFragment;
    'getCreditAccountOrRevert(address)': FunctionFragment;
    'liquidationThresholds(address)': FunctionFragment;
    'manageDebt(address,uint256,bool)': FunctionFragment;
    'maxAllowedEnabledTokenLength()': FunctionFragment;
    'openCreditAccount(uint256,address)': FunctionFragment;
    'pause()': FunctionFragment;
    'paused()': FunctionFragment;
    'pool()': FunctionFragment;
    'poolService()': FunctionFragment;
    'priceOracle()': FunctionFragment;
    'removeEmergencyLiquidator(address)': FunctionFragment;
    'setConfigurator(address)': FunctionFragment;
    'setForbidMask(uint256)': FunctionFragment;
    'setLiquidationThreshold(address,uint16)': FunctionFragment;
    'setMaxEnabledTokens(uint8)': FunctionFragment;
    'setParams(uint16,uint16,uint16,uint16,uint16)': FunctionFragment;
    'tokenMasksMap(address)': FunctionFragment;
    'transferAccountOwnership(address,address)': FunctionFragment;
    'underlying()': FunctionFragment;
    'universalAdapter()': FunctionFragment;
    'unpause()': FunctionFragment;
    'upgradeCreditFacade(address)': FunctionFragment;
    'upgradePriceOracle(address)': FunctionFragment;
    'version()': FunctionFragment;
    'wethAddress()': FunctionFragment;
    'wethGateway()': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | '_accountFactory'
      | '_acl'
      | 'adapterToContract'
      | 'addCollateral'
      | 'addEmergencyLiquidator'
      | 'addToken'
      | 'approveCreditAccount'
      | 'calcClosePayments'
      | 'calcCreditAccountAccruedInterest'
      | 'canLiquidateWhilePaused'
      | 'changeContractAllowance'
      | 'checkAndEnableToken'
      | 'checkAndOptimizeEnabledTokens'
      | 'checkEmergencyPausable'
      | 'closeCreditAccount'
      | 'collateralTokens'
      | 'collateralTokensByMask'
      | 'collateralTokensCount'
      | 'contractToAdapter'
      | 'creditAccounts'
      | 'creditConfigurator'
      | 'creditFacade'
      | 'cumulativeDropAtFastCheckRAY'
      | 'disableToken'
      | 'emergencyLiquidation'
      | 'enabledTokensMap'
      | 'executeOrder'
      | 'fastCollateralCheck'
      | 'fees'
      | 'forbiddenTokenMask'
      | 'fullCollateralCheck'
      | 'getCreditAccountOrRevert'
      | 'liquidationThresholds'
      | 'manageDebt'
      | 'maxAllowedEnabledTokenLength'
      | 'openCreditAccount'
      | 'pause'
      | 'paused'
      | 'pool'
      | 'poolService'
      | 'priceOracle'
      | 'removeEmergencyLiquidator'
      | 'setConfigurator'
      | 'setForbidMask'
      | 'setLiquidationThreshold'
      | 'setMaxEnabledTokens'
      | 'setParams'
      | 'tokenMasksMap'
      | 'transferAccountOwnership'
      | 'underlying'
      | 'universalAdapter'
      | 'unpause'
      | 'upgradeCreditFacade'
      | 'upgradePriceOracle'
      | 'version'
      | 'wethAddress'
      | 'wethGateway',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: '_accountFactory', values?: undefined): string;
  encodeFunctionData(functionFragment: '_acl', values?: undefined): string;
  encodeFunctionData(functionFragment: 'adapterToContract', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'addCollateral',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'addEmergencyLiquidator', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'addToken', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'approveCreditAccount',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'calcClosePayments',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'calcCreditAccountAccruedInterest', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'canLiquidateWhilePaused', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'changeContractAllowance',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'checkAndEnableToken',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'checkAndOptimizeEnabledTokens', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'checkEmergencyPausable',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'closeCreditAccount',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'collateralTokens', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'collateralTokensByMask', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'collateralTokensCount', values?: undefined): string;
  encodeFunctionData(functionFragment: 'contractToAdapter', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'creditAccounts', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'creditConfigurator', values?: undefined): string;
  encodeFunctionData(functionFragment: 'creditFacade', values?: undefined): string;
  encodeFunctionData(functionFragment: 'cumulativeDropAtFastCheckRAY', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'disableToken',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'emergencyLiquidation', values?: undefined): string;
  encodeFunctionData(functionFragment: 'enabledTokensMap', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'executeOrder',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'fastCollateralCheck',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'fees', values?: undefined): string;
  encodeFunctionData(functionFragment: 'forbiddenTokenMask', values?: undefined): string;
  encodeFunctionData(functionFragment: 'fullCollateralCheck', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getCreditAccountOrRevert', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'liquidationThresholds', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'manageDebt',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'maxAllowedEnabledTokenLength', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'openCreditAccount',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'pause', values?: undefined): string;
  encodeFunctionData(functionFragment: 'paused', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pool', values?: undefined): string;
  encodeFunctionData(functionFragment: 'poolService', values?: undefined): string;
  encodeFunctionData(functionFragment: 'priceOracle', values?: undefined): string;
  encodeFunctionData(functionFragment: 'removeEmergencyLiquidator', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setConfigurator', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setForbidMask', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'setLiquidationThreshold',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'setMaxEnabledTokens', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'setParams',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'tokenMasksMap', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'transferAccountOwnership',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'underlying', values?: undefined): string;
  encodeFunctionData(functionFragment: 'universalAdapter', values?: undefined): string;
  encodeFunctionData(functionFragment: 'unpause', values?: undefined): string;
  encodeFunctionData(functionFragment: 'upgradeCreditFacade', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'upgradePriceOracle', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'version', values?: undefined): string;
  encodeFunctionData(functionFragment: 'wethAddress', values?: undefined): string;
  encodeFunctionData(functionFragment: 'wethGateway', values?: undefined): string;

  decodeFunctionResult(functionFragment: '_accountFactory', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: '_acl', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'adapterToContract', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addCollateral', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addEmergencyLiquidator', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'approveCreditAccount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'calcClosePayments', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'calcCreditAccountAccruedInterest', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'canLiquidateWhilePaused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'changeContractAllowance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'checkAndEnableToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'checkAndOptimizeEnabledTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'checkEmergencyPausable', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'closeCreditAccount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'collateralTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'collateralTokensByMask', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'collateralTokensCount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'contractToAdapter', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'creditAccounts', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'creditConfigurator', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'creditFacade', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cumulativeDropAtFastCheckRAY', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'disableToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'emergencyLiquidation', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'enabledTokensMap', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'executeOrder', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'fastCollateralCheck', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'fees', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'forbiddenTokenMask', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'fullCollateralCheck', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getCreditAccountOrRevert', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidationThresholds', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'manageDebt', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'maxAllowedEnabledTokenLength', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'openCreditAccount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pause', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'paused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pool', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'poolService', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'priceOracle', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'removeEmergencyLiquidator', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setConfigurator', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setForbidMask', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setLiquidationThreshold', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMaxEnabledTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setParams', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tokenMasksMap', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferAccountOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'underlying', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'universalAdapter', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'unpause', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'upgradeCreditFacade', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'upgradePriceOracle', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'version', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'wethAddress', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'wethGateway', data: BytesLike): Result;

  events: {
    'ExecuteOrder(address,address)': EventFragment;
    'NewConfigurator(address)': EventFragment;
    'Paused(address)': EventFragment;
    'Unpaused(address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'ExecuteOrder'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NewConfigurator'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Paused'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Unpaused'): EventFragment;
}

export interface ExecuteOrderEventObject {
  borrower: string;
  target: string;
}
export type ExecuteOrderEvent = TypedEvent<[string, string], ExecuteOrderEventObject>;

export type ExecuteOrderEventFilter = TypedEventFilter<ExecuteOrderEvent>;

export interface NewConfiguratorEventObject {
  newConfigurator: string;
}
export type NewConfiguratorEvent = TypedEvent<[string], NewConfiguratorEventObject>;

export type NewConfiguratorEventFilter = TypedEventFilter<NewConfiguratorEvent>;

export interface PausedEventObject {
  account: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface UnpausedEventObject {
  account: string;
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface CreditManagerV2 extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: CreditManagerV2Interface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    _accountFactory(overrides?: CallOverrides): Promise<[string]>;

    _acl(overrides?: CallOverrides): Promise<[string]>;

    adapterToContract(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;

    addCollateral(
      payer: PromiseOrValue<string>,
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    addEmergencyLiquidator(
      liquidator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    addToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    approveCreditAccount(
      borrower: PromiseOrValue<string>,
      targetContract: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    calcClosePayments(
      totalValue: PromiseOrValue<BigNumberish>,
      closureActionType: PromiseOrValue<BigNumberish>,
      borrowedAmount: PromiseOrValue<BigNumberish>,
      borrowedAmountWithInterest: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        amountToPool: BigNumber;
        remainingFunds: BigNumber;
        profit: BigNumber;
        loss: BigNumber;
      }
    >;

    calcCreditAccountAccruedInterest(
      creditAccount: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        borrowedAmount: BigNumber;
        borrowedAmountWithInterest: BigNumber;
        borrowedAmountWithInterestAndFees: BigNumber;
      }
    >;

    canLiquidateWhilePaused(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    changeContractAllowance(
      adapter: PromiseOrValue<string>,
      targetContract: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    checkAndEnableToken(
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    checkAndOptimizeEnabledTokens(
      creditAccount: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    checkEmergencyPausable(
      caller: PromiseOrValue<string>,
      state: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    closeCreditAccount(
      borrower: PromiseOrValue<string>,
      closureActionType: PromiseOrValue<BigNumberish>,
      totalValue: PromiseOrValue<BigNumberish>,
      payer: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      skipTokenMask: PromiseOrValue<BigNumberish>,
      convertWETH: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    collateralTokens(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string, number] & { token: string; liquidationThreshold: number }>;

    collateralTokensByMask(
      tokenMask: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string, number] & { token: string; liquidationThreshold: number }>;

    collateralTokensCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    contractToAdapter(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;

    creditAccounts(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;

    creditConfigurator(overrides?: CallOverrides): Promise<[string]>;

    creditFacade(overrides?: CallOverrides): Promise<[string]>;

    cumulativeDropAtFastCheckRAY(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    disableToken(
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    emergencyLiquidation(overrides?: CallOverrides): Promise<[boolean]>;

    enabledTokensMap(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    executeOrder(
      borrower: PromiseOrValue<string>,
      targetContract: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    fastCollateralCheck(
      creditAccount: PromiseOrValue<string>,
      tokenIn: PromiseOrValue<string>,
      tokenOut: PromiseOrValue<string>,
      balanceInBefore: PromiseOrValue<BigNumberish>,
      balanceOutBefore: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    fees(overrides?: CallOverrides): Promise<
      [number, number, number, number, number] & {
        feeInterest: number;
        feeLiquidation: number;
        liquidationDiscount: number;
        feeLiquidationExpired: number;
        liquidationDiscountExpired: number;
      }
    >;

    forbiddenTokenMask(overrides?: CallOverrides): Promise<[BigNumber]>;

    fullCollateralCheck(
      creditAccount: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    getCreditAccountOrRevert(
      borrower: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[string] & { result: string }>;

    liquidationThresholds(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[number] & { lt: number }>;

    manageDebt(
      creditAccount: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      increase: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    maxAllowedEnabledTokenLength(overrides?: CallOverrides): Promise<[number]>;

    openCreditAccount(
      borrowedAmount: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    pool(overrides?: CallOverrides): Promise<[string]>;

    poolService(overrides?: CallOverrides): Promise<[string]>;

    priceOracle(overrides?: CallOverrides): Promise<[string]>;

    removeEmergencyLiquidator(
      liquidator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setConfigurator(
      _creditConfigurator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setForbidMask(
      _forbidMask: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setLiquidationThreshold(
      token: PromiseOrValue<string>,
      liquidationThreshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setMaxEnabledTokens(
      newMaxEnabledTokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setParams(
      _feeInterest: PromiseOrValue<BigNumberish>,
      _feeLiquidation: PromiseOrValue<BigNumberish>,
      _liquidationDiscount: PromiseOrValue<BigNumberish>,
      _feeLiquidationExpired: PromiseOrValue<BigNumberish>,
      _liquidationDiscountExpired: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    tokenMasksMap(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber] & { mask: BigNumber }>;

    transferAccountOwnership(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    underlying(overrides?: CallOverrides): Promise<[string]>;

    universalAdapter(overrides?: CallOverrides): Promise<[string]>;

    unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    upgradeCreditFacade(
      _creditFacade: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    upgradePriceOracle(
      _priceOracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    version(overrides?: CallOverrides): Promise<[BigNumber]>;

    wethAddress(overrides?: CallOverrides): Promise<[string]>;

    wethGateway(overrides?: CallOverrides): Promise<[string]>;
  };

  _accountFactory(overrides?: CallOverrides): Promise<string>;

  _acl(overrides?: CallOverrides): Promise<string>;

  adapterToContract(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  addCollateral(
    payer: PromiseOrValue<string>,
    creditAccount: PromiseOrValue<string>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  addEmergencyLiquidator(
    liquidator: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  addToken(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  approveCreditAccount(
    borrower: PromiseOrValue<string>,
    targetContract: PromiseOrValue<string>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  calcClosePayments(
    totalValue: PromiseOrValue<BigNumberish>,
    closureActionType: PromiseOrValue<BigNumberish>,
    borrowedAmount: PromiseOrValue<BigNumberish>,
    borrowedAmountWithInterest: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber] & {
      amountToPool: BigNumber;
      remainingFunds: BigNumber;
      profit: BigNumber;
      loss: BigNumber;
    }
  >;

  calcCreditAccountAccruedInterest(
    creditAccount: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      borrowedAmount: BigNumber;
      borrowedAmountWithInterest: BigNumber;
      borrowedAmountWithInterestAndFees: BigNumber;
    }
  >;

  canLiquidateWhilePaused(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  changeContractAllowance(
    adapter: PromiseOrValue<string>,
    targetContract: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  checkAndEnableToken(
    creditAccount: PromiseOrValue<string>,
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  checkAndOptimizeEnabledTokens(
    creditAccount: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  checkEmergencyPausable(
    caller: PromiseOrValue<string>,
    state: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  closeCreditAccount(
    borrower: PromiseOrValue<string>,
    closureActionType: PromiseOrValue<BigNumberish>,
    totalValue: PromiseOrValue<BigNumberish>,
    payer: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    skipTokenMask: PromiseOrValue<BigNumberish>,
    convertWETH: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  collateralTokens(
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<[string, number] & { token: string; liquidationThreshold: number }>;

  collateralTokensByMask(
    tokenMask: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<[string, number] & { token: string; liquidationThreshold: number }>;

  collateralTokensCount(overrides?: CallOverrides): Promise<BigNumber>;

  contractToAdapter(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  creditAccounts(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  creditConfigurator(overrides?: CallOverrides): Promise<string>;

  creditFacade(overrides?: CallOverrides): Promise<string>;

  cumulativeDropAtFastCheckRAY(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  disableToken(
    creditAccount: PromiseOrValue<string>,
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  emergencyLiquidation(overrides?: CallOverrides): Promise<boolean>;

  enabledTokensMap(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  executeOrder(
    borrower: PromiseOrValue<string>,
    targetContract: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  fastCollateralCheck(
    creditAccount: PromiseOrValue<string>,
    tokenIn: PromiseOrValue<string>,
    tokenOut: PromiseOrValue<string>,
    balanceInBefore: PromiseOrValue<BigNumberish>,
    balanceOutBefore: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  fees(overrides?: CallOverrides): Promise<
    [number, number, number, number, number] & {
      feeInterest: number;
      feeLiquidation: number;
      liquidationDiscount: number;
      feeLiquidationExpired: number;
      liquidationDiscountExpired: number;
    }
  >;

  forbiddenTokenMask(overrides?: CallOverrides): Promise<BigNumber>;

  fullCollateralCheck(
    creditAccount: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  getCreditAccountOrRevert(borrower: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  liquidationThresholds(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<number>;

  manageDebt(
    creditAccount: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    increase: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  maxAllowedEnabledTokenLength(overrides?: CallOverrides): Promise<number>;

  openCreditAccount(
    borrowedAmount: PromiseOrValue<BigNumberish>,
    onBehalfOf: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  pool(overrides?: CallOverrides): Promise<string>;

  poolService(overrides?: CallOverrides): Promise<string>;

  priceOracle(overrides?: CallOverrides): Promise<string>;

  removeEmergencyLiquidator(
    liquidator: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setConfigurator(
    _creditConfigurator: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setForbidMask(
    _forbidMask: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setLiquidationThreshold(
    token: PromiseOrValue<string>,
    liquidationThreshold: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setMaxEnabledTokens(
    newMaxEnabledTokens: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setParams(
    _feeInterest: PromiseOrValue<BigNumberish>,
    _feeLiquidation: PromiseOrValue<BigNumberish>,
    _liquidationDiscount: PromiseOrValue<BigNumberish>,
    _feeLiquidationExpired: PromiseOrValue<BigNumberish>,
    _liquidationDiscountExpired: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  tokenMasksMap(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  transferAccountOwnership(
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  underlying(overrides?: CallOverrides): Promise<string>;

  universalAdapter(overrides?: CallOverrides): Promise<string>;

  unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  upgradeCreditFacade(
    _creditFacade: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  upgradePriceOracle(
    _priceOracle: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  version(overrides?: CallOverrides): Promise<BigNumber>;

  wethAddress(overrides?: CallOverrides): Promise<string>;

  wethGateway(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    _accountFactory(overrides?: CallOverrides): Promise<string>;

    _acl(overrides?: CallOverrides): Promise<string>;

    adapterToContract(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    addCollateral(
      payer: PromiseOrValue<string>,
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    addEmergencyLiquidator(liquidator: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    addToken(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    approveCreditAccount(
      borrower: PromiseOrValue<string>,
      targetContract: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    calcClosePayments(
      totalValue: PromiseOrValue<BigNumberish>,
      closureActionType: PromiseOrValue<BigNumberish>,
      borrowedAmount: PromiseOrValue<BigNumberish>,
      borrowedAmountWithInterest: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        amountToPool: BigNumber;
        remainingFunds: BigNumber;
        profit: BigNumber;
        loss: BigNumber;
      }
    >;

    calcCreditAccountAccruedInterest(
      creditAccount: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        borrowedAmount: BigNumber;
        borrowedAmountWithInterest: BigNumber;
        borrowedAmountWithInterestAndFees: BigNumber;
      }
    >;

    canLiquidateWhilePaused(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    changeContractAllowance(
      adapter: PromiseOrValue<string>,
      targetContract: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    checkAndEnableToken(
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    checkAndOptimizeEnabledTokens(creditAccount: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    checkEmergencyPausable(
      caller: PromiseOrValue<string>,
      state: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    closeCreditAccount(
      borrower: PromiseOrValue<string>,
      closureActionType: PromiseOrValue<BigNumberish>,
      totalValue: PromiseOrValue<BigNumberish>,
      payer: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      skipTokenMask: PromiseOrValue<BigNumberish>,
      convertWETH: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    collateralTokens(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string, number] & { token: string; liquidationThreshold: number }>;

    collateralTokensByMask(
      tokenMask: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string, number] & { token: string; liquidationThreshold: number }>;

    collateralTokensCount(overrides?: CallOverrides): Promise<BigNumber>;

    contractToAdapter(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    creditAccounts(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    creditConfigurator(overrides?: CallOverrides): Promise<string>;

    creditFacade(overrides?: CallOverrides): Promise<string>;

    cumulativeDropAtFastCheckRAY(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    disableToken(
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    emergencyLiquidation(overrides?: CallOverrides): Promise<boolean>;

    enabledTokensMap(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    executeOrder(
      borrower: PromiseOrValue<string>,
      targetContract: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<string>;

    fastCollateralCheck(
      creditAccount: PromiseOrValue<string>,
      tokenIn: PromiseOrValue<string>,
      tokenOut: PromiseOrValue<string>,
      balanceInBefore: PromiseOrValue<BigNumberish>,
      balanceOutBefore: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    fees(overrides?: CallOverrides): Promise<
      [number, number, number, number, number] & {
        feeInterest: number;
        feeLiquidation: number;
        liquidationDiscount: number;
        feeLiquidationExpired: number;
        liquidationDiscountExpired: number;
      }
    >;

    forbiddenTokenMask(overrides?: CallOverrides): Promise<BigNumber>;

    fullCollateralCheck(creditAccount: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    getCreditAccountOrRevert(borrower: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    liquidationThresholds(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<number>;

    manageDebt(
      creditAccount: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      increase: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    maxAllowedEnabledTokenLength(overrides?: CallOverrides): Promise<number>;

    openCreditAccount(
      borrowedAmount: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<string>;

    pause(overrides?: CallOverrides): Promise<void>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    pool(overrides?: CallOverrides): Promise<string>;

    poolService(overrides?: CallOverrides): Promise<string>;

    priceOracle(overrides?: CallOverrides): Promise<string>;

    removeEmergencyLiquidator(liquidator: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setConfigurator(_creditConfigurator: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setForbidMask(_forbidMask: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setLiquidationThreshold(
      token: PromiseOrValue<string>,
      liquidationThreshold: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setMaxEnabledTokens(newMaxEnabledTokens: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setParams(
      _feeInterest: PromiseOrValue<BigNumberish>,
      _feeLiquidation: PromiseOrValue<BigNumberish>,
      _liquidationDiscount: PromiseOrValue<BigNumberish>,
      _feeLiquidationExpired: PromiseOrValue<BigNumberish>,
      _liquidationDiscountExpired: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    tokenMasksMap(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    transferAccountOwnership(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    underlying(overrides?: CallOverrides): Promise<string>;

    universalAdapter(overrides?: CallOverrides): Promise<string>;

    unpause(overrides?: CallOverrides): Promise<void>;

    upgradeCreditFacade(_creditFacade: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    upgradePriceOracle(_priceOracle: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    version(overrides?: CallOverrides): Promise<BigNumber>;

    wethAddress(overrides?: CallOverrides): Promise<string>;

    wethGateway(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    'ExecuteOrder(address,address)'(
      borrower?: PromiseOrValue<string> | null,
      target?: PromiseOrValue<string> | null,
    ): ExecuteOrderEventFilter;
    ExecuteOrder(
      borrower?: PromiseOrValue<string> | null,
      target?: PromiseOrValue<string> | null,
    ): ExecuteOrderEventFilter;

    'NewConfigurator(address)'(newConfigurator?: PromiseOrValue<string> | null): NewConfiguratorEventFilter;
    NewConfigurator(newConfigurator?: PromiseOrValue<string> | null): NewConfiguratorEventFilter;

    'Paused(address)'(account?: null): PausedEventFilter;
    Paused(account?: null): PausedEventFilter;

    'Unpaused(address)'(account?: null): UnpausedEventFilter;
    Unpaused(account?: null): UnpausedEventFilter;
  };

  estimateGas: {
    _accountFactory(overrides?: CallOverrides): Promise<BigNumber>;

    _acl(overrides?: CallOverrides): Promise<BigNumber>;

    adapterToContract(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    addCollateral(
      payer: PromiseOrValue<string>,
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    addEmergencyLiquidator(
      liquidator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    addToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    approveCreditAccount(
      borrower: PromiseOrValue<string>,
      targetContract: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    calcClosePayments(
      totalValue: PromiseOrValue<BigNumberish>,
      closureActionType: PromiseOrValue<BigNumberish>,
      borrowedAmount: PromiseOrValue<BigNumberish>,
      borrowedAmountWithInterest: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    calcCreditAccountAccruedInterest(
      creditAccount: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    canLiquidateWhilePaused(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    changeContractAllowance(
      adapter: PromiseOrValue<string>,
      targetContract: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    checkAndEnableToken(
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    checkAndOptimizeEnabledTokens(
      creditAccount: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    checkEmergencyPausable(
      caller: PromiseOrValue<string>,
      state: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    closeCreditAccount(
      borrower: PromiseOrValue<string>,
      closureActionType: PromiseOrValue<BigNumberish>,
      totalValue: PromiseOrValue<BigNumberish>,
      payer: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      skipTokenMask: PromiseOrValue<BigNumberish>,
      convertWETH: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    collateralTokens(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    collateralTokensByMask(tokenMask: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    collateralTokensCount(overrides?: CallOverrides): Promise<BigNumber>;

    contractToAdapter(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    creditAccounts(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    creditConfigurator(overrides?: CallOverrides): Promise<BigNumber>;

    creditFacade(overrides?: CallOverrides): Promise<BigNumber>;

    cumulativeDropAtFastCheckRAY(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    disableToken(
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    emergencyLiquidation(overrides?: CallOverrides): Promise<BigNumber>;

    enabledTokensMap(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    executeOrder(
      borrower: PromiseOrValue<string>,
      targetContract: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    fastCollateralCheck(
      creditAccount: PromiseOrValue<string>,
      tokenIn: PromiseOrValue<string>,
      tokenOut: PromiseOrValue<string>,
      balanceInBefore: PromiseOrValue<BigNumberish>,
      balanceOutBefore: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    fees(overrides?: CallOverrides): Promise<BigNumber>;

    forbiddenTokenMask(overrides?: CallOverrides): Promise<BigNumber>;

    fullCollateralCheck(
      creditAccount: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    getCreditAccountOrRevert(borrower: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    liquidationThresholds(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    manageDebt(
      creditAccount: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      increase: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    maxAllowedEnabledTokenLength(overrides?: CallOverrides): Promise<BigNumber>;

    openCreditAccount(
      borrowedAmount: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    pool(overrides?: CallOverrides): Promise<BigNumber>;

    poolService(overrides?: CallOverrides): Promise<BigNumber>;

    priceOracle(overrides?: CallOverrides): Promise<BigNumber>;

    removeEmergencyLiquidator(
      liquidator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setConfigurator(
      _creditConfigurator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setForbidMask(
      _forbidMask: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setLiquidationThreshold(
      token: PromiseOrValue<string>,
      liquidationThreshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setMaxEnabledTokens(
      newMaxEnabledTokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setParams(
      _feeInterest: PromiseOrValue<BigNumberish>,
      _feeLiquidation: PromiseOrValue<BigNumberish>,
      _liquidationDiscount: PromiseOrValue<BigNumberish>,
      _feeLiquidationExpired: PromiseOrValue<BigNumberish>,
      _liquidationDiscountExpired: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    tokenMasksMap(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    transferAccountOwnership(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    underlying(overrides?: CallOverrides): Promise<BigNumber>;

    universalAdapter(overrides?: CallOverrides): Promise<BigNumber>;

    unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    upgradeCreditFacade(
      _creditFacade: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    upgradePriceOracle(
      _priceOracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    version(overrides?: CallOverrides): Promise<BigNumber>;

    wethAddress(overrides?: CallOverrides): Promise<BigNumber>;

    wethGateway(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    _accountFactory(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    _acl(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    adapterToContract(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    addCollateral(
      payer: PromiseOrValue<string>,
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    addEmergencyLiquidator(
      liquidator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    addToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    approveCreditAccount(
      borrower: PromiseOrValue<string>,
      targetContract: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    calcClosePayments(
      totalValue: PromiseOrValue<BigNumberish>,
      closureActionType: PromiseOrValue<BigNumberish>,
      borrowedAmount: PromiseOrValue<BigNumberish>,
      borrowedAmountWithInterest: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    calcCreditAccountAccruedInterest(
      creditAccount: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    canLiquidateWhilePaused(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    changeContractAllowance(
      adapter: PromiseOrValue<string>,
      targetContract: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    checkAndEnableToken(
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    checkAndOptimizeEnabledTokens(
      creditAccount: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    checkEmergencyPausable(
      caller: PromiseOrValue<string>,
      state: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    closeCreditAccount(
      borrower: PromiseOrValue<string>,
      closureActionType: PromiseOrValue<BigNumberish>,
      totalValue: PromiseOrValue<BigNumberish>,
      payer: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      skipTokenMask: PromiseOrValue<BigNumberish>,
      convertWETH: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    collateralTokens(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    collateralTokensByMask(
      tokenMask: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    collateralTokensCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    contractToAdapter(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    creditAccounts(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    creditConfigurator(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    creditFacade(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    cumulativeDropAtFastCheckRAY(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    disableToken(
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    emergencyLiquidation(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    enabledTokensMap(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    executeOrder(
      borrower: PromiseOrValue<string>,
      targetContract: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    fastCollateralCheck(
      creditAccount: PromiseOrValue<string>,
      tokenIn: PromiseOrValue<string>,
      tokenOut: PromiseOrValue<string>,
      balanceInBefore: PromiseOrValue<BigNumberish>,
      balanceOutBefore: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    fees(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    forbiddenTokenMask(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    fullCollateralCheck(
      creditAccount: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    getCreditAccountOrRevert(
      borrower: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    liquidationThresholds(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    manageDebt(
      creditAccount: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      increase: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    maxAllowedEnabledTokenLength(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    openCreditAccount(
      borrowedAmount: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pool(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    poolService(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    priceOracle(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    removeEmergencyLiquidator(
      liquidator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setConfigurator(
      _creditConfigurator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setForbidMask(
      _forbidMask: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setLiquidationThreshold(
      token: PromiseOrValue<string>,
      liquidationThreshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setMaxEnabledTokens(
      newMaxEnabledTokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setParams(
      _feeInterest: PromiseOrValue<BigNumberish>,
      _feeLiquidation: PromiseOrValue<BigNumberish>,
      _liquidationDiscount: PromiseOrValue<BigNumberish>,
      _feeLiquidationExpired: PromiseOrValue<BigNumberish>,
      _liquidationDiscountExpired: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    tokenMasksMap(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferAccountOwnership(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    underlying(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    universalAdapter(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    upgradeCreditFacade(
      _creditFacade: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    upgradePriceOracle(
      _priceOracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    wethAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    wethGateway(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}

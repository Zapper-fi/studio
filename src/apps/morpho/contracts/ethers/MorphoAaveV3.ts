/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export declare namespace Types {
  export type SignatureStruct = {
    v: PromiseOrValue<BigNumberish>;
    r: PromiseOrValue<BytesLike>;
    s: PromiseOrValue<BytesLike>;
  };

  export type SignatureStructOutput = [number, string, string] & {
    v: number;
    r: string;
    s: string;
  };

  export type IterationsStruct = {
    repay: PromiseOrValue<BigNumberish>;
    withdraw: PromiseOrValue<BigNumberish>;
  };

  export type IterationsStructOutput = [BigNumber, BigNumber] & {
    repay: BigNumber;
    withdraw: BigNumber;
  };

  export type LiquidityDataStruct = {
    borrowable: PromiseOrValue<BigNumberish>;
    maxDebt: PromiseOrValue<BigNumberish>;
    debt: PromiseOrValue<BigNumberish>;
  };

  export type LiquidityDataStructOutput = [BigNumber, BigNumber, BigNumber] & {
    borrowable: BigNumber;
    maxDebt: BigNumber;
    debt: BigNumber;
  };

  export type MarketSideIndexesStruct = {
    poolIndex: PromiseOrValue<BigNumberish>;
    p2pIndex: PromiseOrValue<BigNumberish>;
  };

  export type MarketSideIndexesStructOutput = [BigNumber, BigNumber] & {
    poolIndex: BigNumber;
    p2pIndex: BigNumber;
  };

  export type IndexesStruct = {
    supply: Types.MarketSideIndexesStruct;
    borrow: Types.MarketSideIndexesStruct;
  };

  export type IndexesStructOutput = [Types.MarketSideIndexesStructOutput, Types.MarketSideIndexesStructOutput] & {
    supply: Types.MarketSideIndexesStructOutput;
    borrow: Types.MarketSideIndexesStructOutput;
  };

  export type MarketSideDeltaStruct = {
    scaledDelta: PromiseOrValue<BigNumberish>;
    scaledP2PTotal: PromiseOrValue<BigNumberish>;
  };

  export type MarketSideDeltaStructOutput = [BigNumber, BigNumber] & {
    scaledDelta: BigNumber;
    scaledP2PTotal: BigNumber;
  };

  export type DeltasStruct = {
    supply: Types.MarketSideDeltaStruct;
    borrow: Types.MarketSideDeltaStruct;
  };

  export type DeltasStructOutput = [Types.MarketSideDeltaStructOutput, Types.MarketSideDeltaStructOutput] & {
    supply: Types.MarketSideDeltaStructOutput;
    borrow: Types.MarketSideDeltaStructOutput;
  };

  export type PauseStatusesStruct = {
    isP2PDisabled: PromiseOrValue<boolean>;
    isSupplyPaused: PromiseOrValue<boolean>;
    isSupplyCollateralPaused: PromiseOrValue<boolean>;
    isBorrowPaused: PromiseOrValue<boolean>;
    isWithdrawPaused: PromiseOrValue<boolean>;
    isWithdrawCollateralPaused: PromiseOrValue<boolean>;
    isRepayPaused: PromiseOrValue<boolean>;
    isLiquidateCollateralPaused: PromiseOrValue<boolean>;
    isLiquidateBorrowPaused: PromiseOrValue<boolean>;
    isDeprecated: PromiseOrValue<boolean>;
  };

  export type PauseStatusesStructOutput = [
    boolean,
    boolean,
    boolean,
    boolean,
    boolean,
    boolean,
    boolean,
    boolean,
    boolean,
    boolean,
  ] & {
    isP2PDisabled: boolean;
    isSupplyPaused: boolean;
    isSupplyCollateralPaused: boolean;
    isBorrowPaused: boolean;
    isWithdrawPaused: boolean;
    isWithdrawCollateralPaused: boolean;
    isRepayPaused: boolean;
    isLiquidateCollateralPaused: boolean;
    isLiquidateBorrowPaused: boolean;
    isDeprecated: boolean;
  };

  export type MarketStruct = {
    indexes: Types.IndexesStruct;
    deltas: Types.DeltasStruct;
    underlying: PromiseOrValue<string>;
    pauseStatuses: Types.PauseStatusesStruct;
    isCollateral: PromiseOrValue<boolean>;
    variableDebtToken: PromiseOrValue<string>;
    lastUpdateTimestamp: PromiseOrValue<BigNumberish>;
    reserveFactor: PromiseOrValue<BigNumberish>;
    p2pIndexCursor: PromiseOrValue<BigNumberish>;
    aToken: PromiseOrValue<string>;
    stableDebtToken: PromiseOrValue<string>;
    idleSupply: PromiseOrValue<BigNumberish>;
  };

  export type MarketStructOutput = [
    Types.IndexesStructOutput,
    Types.DeltasStructOutput,
    string,
    Types.PauseStatusesStructOutput,
    boolean,
    string,
    number,
    number,
    number,
    string,
    string,
    BigNumber,
  ] & {
    indexes: Types.IndexesStructOutput;
    deltas: Types.DeltasStructOutput;
    underlying: string;
    pauseStatuses: Types.PauseStatusesStructOutput;
    isCollateral: boolean;
    variableDebtToken: string;
    lastUpdateTimestamp: number;
    reserveFactor: number;
    p2pIndexCursor: number;
    aToken: string;
    stableDebtToken: string;
    idleSupply: BigNumber;
  };

  export type MarketSideIndexes256Struct = {
    poolIndex: PromiseOrValue<BigNumberish>;
    p2pIndex: PromiseOrValue<BigNumberish>;
  };

  export type MarketSideIndexes256StructOutput = [BigNumber, BigNumber] & {
    poolIndex: BigNumber;
    p2pIndex: BigNumber;
  };

  export type Indexes256Struct = {
    supply: Types.MarketSideIndexes256Struct;
    borrow: Types.MarketSideIndexes256Struct;
  };

  export type Indexes256StructOutput = [
    Types.MarketSideIndexes256StructOutput,
    Types.MarketSideIndexes256StructOutput,
  ] & {
    supply: Types.MarketSideIndexes256StructOutput;
    borrow: Types.MarketSideIndexes256StructOutput;
  };
}

export interface MorphoAaveV3Interface extends utils.Interface {
  functions: {
    'DOMAIN_SEPARATOR()': FunctionFragment;
    'acceptOwnership()': FunctionFragment;
    'addressesProvider()': FunctionFragment;
    'approveManager(address,bool)': FunctionFragment;
    'approveManagerWithSig(address,address,bool,uint256,uint256,(uint8,bytes32,bytes32))': FunctionFragment;
    'borrow(address,uint256,address,address,uint256)': FunctionFragment;
    'borrowBalance(address,address)': FunctionFragment;
    'claimRewards(address[],address)': FunctionFragment;
    'claimToTreasury(address[],uint256[])': FunctionFragment;
    'collateralBalance(address,address)': FunctionFragment;
    'createMarket(address,uint16,uint16)': FunctionFragment;
    'defaultIterations()': FunctionFragment;
    'eModeCategoryId()': FunctionFragment;
    'getBucketsMask(address,uint8)': FunctionFragment;
    'getNext(address,uint8,address)': FunctionFragment;
    'increaseP2PDeltas(address,uint256)': FunctionFragment;
    'initialize(address,uint8,address,(uint128,uint128))': FunctionFragment;
    'isClaimRewardsPaused()': FunctionFragment;
    'isManagedBy(address,address)': FunctionFragment;
    'liquidate(address,address,address,uint256)': FunctionFragment;
    'liquidityData(address)': FunctionFragment;
    'market(address)': FunctionFragment;
    'marketsCreated()': FunctionFragment;
    'owner()': FunctionFragment;
    'pendingOwner()': FunctionFragment;
    'pool()': FunctionFragment;
    'positionsManager()': FunctionFragment;
    'renounceOwnership()': FunctionFragment;
    'repay(address,uint256,address)': FunctionFragment;
    'repayWithPermit(address,uint256,address,uint256,(uint8,bytes32,bytes32))': FunctionFragment;
    'rewardsManager()': FunctionFragment;
    'scaledCollateralBalance(address,address)': FunctionFragment;
    'scaledP2PBorrowBalance(address,address)': FunctionFragment;
    'scaledP2PSupplyBalance(address,address)': FunctionFragment;
    'scaledPoolBorrowBalance(address,address)': FunctionFragment;
    'scaledPoolSupplyBalance(address,address)': FunctionFragment;
    'setAssetIsCollateral(address,bool)': FunctionFragment;
    'setAssetIsCollateralOnPool(address,bool)': FunctionFragment;
    'setDefaultIterations((uint128,uint128))': FunctionFragment;
    'setIsBorrowPaused(address,bool)': FunctionFragment;
    'setIsClaimRewardsPaused(bool)': FunctionFragment;
    'setIsDeprecated(address,bool)': FunctionFragment;
    'setIsLiquidateBorrowPaused(address,bool)': FunctionFragment;
    'setIsLiquidateCollateralPaused(address,bool)': FunctionFragment;
    'setIsP2PDisabled(address,bool)': FunctionFragment;
    'setIsPaused(address,bool)': FunctionFragment;
    'setIsPausedForAllMarkets(bool)': FunctionFragment;
    'setIsRepayPaused(address,bool)': FunctionFragment;
    'setIsSupplyCollateralPaused(address,bool)': FunctionFragment;
    'setIsSupplyPaused(address,bool)': FunctionFragment;
    'setIsWithdrawCollateralPaused(address,bool)': FunctionFragment;
    'setIsWithdrawPaused(address,bool)': FunctionFragment;
    'setP2PIndexCursor(address,uint16)': FunctionFragment;
    'setPositionsManager(address)': FunctionFragment;
    'setReserveFactor(address,uint16)': FunctionFragment;
    'setRewardsManager(address)': FunctionFragment;
    'setTreasuryVault(address)': FunctionFragment;
    'supply(address,uint256,address,uint256)': FunctionFragment;
    'supplyBalance(address,address)': FunctionFragment;
    'supplyCollateral(address,uint256,address)': FunctionFragment;
    'supplyCollateralWithPermit(address,uint256,address,uint256,(uint8,bytes32,bytes32))': FunctionFragment;
    'supplyWithPermit(address,uint256,address,uint256,uint256,(uint8,bytes32,bytes32))': FunctionFragment;
    'transferOwnership(address)': FunctionFragment;
    'treasuryVault()': FunctionFragment;
    'updatedIndexes(address)': FunctionFragment;
    'userBorrows(address)': FunctionFragment;
    'userCollaterals(address)': FunctionFragment;
    'userNonce(address)': FunctionFragment;
    'withdraw(address,uint256,address,address,uint256)': FunctionFragment;
    'withdrawCollateral(address,uint256,address,address)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'DOMAIN_SEPARATOR'
      | 'acceptOwnership'
      | 'addressesProvider'
      | 'approveManager'
      | 'approveManagerWithSig'
      | 'borrow'
      | 'borrowBalance'
      | 'claimRewards'
      | 'claimToTreasury'
      | 'collateralBalance'
      | 'createMarket'
      | 'defaultIterations'
      | 'eModeCategoryId'
      | 'getBucketsMask'
      | 'getNext'
      | 'increaseP2PDeltas'
      | 'initialize'
      | 'isClaimRewardsPaused'
      | 'isManagedBy'
      | 'liquidate'
      | 'liquidityData'
      | 'market'
      | 'marketsCreated'
      | 'owner'
      | 'pendingOwner'
      | 'pool'
      | 'positionsManager'
      | 'renounceOwnership'
      | 'repay'
      | 'repayWithPermit'
      | 'rewardsManager'
      | 'scaledCollateralBalance'
      | 'scaledP2PBorrowBalance'
      | 'scaledP2PSupplyBalance'
      | 'scaledPoolBorrowBalance'
      | 'scaledPoolSupplyBalance'
      | 'setAssetIsCollateral'
      | 'setAssetIsCollateralOnPool'
      | 'setDefaultIterations'
      | 'setIsBorrowPaused'
      | 'setIsClaimRewardsPaused'
      | 'setIsDeprecated'
      | 'setIsLiquidateBorrowPaused'
      | 'setIsLiquidateCollateralPaused'
      | 'setIsP2PDisabled'
      | 'setIsPaused'
      | 'setIsPausedForAllMarkets'
      | 'setIsRepayPaused'
      | 'setIsSupplyCollateralPaused'
      | 'setIsSupplyPaused'
      | 'setIsWithdrawCollateralPaused'
      | 'setIsWithdrawPaused'
      | 'setP2PIndexCursor'
      | 'setPositionsManager'
      | 'setReserveFactor'
      | 'setRewardsManager'
      | 'setTreasuryVault'
      | 'supply'
      | 'supplyBalance'
      | 'supplyCollateral'
      | 'supplyCollateralWithPermit'
      | 'supplyWithPermit'
      | 'transferOwnership'
      | 'treasuryVault'
      | 'updatedIndexes'
      | 'userBorrows'
      | 'userCollaterals'
      | 'userNonce'
      | 'withdraw'
      | 'withdrawCollateral',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'DOMAIN_SEPARATOR', values?: undefined): string;
  encodeFunctionData(functionFragment: 'acceptOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'addressesProvider', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'approveManager',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'approveManagerWithSig',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      Types.SignatureStruct,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'borrow',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'borrowBalance',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'claimRewards',
    values: [PromiseOrValue<string>[], PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'claimToTreasury',
    values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'collateralBalance',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'createMarket',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'defaultIterations', values?: undefined): string;
  encodeFunctionData(functionFragment: 'eModeCategoryId', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'getBucketsMask',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getNext',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'increaseP2PDeltas',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'initialize',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>, Types.IterationsStruct],
  ): string;
  encodeFunctionData(functionFragment: 'isClaimRewardsPaused', values?: undefined): string;
  encodeFunctionData(functionFragment: 'isManagedBy', values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'liquidate',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'liquidityData', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'market', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'marketsCreated', values?: undefined): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pendingOwner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pool', values?: undefined): string;
  encodeFunctionData(functionFragment: 'positionsManager', values?: undefined): string;
  encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'repay',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'repayWithPermit',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      Types.SignatureStruct,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'rewardsManager', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'scaledCollateralBalance',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'scaledP2PBorrowBalance',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'scaledP2PSupplyBalance',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'scaledPoolBorrowBalance',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'scaledPoolSupplyBalance',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setAssetIsCollateral',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setAssetIsCollateralOnPool',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'setDefaultIterations', values: [Types.IterationsStruct]): string;
  encodeFunctionData(
    functionFragment: 'setIsBorrowPaused',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'setIsClaimRewardsPaused', values: [PromiseOrValue<boolean>]): string;
  encodeFunctionData(
    functionFragment: 'setIsDeprecated',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setIsLiquidateBorrowPaused',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setIsLiquidateCollateralPaused',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setIsP2PDisabled',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setIsPaused',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'setIsPausedForAllMarkets', values: [PromiseOrValue<boolean>]): string;
  encodeFunctionData(
    functionFragment: 'setIsRepayPaused',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setIsSupplyCollateralPaused',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setIsSupplyPaused',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setIsWithdrawCollateralPaused',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setIsWithdrawPaused',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setP2PIndexCursor',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'setPositionsManager', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'setReserveFactor',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'setRewardsManager', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setTreasuryVault', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'supply',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'supplyBalance',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'supplyCollateral',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'supplyCollateralWithPermit',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      Types.SignatureStruct,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'supplyWithPermit',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      Types.SignatureStruct,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'transferOwnership', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'treasuryVault', values?: undefined): string;
  encodeFunctionData(functionFragment: 'updatedIndexes', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'userBorrows', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'userCollaterals', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'userNonce', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'withdraw',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'withdrawCollateral',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;

  decodeFunctionResult(functionFragment: 'DOMAIN_SEPARATOR', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'acceptOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addressesProvider', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'approveManager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'approveManagerWithSig', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'borrow', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'borrowBalance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimToTreasury', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'collateralBalance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'createMarket', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'defaultIterations', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'eModeCategoryId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getBucketsMask', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getNext', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'increaseP2PDeltas', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isClaimRewardsPaused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isManagedBy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidityData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'market', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'marketsCreated', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pendingOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pool', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'positionsManager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'repay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'repayWithPermit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardsManager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'scaledCollateralBalance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'scaledP2PBorrowBalance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'scaledP2PSupplyBalance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'scaledPoolBorrowBalance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'scaledPoolSupplyBalance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setAssetIsCollateral', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setAssetIsCollateralOnPool', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setDefaultIterations', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setIsBorrowPaused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setIsClaimRewardsPaused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setIsDeprecated', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setIsLiquidateBorrowPaused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setIsLiquidateCollateralPaused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setIsP2PDisabled', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setIsPaused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setIsPausedForAllMarkets', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setIsRepayPaused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setIsSupplyCollateralPaused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setIsSupplyPaused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setIsWithdrawCollateralPaused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setIsWithdrawPaused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setP2PIndexCursor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setPositionsManager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setReserveFactor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setRewardsManager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setTreasuryVault', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'supply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'supplyBalance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'supplyCollateral', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'supplyCollateralWithPermit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'supplyWithPermit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'treasuryVault', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updatedIndexes', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userBorrows', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userCollaterals', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userNonce', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawCollateral', data: BytesLike): Result;

  events: {
    'Initialized(uint8)': EventFragment;
    'OwnershipTransferStarted(address,address)': EventFragment;
    'OwnershipTransferred(address,address)': EventFragment;
    'BorrowPositionUpdated(address,address,uint256,uint256)': EventFragment;
    'Borrowed(address,address,address,address,uint256,uint256,uint256)': EventFragment;
    'CollateralSupplied(address,address,address,uint256,uint256)': EventFragment;
    'CollateralWithdrawn(address,address,address,address,uint256,uint256)': EventFragment;
    'DefaultIterationsSet(uint128,uint128)': EventFragment;
    'IdleSupplyUpdated(address,uint256)': EventFragment;
    'IndexesUpdated(address,uint256,uint256,uint256,uint256)': EventFragment;
    'IsBorrowPausedSet(address,bool)': EventFragment;
    'IsClaimRewardsPausedSet(bool)': EventFragment;
    'IsCollateralSet(address,bool)': EventFragment;
    'IsDeprecatedSet(address,bool)': EventFragment;
    'IsLiquidateBorrowPausedSet(address,bool)': EventFragment;
    'IsLiquidateCollateralPausedSet(address,bool)': EventFragment;
    'IsP2PDisabledSet(address,bool)': EventFragment;
    'IsRepayPausedSet(address,bool)': EventFragment;
    'IsSupplyCollateralPausedSet(address,bool)': EventFragment;
    'IsSupplyPausedSet(address,bool)': EventFragment;
    'IsWithdrawCollateralPausedSet(address,bool)': EventFragment;
    'IsWithdrawPausedSet(address,bool)': EventFragment;
    'Liquidated(address,address,address,uint256,address,uint256)': EventFragment;
    'ManagerApproval(address,address,bool)': EventFragment;
    'MarketCreated(address)': EventFragment;
    'P2PBorrowDeltaUpdated(address,uint256)': EventFragment;
    'P2PDeltasIncreased(address,uint256)': EventFragment;
    'P2PIndexCursorSet(address,uint16)': EventFragment;
    'P2PSupplyDeltaUpdated(address,uint256)': EventFragment;
    'P2PTotalsUpdated(address,uint256,uint256)': EventFragment;
    'PositionsManagerSet(address)': EventFragment;
    'Repaid(address,address,address,uint256,uint256,uint256)': EventFragment;
    'ReserveFactorSet(address,uint16)': EventFragment;
    'ReserveFeeClaimed(address,uint256)': EventFragment;
    'RewardsClaimed(address,address,address,uint256)': EventFragment;
    'RewardsManagerSet(address)': EventFragment;
    'Supplied(address,address,address,uint256,uint256,uint256)': EventFragment;
    'SupplyPositionUpdated(address,address,uint256,uint256)': EventFragment;
    'TreasuryVaultSet(address)': EventFragment;
    'UserNonceIncremented(address,address,uint256)': EventFragment;
    'Withdrawn(address,address,address,address,uint256,uint256,uint256)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'Initialized'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferStarted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'BorrowPositionUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Borrowed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CollateralSupplied'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CollateralWithdrawn'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'DefaultIterationsSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'IdleSupplyUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'IndexesUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'IsBorrowPausedSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'IsClaimRewardsPausedSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'IsCollateralSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'IsDeprecatedSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'IsLiquidateBorrowPausedSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'IsLiquidateCollateralPausedSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'IsP2PDisabledSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'IsRepayPausedSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'IsSupplyCollateralPausedSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'IsSupplyPausedSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'IsWithdrawCollateralPausedSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'IsWithdrawPausedSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Liquidated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ManagerApproval'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'MarketCreated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'P2PBorrowDeltaUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'P2PDeltasIncreased'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'P2PIndexCursorSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'P2PSupplyDeltaUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'P2PTotalsUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'PositionsManagerSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Repaid'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ReserveFactorSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ReserveFeeClaimed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardsClaimed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardsManagerSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Supplied'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SupplyPositionUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TreasuryVaultSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'UserNonceIncremented'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Withdrawn'): EventFragment;
}

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface OwnershipTransferStartedEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferStartedEvent = TypedEvent<[string, string], OwnershipTransferStartedEventObject>;

export type OwnershipTransferStartedEventFilter = TypedEventFilter<OwnershipTransferStartedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<[string, string], OwnershipTransferredEventObject>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export interface BorrowPositionUpdatedEventObject {
  user: string;
  underlying: string;
  scaledOnPool: BigNumber;
  scaledInP2P: BigNumber;
}
export type BorrowPositionUpdatedEvent = TypedEvent<
  [string, string, BigNumber, BigNumber],
  BorrowPositionUpdatedEventObject
>;

export type BorrowPositionUpdatedEventFilter = TypedEventFilter<BorrowPositionUpdatedEvent>;

export interface BorrowedEventObject {
  caller: string;
  onBehalf: string;
  receiver: string;
  underlying: string;
  amount: BigNumber;
  scaledOnPool: BigNumber;
  scaledInP2P: BigNumber;
}
export type BorrowedEvent = TypedEvent<
  [string, string, string, string, BigNumber, BigNumber, BigNumber],
  BorrowedEventObject
>;

export type BorrowedEventFilter = TypedEventFilter<BorrowedEvent>;

export interface CollateralSuppliedEventObject {
  from: string;
  onBehalf: string;
  underlying: string;
  amount: BigNumber;
  scaledBalance: BigNumber;
}
export type CollateralSuppliedEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  CollateralSuppliedEventObject
>;

export type CollateralSuppliedEventFilter = TypedEventFilter<CollateralSuppliedEvent>;

export interface CollateralWithdrawnEventObject {
  caller: string;
  onBehalf: string;
  receiver: string;
  underlying: string;
  amount: BigNumber;
  scaledBalance: BigNumber;
}
export type CollateralWithdrawnEvent = TypedEvent<
  [string, string, string, string, BigNumber, BigNumber],
  CollateralWithdrawnEventObject
>;

export type CollateralWithdrawnEventFilter = TypedEventFilter<CollateralWithdrawnEvent>;

export interface DefaultIterationsSetEventObject {
  repay: BigNumber;
  withdraw: BigNumber;
}
export type DefaultIterationsSetEvent = TypedEvent<[BigNumber, BigNumber], DefaultIterationsSetEventObject>;

export type DefaultIterationsSetEventFilter = TypedEventFilter<DefaultIterationsSetEvent>;

export interface IdleSupplyUpdatedEventObject {
  underlying: string;
  idleSupply: BigNumber;
}
export type IdleSupplyUpdatedEvent = TypedEvent<[string, BigNumber], IdleSupplyUpdatedEventObject>;

export type IdleSupplyUpdatedEventFilter = TypedEventFilter<IdleSupplyUpdatedEvent>;

export interface IndexesUpdatedEventObject {
  underlying: string;
  poolSupplyIndex: BigNumber;
  p2pSupplyIndex: BigNumber;
  poolBorrowIndex: BigNumber;
  p2pBorrowIndex: BigNumber;
}
export type IndexesUpdatedEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, BigNumber],
  IndexesUpdatedEventObject
>;

export type IndexesUpdatedEventFilter = TypedEventFilter<IndexesUpdatedEvent>;

export interface IsBorrowPausedSetEventObject {
  underlying: string;
  isPaused: boolean;
}
export type IsBorrowPausedSetEvent = TypedEvent<[string, boolean], IsBorrowPausedSetEventObject>;

export type IsBorrowPausedSetEventFilter = TypedEventFilter<IsBorrowPausedSetEvent>;

export interface IsClaimRewardsPausedSetEventObject {
  isPaused: boolean;
}
export type IsClaimRewardsPausedSetEvent = TypedEvent<[boolean], IsClaimRewardsPausedSetEventObject>;

export type IsClaimRewardsPausedSetEventFilter = TypedEventFilter<IsClaimRewardsPausedSetEvent>;

export interface IsCollateralSetEventObject {
  underlying: string;
  isCollateral: boolean;
}
export type IsCollateralSetEvent = TypedEvent<[string, boolean], IsCollateralSetEventObject>;

export type IsCollateralSetEventFilter = TypedEventFilter<IsCollateralSetEvent>;

export interface IsDeprecatedSetEventObject {
  underlying: string;
  isDeprecated: boolean;
}
export type IsDeprecatedSetEvent = TypedEvent<[string, boolean], IsDeprecatedSetEventObject>;

export type IsDeprecatedSetEventFilter = TypedEventFilter<IsDeprecatedSetEvent>;

export interface IsLiquidateBorrowPausedSetEventObject {
  underlying: string;
  isPaused: boolean;
}
export type IsLiquidateBorrowPausedSetEvent = TypedEvent<[string, boolean], IsLiquidateBorrowPausedSetEventObject>;

export type IsLiquidateBorrowPausedSetEventFilter = TypedEventFilter<IsLiquidateBorrowPausedSetEvent>;

export interface IsLiquidateCollateralPausedSetEventObject {
  underlying: string;
  isPaused: boolean;
}
export type IsLiquidateCollateralPausedSetEvent = TypedEvent<
  [string, boolean],
  IsLiquidateCollateralPausedSetEventObject
>;

export type IsLiquidateCollateralPausedSetEventFilter = TypedEventFilter<IsLiquidateCollateralPausedSetEvent>;

export interface IsP2PDisabledSetEventObject {
  underlying: string;
  isP2PDisabled: boolean;
}
export type IsP2PDisabledSetEvent = TypedEvent<[string, boolean], IsP2PDisabledSetEventObject>;

export type IsP2PDisabledSetEventFilter = TypedEventFilter<IsP2PDisabledSetEvent>;

export interface IsRepayPausedSetEventObject {
  underlying: string;
  isPaused: boolean;
}
export type IsRepayPausedSetEvent = TypedEvent<[string, boolean], IsRepayPausedSetEventObject>;

export type IsRepayPausedSetEventFilter = TypedEventFilter<IsRepayPausedSetEvent>;

export interface IsSupplyCollateralPausedSetEventObject {
  underlying: string;
  isPaused: boolean;
}
export type IsSupplyCollateralPausedSetEvent = TypedEvent<[string, boolean], IsSupplyCollateralPausedSetEventObject>;

export type IsSupplyCollateralPausedSetEventFilter = TypedEventFilter<IsSupplyCollateralPausedSetEvent>;

export interface IsSupplyPausedSetEventObject {
  underlying: string;
  isPaused: boolean;
}
export type IsSupplyPausedSetEvent = TypedEvent<[string, boolean], IsSupplyPausedSetEventObject>;

export type IsSupplyPausedSetEventFilter = TypedEventFilter<IsSupplyPausedSetEvent>;

export interface IsWithdrawCollateralPausedSetEventObject {
  underlying: string;
  isPaused: boolean;
}
export type IsWithdrawCollateralPausedSetEvent = TypedEvent<
  [string, boolean],
  IsWithdrawCollateralPausedSetEventObject
>;

export type IsWithdrawCollateralPausedSetEventFilter = TypedEventFilter<IsWithdrawCollateralPausedSetEvent>;

export interface IsWithdrawPausedSetEventObject {
  underlying: string;
  isPaused: boolean;
}
export type IsWithdrawPausedSetEvent = TypedEvent<[string, boolean], IsWithdrawPausedSetEventObject>;

export type IsWithdrawPausedSetEventFilter = TypedEventFilter<IsWithdrawPausedSetEvent>;

export interface LiquidatedEventObject {
  liquidator: string;
  borrower: string;
  underlyingBorrowed: string;
  amountLiquidated: BigNumber;
  underlyingCollateral: string;
  amountSeized: BigNumber;
}
export type LiquidatedEvent = TypedEvent<[string, string, string, BigNumber, string, BigNumber], LiquidatedEventObject>;

export type LiquidatedEventFilter = TypedEventFilter<LiquidatedEvent>;

export interface ManagerApprovalEventObject {
  delegator: string;
  manager: string;
  isAllowed: boolean;
}
export type ManagerApprovalEvent = TypedEvent<[string, string, boolean], ManagerApprovalEventObject>;

export type ManagerApprovalEventFilter = TypedEventFilter<ManagerApprovalEvent>;

export interface MarketCreatedEventObject {
  underlying: string;
}
export type MarketCreatedEvent = TypedEvent<[string], MarketCreatedEventObject>;

export type MarketCreatedEventFilter = TypedEventFilter<MarketCreatedEvent>;

export interface P2PBorrowDeltaUpdatedEventObject {
  underlying: string;
  scaledDelta: BigNumber;
}
export type P2PBorrowDeltaUpdatedEvent = TypedEvent<[string, BigNumber], P2PBorrowDeltaUpdatedEventObject>;

export type P2PBorrowDeltaUpdatedEventFilter = TypedEventFilter<P2PBorrowDeltaUpdatedEvent>;

export interface P2PDeltasIncreasedEventObject {
  underlying: string;
  amount: BigNumber;
}
export type P2PDeltasIncreasedEvent = TypedEvent<[string, BigNumber], P2PDeltasIncreasedEventObject>;

export type P2PDeltasIncreasedEventFilter = TypedEventFilter<P2PDeltasIncreasedEvent>;

export interface P2PIndexCursorSetEventObject {
  underlying: string;
  p2pIndexCursor: number;
}
export type P2PIndexCursorSetEvent = TypedEvent<[string, number], P2PIndexCursorSetEventObject>;

export type P2PIndexCursorSetEventFilter = TypedEventFilter<P2PIndexCursorSetEvent>;

export interface P2PSupplyDeltaUpdatedEventObject {
  underlying: string;
  scaledDelta: BigNumber;
}
export type P2PSupplyDeltaUpdatedEvent = TypedEvent<[string, BigNumber], P2PSupplyDeltaUpdatedEventObject>;

export type P2PSupplyDeltaUpdatedEventFilter = TypedEventFilter<P2PSupplyDeltaUpdatedEvent>;

export interface P2PTotalsUpdatedEventObject {
  underlying: string;
  scaledTotalSupplyP2P: BigNumber;
  scaledTotalBorrowP2P: BigNumber;
}
export type P2PTotalsUpdatedEvent = TypedEvent<[string, BigNumber, BigNumber], P2PTotalsUpdatedEventObject>;

export type P2PTotalsUpdatedEventFilter = TypedEventFilter<P2PTotalsUpdatedEvent>;

export interface PositionsManagerSetEventObject {
  positionsManager: string;
}
export type PositionsManagerSetEvent = TypedEvent<[string], PositionsManagerSetEventObject>;

export type PositionsManagerSetEventFilter = TypedEventFilter<PositionsManagerSetEvent>;

export interface RepaidEventObject {
  repayer: string;
  onBehalf: string;
  underlying: string;
  amount: BigNumber;
  scaledOnPool: BigNumber;
  scaledInP2P: BigNumber;
}
export type RepaidEvent = TypedEvent<[string, string, string, BigNumber, BigNumber, BigNumber], RepaidEventObject>;

export type RepaidEventFilter = TypedEventFilter<RepaidEvent>;

export interface ReserveFactorSetEventObject {
  underlying: string;
  reserveFactor: number;
}
export type ReserveFactorSetEvent = TypedEvent<[string, number], ReserveFactorSetEventObject>;

export type ReserveFactorSetEventFilter = TypedEventFilter<ReserveFactorSetEvent>;

export interface ReserveFeeClaimedEventObject {
  underlying: string;
  claimed: BigNumber;
}
export type ReserveFeeClaimedEvent = TypedEvent<[string, BigNumber], ReserveFeeClaimedEventObject>;

export type ReserveFeeClaimedEventFilter = TypedEventFilter<ReserveFeeClaimedEvent>;

export interface RewardsClaimedEventObject {
  claimer: string;
  onBehalf: string;
  rewardToken: string;
  amountClaimed: BigNumber;
}
export type RewardsClaimedEvent = TypedEvent<[string, string, string, BigNumber], RewardsClaimedEventObject>;

export type RewardsClaimedEventFilter = TypedEventFilter<RewardsClaimedEvent>;

export interface RewardsManagerSetEventObject {
  rewardsManager: string;
}
export type RewardsManagerSetEvent = TypedEvent<[string], RewardsManagerSetEventObject>;

export type RewardsManagerSetEventFilter = TypedEventFilter<RewardsManagerSetEvent>;

export interface SuppliedEventObject {
  from: string;
  onBehalf: string;
  underlying: string;
  amount: BigNumber;
  scaledOnPool: BigNumber;
  scaledInP2P: BigNumber;
}
export type SuppliedEvent = TypedEvent<[string, string, string, BigNumber, BigNumber, BigNumber], SuppliedEventObject>;

export type SuppliedEventFilter = TypedEventFilter<SuppliedEvent>;

export interface SupplyPositionUpdatedEventObject {
  user: string;
  underlying: string;
  scaledOnPool: BigNumber;
  scaledInP2P: BigNumber;
}
export type SupplyPositionUpdatedEvent = TypedEvent<
  [string, string, BigNumber, BigNumber],
  SupplyPositionUpdatedEventObject
>;

export type SupplyPositionUpdatedEventFilter = TypedEventFilter<SupplyPositionUpdatedEvent>;

export interface TreasuryVaultSetEventObject {
  treasuryVault: string;
}
export type TreasuryVaultSetEvent = TypedEvent<[string], TreasuryVaultSetEventObject>;

export type TreasuryVaultSetEventFilter = TypedEventFilter<TreasuryVaultSetEvent>;

export interface UserNonceIncrementedEventObject {
  caller: string;
  signatory: string;
  usedNonce: BigNumber;
}
export type UserNonceIncrementedEvent = TypedEvent<[string, string, BigNumber], UserNonceIncrementedEventObject>;

export type UserNonceIncrementedEventFilter = TypedEventFilter<UserNonceIncrementedEvent>;

export interface WithdrawnEventObject {
  caller: string;
  onBehalf: string;
  receiver: string;
  underlying: string;
  amount: BigNumber;
  scaledOnPool: BigNumber;
  scaledInP2P: BigNumber;
}
export type WithdrawnEvent = TypedEvent<
  [string, string, string, string, BigNumber, BigNumber, BigNumber],
  WithdrawnEventObject
>;

export type WithdrawnEventFilter = TypedEventFilter<WithdrawnEvent>;

export interface MorphoAaveV3 extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: MorphoAaveV3Interface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;

    acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    addressesProvider(overrides?: CallOverrides): Promise<[string]>;

    approveManager(
      manager: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    approveManagerWithSig(
      delegator: PromiseOrValue<string>,
      manager: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      nonce: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    borrow(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    borrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    claimRewards(
      assets: PromiseOrValue<string>[],
      onBehalf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    claimToTreasury(
      underlyings: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    collateralBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    createMarket(
      underlying: PromiseOrValue<string>,
      reserveFactor: PromiseOrValue<BigNumberish>,
      p2pIndexCursor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    defaultIterations(overrides?: CallOverrides): Promise<[Types.IterationsStructOutput]>;

    eModeCategoryId(overrides?: CallOverrides): Promise<[BigNumber]>;

    getBucketsMask(
      underlying: PromiseOrValue<string>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    getNext(
      underlying: PromiseOrValue<string>,
      position: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[string]>;

    increaseP2PDeltas(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    initialize(
      addressesProvider: PromiseOrValue<string>,
      eModeCategoryId: PromiseOrValue<BigNumberish>,
      positionsManager: PromiseOrValue<string>,
      defaultIterations: Types.IterationsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    isClaimRewardsPaused(overrides?: CallOverrides): Promise<[boolean]>;

    isManagedBy(
      delegator: PromiseOrValue<string>,
      manager: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    liquidate(
      underlyingBorrowed: PromiseOrValue<string>,
      underlyingCollateral: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    liquidityData(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[Types.LiquidityDataStructOutput]>;

    market(underlying: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[Types.MarketStructOutput]>;

    marketsCreated(overrides?: CallOverrides): Promise<[string[]]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pendingOwner(overrides?: CallOverrides): Promise<[string]>;

    pool(overrides?: CallOverrides): Promise<[string]>;

    positionsManager(overrides?: CallOverrides): Promise<[string]>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    repay(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    repayWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    rewardsManager(overrides?: CallOverrides): Promise<[string]>;

    scaledCollateralBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    scaledP2PBorrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    scaledP2PSupplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    scaledPoolBorrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    scaledPoolSupplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    setAssetIsCollateral(
      underlying: PromiseOrValue<string>,
      isCollateral: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setAssetIsCollateralOnPool(
      underlying: PromiseOrValue<string>,
      isCollateral: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setDefaultIterations(
      defaultIterations: Types.IterationsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setIsBorrowPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setIsClaimRewardsPaused(
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setIsDeprecated(
      underlying: PromiseOrValue<string>,
      isDeprecated: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setIsLiquidateBorrowPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setIsLiquidateCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setIsP2PDisabled(
      underlying: PromiseOrValue<string>,
      isP2PDisabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setIsPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setIsPausedForAllMarkets(
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setIsRepayPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setIsSupplyCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setIsSupplyPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setIsWithdrawCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setIsWithdrawPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setP2PIndexCursor(
      underlying: PromiseOrValue<string>,
      p2pIndexCursor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setPositionsManager(
      positionsManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setReserveFactor(
      underlying: PromiseOrValue<string>,
      newReserveFactor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setRewardsManager(
      rewardsManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setTreasuryVault(
      treasuryVault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    supply(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    supplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    supplyCollateral(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    supplyCollateralWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    supplyWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    treasuryVault(overrides?: CallOverrides): Promise<[string]>;

    updatedIndexes(
      underlying: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[Types.Indexes256StructOutput] & { indexes: Types.Indexes256StructOutput }>;

    userBorrows(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string[]]>;

    userCollaterals(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string[]]>;

    userNonce(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    withdraw(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    withdrawCollateral(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;
  };

  DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

  acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  addressesProvider(overrides?: CallOverrides): Promise<string>;

  approveManager(
    manager: PromiseOrValue<string>,
    isAllowed: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  approveManagerWithSig(
    delegator: PromiseOrValue<string>,
    manager: PromiseOrValue<string>,
    isAllowed: PromiseOrValue<boolean>,
    nonce: PromiseOrValue<BigNumberish>,
    deadline: PromiseOrValue<BigNumberish>,
    signature: Types.SignatureStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  borrow(
    underlying: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    onBehalf: PromiseOrValue<string>,
    receiver: PromiseOrValue<string>,
    maxIterations: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  borrowBalance(
    underlying: PromiseOrValue<string>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  claimRewards(
    assets: PromiseOrValue<string>[],
    onBehalf: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  claimToTreasury(
    underlyings: PromiseOrValue<string>[],
    amounts: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  collateralBalance(
    underlying: PromiseOrValue<string>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  createMarket(
    underlying: PromiseOrValue<string>,
    reserveFactor: PromiseOrValue<BigNumberish>,
    p2pIndexCursor: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  defaultIterations(overrides?: CallOverrides): Promise<Types.IterationsStructOutput>;

  eModeCategoryId(overrides?: CallOverrides): Promise<BigNumber>;

  getBucketsMask(
    underlying: PromiseOrValue<string>,
    position: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  getNext(
    underlying: PromiseOrValue<string>,
    position: PromiseOrValue<BigNumberish>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<string>;

  increaseP2PDeltas(
    underlying: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  initialize(
    addressesProvider: PromiseOrValue<string>,
    eModeCategoryId: PromiseOrValue<BigNumberish>,
    positionsManager: PromiseOrValue<string>,
    defaultIterations: Types.IterationsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  isClaimRewardsPaused(overrides?: CallOverrides): Promise<boolean>;

  isManagedBy(
    delegator: PromiseOrValue<string>,
    manager: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  liquidate(
    underlyingBorrowed: PromiseOrValue<string>,
    underlyingCollateral: PromiseOrValue<string>,
    user: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  liquidityData(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<Types.LiquidityDataStructOutput>;

  market(underlying: PromiseOrValue<string>, overrides?: CallOverrides): Promise<Types.MarketStructOutput>;

  marketsCreated(overrides?: CallOverrides): Promise<string[]>;

  owner(overrides?: CallOverrides): Promise<string>;

  pendingOwner(overrides?: CallOverrides): Promise<string>;

  pool(overrides?: CallOverrides): Promise<string>;

  positionsManager(overrides?: CallOverrides): Promise<string>;

  renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  repay(
    underlying: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    onBehalf: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  repayWithPermit(
    underlying: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    onBehalf: PromiseOrValue<string>,
    deadline: PromiseOrValue<BigNumberish>,
    signature: Types.SignatureStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  rewardsManager(overrides?: CallOverrides): Promise<string>;

  scaledCollateralBalance(
    underlying: PromiseOrValue<string>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  scaledP2PBorrowBalance(
    underlying: PromiseOrValue<string>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  scaledP2PSupplyBalance(
    underlying: PromiseOrValue<string>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  scaledPoolBorrowBalance(
    underlying: PromiseOrValue<string>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  scaledPoolSupplyBalance(
    underlying: PromiseOrValue<string>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  setAssetIsCollateral(
    underlying: PromiseOrValue<string>,
    isCollateral: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setAssetIsCollateralOnPool(
    underlying: PromiseOrValue<string>,
    isCollateral: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setDefaultIterations(
    defaultIterations: Types.IterationsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setIsBorrowPaused(
    underlying: PromiseOrValue<string>,
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setIsClaimRewardsPaused(
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setIsDeprecated(
    underlying: PromiseOrValue<string>,
    isDeprecated: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setIsLiquidateBorrowPaused(
    underlying: PromiseOrValue<string>,
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setIsLiquidateCollateralPaused(
    underlying: PromiseOrValue<string>,
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setIsP2PDisabled(
    underlying: PromiseOrValue<string>,
    isP2PDisabled: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setIsPaused(
    underlying: PromiseOrValue<string>,
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setIsPausedForAllMarkets(
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setIsRepayPaused(
    underlying: PromiseOrValue<string>,
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setIsSupplyCollateralPaused(
    underlying: PromiseOrValue<string>,
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setIsSupplyPaused(
    underlying: PromiseOrValue<string>,
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setIsWithdrawCollateralPaused(
    underlying: PromiseOrValue<string>,
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setIsWithdrawPaused(
    underlying: PromiseOrValue<string>,
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setP2PIndexCursor(
    underlying: PromiseOrValue<string>,
    p2pIndexCursor: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setPositionsManager(
    positionsManager: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setReserveFactor(
    underlying: PromiseOrValue<string>,
    newReserveFactor: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setRewardsManager(
    rewardsManager: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setTreasuryVault(
    treasuryVault: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  supply(
    underlying: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    onBehalf: PromiseOrValue<string>,
    maxIterations: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  supplyBalance(
    underlying: PromiseOrValue<string>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  supplyCollateral(
    underlying: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    onBehalf: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  supplyCollateralWithPermit(
    underlying: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    onBehalf: PromiseOrValue<string>,
    deadline: PromiseOrValue<BigNumberish>,
    signature: Types.SignatureStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  supplyWithPermit(
    underlying: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    onBehalf: PromiseOrValue<string>,
    maxIterations: PromiseOrValue<BigNumberish>,
    deadline: PromiseOrValue<BigNumberish>,
    signature: Types.SignatureStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  treasuryVault(overrides?: CallOverrides): Promise<string>;

  updatedIndexes(underlying: PromiseOrValue<string>, overrides?: CallOverrides): Promise<Types.Indexes256StructOutput>;

  userBorrows(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string[]>;

  userCollaterals(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string[]>;

  userNonce(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  withdraw(
    underlying: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    onBehalf: PromiseOrValue<string>,
    receiver: PromiseOrValue<string>,
    maxIterations: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  withdrawCollateral(
    underlying: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    onBehalf: PromiseOrValue<string>,
    receiver: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

    acceptOwnership(overrides?: CallOverrides): Promise<void>;

    addressesProvider(overrides?: CallOverrides): Promise<string>;

    approveManager(
      manager: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    approveManagerWithSig(
      delegator: PromiseOrValue<string>,
      manager: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      nonce: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: CallOverrides,
    ): Promise<void>;

    borrow(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    borrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    claimRewards(
      assets: PromiseOrValue<string>[],
      onBehalf: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [string[], BigNumber[]] & {
        rewardTokens: string[];
        claimedAmounts: BigNumber[];
      }
    >;

    claimToTreasury(
      underlyings: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<void>;

    collateralBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    createMarket(
      underlying: PromiseOrValue<string>,
      reserveFactor: PromiseOrValue<BigNumberish>,
      p2pIndexCursor: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    defaultIterations(overrides?: CallOverrides): Promise<Types.IterationsStructOutput>;

    eModeCategoryId(overrides?: CallOverrides): Promise<BigNumber>;

    getBucketsMask(
      underlying: PromiseOrValue<string>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getNext(
      underlying: PromiseOrValue<string>,
      position: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<string>;

    increaseP2PDeltas(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    initialize(
      addressesProvider: PromiseOrValue<string>,
      eModeCategoryId: PromiseOrValue<BigNumberish>,
      positionsManager: PromiseOrValue<string>,
      defaultIterations: Types.IterationsStruct,
      overrides?: CallOverrides,
    ): Promise<void>;

    isClaimRewardsPaused(overrides?: CallOverrides): Promise<boolean>;

    isManagedBy(
      delegator: PromiseOrValue<string>,
      manager: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    liquidate(
      underlyingBorrowed: PromiseOrValue<string>,
      underlyingCollateral: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber]>;

    liquidityData(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<Types.LiquidityDataStructOutput>;

    market(underlying: PromiseOrValue<string>, overrides?: CallOverrides): Promise<Types.MarketStructOutput>;

    marketsCreated(overrides?: CallOverrides): Promise<string[]>;

    owner(overrides?: CallOverrides): Promise<string>;

    pendingOwner(overrides?: CallOverrides): Promise<string>;

    pool(overrides?: CallOverrides): Promise<string>;

    positionsManager(overrides?: CallOverrides): Promise<string>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    repay(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    repayWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    rewardsManager(overrides?: CallOverrides): Promise<string>;

    scaledCollateralBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    scaledP2PBorrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    scaledP2PSupplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    scaledPoolBorrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    scaledPoolSupplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    setAssetIsCollateral(
      underlying: PromiseOrValue<string>,
      isCollateral: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setAssetIsCollateralOnPool(
      underlying: PromiseOrValue<string>,
      isCollateral: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setDefaultIterations(defaultIterations: Types.IterationsStruct, overrides?: CallOverrides): Promise<void>;

    setIsBorrowPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setIsClaimRewardsPaused(isPaused: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;

    setIsDeprecated(
      underlying: PromiseOrValue<string>,
      isDeprecated: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setIsLiquidateBorrowPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setIsLiquidateCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setIsP2PDisabled(
      underlying: PromiseOrValue<string>,
      isP2PDisabled: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setIsPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setIsPausedForAllMarkets(isPaused: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;

    setIsRepayPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setIsSupplyCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setIsSupplyPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setIsWithdrawCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setIsWithdrawPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setP2PIndexCursor(
      underlying: PromiseOrValue<string>,
      p2pIndexCursor: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setPositionsManager(positionsManager: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setReserveFactor(
      underlying: PromiseOrValue<string>,
      newReserveFactor: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setRewardsManager(rewardsManager: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setTreasuryVault(treasuryVault: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    supply(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    supplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    supplyCollateral(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    supplyCollateralWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    supplyWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    transferOwnership(newOwner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    treasuryVault(overrides?: CallOverrides): Promise<string>;

    updatedIndexes(
      underlying: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<Types.Indexes256StructOutput>;

    userBorrows(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string[]>;

    userCollaterals(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string[]>;

    userNonce(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    withdraw(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    withdrawCollateral(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;
  };

  filters: {
    'Initialized(uint8)'(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    'OwnershipTransferStarted(address,address)'(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferStartedEventFilter;
    OwnershipTransferStarted(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferStartedEventFilter;

    'OwnershipTransferred(address,address)'(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;

    'BorrowPositionUpdated(address,address,uint256,uint256)'(
      user?: PromiseOrValue<string> | null,
      underlying?: PromiseOrValue<string> | null,
      scaledOnPool?: null,
      scaledInP2P?: null,
    ): BorrowPositionUpdatedEventFilter;
    BorrowPositionUpdated(
      user?: PromiseOrValue<string> | null,
      underlying?: PromiseOrValue<string> | null,
      scaledOnPool?: null,
      scaledInP2P?: null,
    ): BorrowPositionUpdatedEventFilter;

    'Borrowed(address,address,address,address,uint256,uint256,uint256)'(
      caller?: null,
      onBehalf?: PromiseOrValue<string> | null,
      receiver?: PromiseOrValue<string> | null,
      underlying?: PromiseOrValue<string> | null,
      amount?: null,
      scaledOnPool?: null,
      scaledInP2P?: null,
    ): BorrowedEventFilter;
    Borrowed(
      caller?: null,
      onBehalf?: PromiseOrValue<string> | null,
      receiver?: PromiseOrValue<string> | null,
      underlying?: PromiseOrValue<string> | null,
      amount?: null,
      scaledOnPool?: null,
      scaledInP2P?: null,
    ): BorrowedEventFilter;

    'CollateralSupplied(address,address,address,uint256,uint256)'(
      from?: PromiseOrValue<string> | null,
      onBehalf?: PromiseOrValue<string> | null,
      underlying?: PromiseOrValue<string> | null,
      amount?: null,
      scaledBalance?: null,
    ): CollateralSuppliedEventFilter;
    CollateralSupplied(
      from?: PromiseOrValue<string> | null,
      onBehalf?: PromiseOrValue<string> | null,
      underlying?: PromiseOrValue<string> | null,
      amount?: null,
      scaledBalance?: null,
    ): CollateralSuppliedEventFilter;

    'CollateralWithdrawn(address,address,address,address,uint256,uint256)'(
      caller?: null,
      onBehalf?: PromiseOrValue<string> | null,
      receiver?: PromiseOrValue<string> | null,
      underlying?: PromiseOrValue<string> | null,
      amount?: null,
      scaledBalance?: null,
    ): CollateralWithdrawnEventFilter;
    CollateralWithdrawn(
      caller?: null,
      onBehalf?: PromiseOrValue<string> | null,
      receiver?: PromiseOrValue<string> | null,
      underlying?: PromiseOrValue<string> | null,
      amount?: null,
      scaledBalance?: null,
    ): CollateralWithdrawnEventFilter;

    'DefaultIterationsSet(uint128,uint128)'(repay?: null, withdraw?: null): DefaultIterationsSetEventFilter;
    DefaultIterationsSet(repay?: null, withdraw?: null): DefaultIterationsSetEventFilter;

    'IdleSupplyUpdated(address,uint256)'(
      underlying?: PromiseOrValue<string> | null,
      idleSupply?: null,
    ): IdleSupplyUpdatedEventFilter;
    IdleSupplyUpdated(underlying?: PromiseOrValue<string> | null, idleSupply?: null): IdleSupplyUpdatedEventFilter;

    'IndexesUpdated(address,uint256,uint256,uint256,uint256)'(
      underlying?: PromiseOrValue<string> | null,
      poolSupplyIndex?: null,
      p2pSupplyIndex?: null,
      poolBorrowIndex?: null,
      p2pBorrowIndex?: null,
    ): IndexesUpdatedEventFilter;
    IndexesUpdated(
      underlying?: PromiseOrValue<string> | null,
      poolSupplyIndex?: null,
      p2pSupplyIndex?: null,
      poolBorrowIndex?: null,
      p2pBorrowIndex?: null,
    ): IndexesUpdatedEventFilter;

    'IsBorrowPausedSet(address,bool)'(
      underlying?: PromiseOrValue<string> | null,
      isPaused?: null,
    ): IsBorrowPausedSetEventFilter;
    IsBorrowPausedSet(underlying?: PromiseOrValue<string> | null, isPaused?: null): IsBorrowPausedSetEventFilter;

    'IsClaimRewardsPausedSet(bool)'(isPaused?: null): IsClaimRewardsPausedSetEventFilter;
    IsClaimRewardsPausedSet(isPaused?: null): IsClaimRewardsPausedSetEventFilter;

    'IsCollateralSet(address,bool)'(
      underlying?: PromiseOrValue<string> | null,
      isCollateral?: null,
    ): IsCollateralSetEventFilter;
    IsCollateralSet(underlying?: PromiseOrValue<string> | null, isCollateral?: null): IsCollateralSetEventFilter;

    'IsDeprecatedSet(address,bool)'(
      underlying?: PromiseOrValue<string> | null,
      isDeprecated?: null,
    ): IsDeprecatedSetEventFilter;
    IsDeprecatedSet(underlying?: PromiseOrValue<string> | null, isDeprecated?: null): IsDeprecatedSetEventFilter;

    'IsLiquidateBorrowPausedSet(address,bool)'(
      underlying?: PromiseOrValue<string> | null,
      isPaused?: null,
    ): IsLiquidateBorrowPausedSetEventFilter;
    IsLiquidateBorrowPausedSet(
      underlying?: PromiseOrValue<string> | null,
      isPaused?: null,
    ): IsLiquidateBorrowPausedSetEventFilter;

    'IsLiquidateCollateralPausedSet(address,bool)'(
      underlying?: PromiseOrValue<string> | null,
      isPaused?: null,
    ): IsLiquidateCollateralPausedSetEventFilter;
    IsLiquidateCollateralPausedSet(
      underlying?: PromiseOrValue<string> | null,
      isPaused?: null,
    ): IsLiquidateCollateralPausedSetEventFilter;

    'IsP2PDisabledSet(address,bool)'(
      underlying?: PromiseOrValue<string> | null,
      isP2PDisabled?: null,
    ): IsP2PDisabledSetEventFilter;
    IsP2PDisabledSet(underlying?: PromiseOrValue<string> | null, isP2PDisabled?: null): IsP2PDisabledSetEventFilter;

    'IsRepayPausedSet(address,bool)'(
      underlying?: PromiseOrValue<string> | null,
      isPaused?: null,
    ): IsRepayPausedSetEventFilter;
    IsRepayPausedSet(underlying?: PromiseOrValue<string> | null, isPaused?: null): IsRepayPausedSetEventFilter;

    'IsSupplyCollateralPausedSet(address,bool)'(
      underlying?: PromiseOrValue<string> | null,
      isPaused?: null,
    ): IsSupplyCollateralPausedSetEventFilter;
    IsSupplyCollateralPausedSet(
      underlying?: PromiseOrValue<string> | null,
      isPaused?: null,
    ): IsSupplyCollateralPausedSetEventFilter;

    'IsSupplyPausedSet(address,bool)'(
      underlying?: PromiseOrValue<string> | null,
      isPaused?: null,
    ): IsSupplyPausedSetEventFilter;
    IsSupplyPausedSet(underlying?: PromiseOrValue<string> | null, isPaused?: null): IsSupplyPausedSetEventFilter;

    'IsWithdrawCollateralPausedSet(address,bool)'(
      underlying?: PromiseOrValue<string> | null,
      isPaused?: null,
    ): IsWithdrawCollateralPausedSetEventFilter;
    IsWithdrawCollateralPausedSet(
      underlying?: PromiseOrValue<string> | null,
      isPaused?: null,
    ): IsWithdrawCollateralPausedSetEventFilter;

    'IsWithdrawPausedSet(address,bool)'(
      underlying?: PromiseOrValue<string> | null,
      isPaused?: null,
    ): IsWithdrawPausedSetEventFilter;
    IsWithdrawPausedSet(underlying?: PromiseOrValue<string> | null, isPaused?: null): IsWithdrawPausedSetEventFilter;

    'Liquidated(address,address,address,uint256,address,uint256)'(
      liquidator?: PromiseOrValue<string> | null,
      borrower?: PromiseOrValue<string> | null,
      underlyingBorrowed?: PromiseOrValue<string> | null,
      amountLiquidated?: null,
      underlyingCollateral?: null,
      amountSeized?: null,
    ): LiquidatedEventFilter;
    Liquidated(
      liquidator?: PromiseOrValue<string> | null,
      borrower?: PromiseOrValue<string> | null,
      underlyingBorrowed?: PromiseOrValue<string> | null,
      amountLiquidated?: null,
      underlyingCollateral?: null,
      amountSeized?: null,
    ): LiquidatedEventFilter;

    'ManagerApproval(address,address,bool)'(
      delegator?: PromiseOrValue<string> | null,
      manager?: PromiseOrValue<string> | null,
      isAllowed?: null,
    ): ManagerApprovalEventFilter;
    ManagerApproval(
      delegator?: PromiseOrValue<string> | null,
      manager?: PromiseOrValue<string> | null,
      isAllowed?: null,
    ): ManagerApprovalEventFilter;

    'MarketCreated(address)'(underlying?: PromiseOrValue<string> | null): MarketCreatedEventFilter;
    MarketCreated(underlying?: PromiseOrValue<string> | null): MarketCreatedEventFilter;

    'P2PBorrowDeltaUpdated(address,uint256)'(
      underlying?: PromiseOrValue<string> | null,
      scaledDelta?: null,
    ): P2PBorrowDeltaUpdatedEventFilter;
    P2PBorrowDeltaUpdated(
      underlying?: PromiseOrValue<string> | null,
      scaledDelta?: null,
    ): P2PBorrowDeltaUpdatedEventFilter;

    'P2PDeltasIncreased(address,uint256)'(
      underlying?: PromiseOrValue<string> | null,
      amount?: null,
    ): P2PDeltasIncreasedEventFilter;
    P2PDeltasIncreased(underlying?: PromiseOrValue<string> | null, amount?: null): P2PDeltasIncreasedEventFilter;

    'P2PIndexCursorSet(address,uint16)'(
      underlying?: PromiseOrValue<string> | null,
      p2pIndexCursor?: null,
    ): P2PIndexCursorSetEventFilter;
    P2PIndexCursorSet(underlying?: PromiseOrValue<string> | null, p2pIndexCursor?: null): P2PIndexCursorSetEventFilter;

    'P2PSupplyDeltaUpdated(address,uint256)'(
      underlying?: PromiseOrValue<string> | null,
      scaledDelta?: null,
    ): P2PSupplyDeltaUpdatedEventFilter;
    P2PSupplyDeltaUpdated(
      underlying?: PromiseOrValue<string> | null,
      scaledDelta?: null,
    ): P2PSupplyDeltaUpdatedEventFilter;

    'P2PTotalsUpdated(address,uint256,uint256)'(
      underlying?: PromiseOrValue<string> | null,
      scaledTotalSupplyP2P?: null,
      scaledTotalBorrowP2P?: null,
    ): P2PTotalsUpdatedEventFilter;
    P2PTotalsUpdated(
      underlying?: PromiseOrValue<string> | null,
      scaledTotalSupplyP2P?: null,
      scaledTotalBorrowP2P?: null,
    ): P2PTotalsUpdatedEventFilter;

    'PositionsManagerSet(address)'(positionsManager?: PromiseOrValue<string> | null): PositionsManagerSetEventFilter;
    PositionsManagerSet(positionsManager?: PromiseOrValue<string> | null): PositionsManagerSetEventFilter;

    'Repaid(address,address,address,uint256,uint256,uint256)'(
      repayer?: PromiseOrValue<string> | null,
      onBehalf?: PromiseOrValue<string> | null,
      underlying?: PromiseOrValue<string> | null,
      amount?: null,
      scaledOnPool?: null,
      scaledInP2P?: null,
    ): RepaidEventFilter;
    Repaid(
      repayer?: PromiseOrValue<string> | null,
      onBehalf?: PromiseOrValue<string> | null,
      underlying?: PromiseOrValue<string> | null,
      amount?: null,
      scaledOnPool?: null,
      scaledInP2P?: null,
    ): RepaidEventFilter;

    'ReserveFactorSet(address,uint16)'(
      underlying?: PromiseOrValue<string> | null,
      reserveFactor?: null,
    ): ReserveFactorSetEventFilter;
    ReserveFactorSet(underlying?: PromiseOrValue<string> | null, reserveFactor?: null): ReserveFactorSetEventFilter;

    'ReserveFeeClaimed(address,uint256)'(
      underlying?: PromiseOrValue<string> | null,
      claimed?: null,
    ): ReserveFeeClaimedEventFilter;
    ReserveFeeClaimed(underlying?: PromiseOrValue<string> | null, claimed?: null): ReserveFeeClaimedEventFilter;

    'RewardsClaimed(address,address,address,uint256)'(
      claimer?: PromiseOrValue<string> | null,
      onBehalf?: PromiseOrValue<string> | null,
      rewardToken?: PromiseOrValue<string> | null,
      amountClaimed?: null,
    ): RewardsClaimedEventFilter;
    RewardsClaimed(
      claimer?: PromiseOrValue<string> | null,
      onBehalf?: PromiseOrValue<string> | null,
      rewardToken?: PromiseOrValue<string> | null,
      amountClaimed?: null,
    ): RewardsClaimedEventFilter;

    'RewardsManagerSet(address)'(rewardsManager?: PromiseOrValue<string> | null): RewardsManagerSetEventFilter;
    RewardsManagerSet(rewardsManager?: PromiseOrValue<string> | null): RewardsManagerSetEventFilter;

    'Supplied(address,address,address,uint256,uint256,uint256)'(
      from?: PromiseOrValue<string> | null,
      onBehalf?: PromiseOrValue<string> | null,
      underlying?: PromiseOrValue<string> | null,
      amount?: null,
      scaledOnPool?: null,
      scaledInP2P?: null,
    ): SuppliedEventFilter;
    Supplied(
      from?: PromiseOrValue<string> | null,
      onBehalf?: PromiseOrValue<string> | null,
      underlying?: PromiseOrValue<string> | null,
      amount?: null,
      scaledOnPool?: null,
      scaledInP2P?: null,
    ): SuppliedEventFilter;

    'SupplyPositionUpdated(address,address,uint256,uint256)'(
      user?: PromiseOrValue<string> | null,
      underlying?: PromiseOrValue<string> | null,
      scaledOnPool?: null,
      scaledInP2P?: null,
    ): SupplyPositionUpdatedEventFilter;
    SupplyPositionUpdated(
      user?: PromiseOrValue<string> | null,
      underlying?: PromiseOrValue<string> | null,
      scaledOnPool?: null,
      scaledInP2P?: null,
    ): SupplyPositionUpdatedEventFilter;

    'TreasuryVaultSet(address)'(treasuryVault?: PromiseOrValue<string> | null): TreasuryVaultSetEventFilter;
    TreasuryVaultSet(treasuryVault?: PromiseOrValue<string> | null): TreasuryVaultSetEventFilter;

    'UserNonceIncremented(address,address,uint256)'(
      caller?: PromiseOrValue<string> | null,
      signatory?: PromiseOrValue<string> | null,
      usedNonce?: null,
    ): UserNonceIncrementedEventFilter;
    UserNonceIncremented(
      caller?: PromiseOrValue<string> | null,
      signatory?: PromiseOrValue<string> | null,
      usedNonce?: null,
    ): UserNonceIncrementedEventFilter;

    'Withdrawn(address,address,address,address,uint256,uint256,uint256)'(
      caller?: null,
      onBehalf?: PromiseOrValue<string> | null,
      receiver?: PromiseOrValue<string> | null,
      underlying?: PromiseOrValue<string> | null,
      amount?: null,
      scaledOnPool?: null,
      scaledInP2P?: null,
    ): WithdrawnEventFilter;
    Withdrawn(
      caller?: null,
      onBehalf?: PromiseOrValue<string> | null,
      receiver?: PromiseOrValue<string> | null,
      underlying?: PromiseOrValue<string> | null,
      amount?: null,
      scaledOnPool?: null,
      scaledInP2P?: null,
    ): WithdrawnEventFilter;
  };

  estimateGas: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber>;

    acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    addressesProvider(overrides?: CallOverrides): Promise<BigNumber>;

    approveManager(
      manager: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    approveManagerWithSig(
      delegator: PromiseOrValue<string>,
      manager: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      nonce: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    borrow(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    borrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    claimRewards(
      assets: PromiseOrValue<string>[],
      onBehalf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    claimToTreasury(
      underlyings: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    collateralBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    createMarket(
      underlying: PromiseOrValue<string>,
      reserveFactor: PromiseOrValue<BigNumberish>,
      p2pIndexCursor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    defaultIterations(overrides?: CallOverrides): Promise<BigNumber>;

    eModeCategoryId(overrides?: CallOverrides): Promise<BigNumber>;

    getBucketsMask(
      underlying: PromiseOrValue<string>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getNext(
      underlying: PromiseOrValue<string>,
      position: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    increaseP2PDeltas(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    initialize(
      addressesProvider: PromiseOrValue<string>,
      eModeCategoryId: PromiseOrValue<BigNumberish>,
      positionsManager: PromiseOrValue<string>,
      defaultIterations: Types.IterationsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    isClaimRewardsPaused(overrides?: CallOverrides): Promise<BigNumber>;

    isManagedBy(
      delegator: PromiseOrValue<string>,
      manager: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    liquidate(
      underlyingBorrowed: PromiseOrValue<string>,
      underlyingCollateral: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    liquidityData(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    market(underlying: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    marketsCreated(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pendingOwner(overrides?: CallOverrides): Promise<BigNumber>;

    pool(overrides?: CallOverrides): Promise<BigNumber>;

    positionsManager(overrides?: CallOverrides): Promise<BigNumber>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    repay(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    repayWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    rewardsManager(overrides?: CallOverrides): Promise<BigNumber>;

    scaledCollateralBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    scaledP2PBorrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    scaledP2PSupplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    scaledPoolBorrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    scaledPoolSupplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    setAssetIsCollateral(
      underlying: PromiseOrValue<string>,
      isCollateral: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setAssetIsCollateralOnPool(
      underlying: PromiseOrValue<string>,
      isCollateral: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setDefaultIterations(
      defaultIterations: Types.IterationsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setIsBorrowPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setIsClaimRewardsPaused(
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setIsDeprecated(
      underlying: PromiseOrValue<string>,
      isDeprecated: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setIsLiquidateBorrowPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setIsLiquidateCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setIsP2PDisabled(
      underlying: PromiseOrValue<string>,
      isP2PDisabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setIsPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setIsPausedForAllMarkets(
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setIsRepayPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setIsSupplyCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setIsSupplyPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setIsWithdrawCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setIsWithdrawPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setP2PIndexCursor(
      underlying: PromiseOrValue<string>,
      p2pIndexCursor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setPositionsManager(
      positionsManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setReserveFactor(
      underlying: PromiseOrValue<string>,
      newReserveFactor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setRewardsManager(
      rewardsManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setTreasuryVault(
      treasuryVault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    supply(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    supplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    supplyCollateral(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    supplyCollateralWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    supplyWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    treasuryVault(overrides?: CallOverrides): Promise<BigNumber>;

    updatedIndexes(underlying: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    userBorrows(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    userCollaterals(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    userNonce(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    withdraw(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    withdrawCollateral(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    addressesProvider(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    approveManager(
      manager: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    approveManagerWithSig(
      delegator: PromiseOrValue<string>,
      manager: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      nonce: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    borrow(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    borrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    claimRewards(
      assets: PromiseOrValue<string>[],
      onBehalf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    claimToTreasury(
      underlyings: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    collateralBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    createMarket(
      underlying: PromiseOrValue<string>,
      reserveFactor: PromiseOrValue<BigNumberish>,
      p2pIndexCursor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    defaultIterations(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    eModeCategoryId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getBucketsMask(
      underlying: PromiseOrValue<string>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getNext(
      underlying: PromiseOrValue<string>,
      position: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    increaseP2PDeltas(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    initialize(
      addressesProvider: PromiseOrValue<string>,
      eModeCategoryId: PromiseOrValue<BigNumberish>,
      positionsManager: PromiseOrValue<string>,
      defaultIterations: Types.IterationsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    isClaimRewardsPaused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isManagedBy(
      delegator: PromiseOrValue<string>,
      manager: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    liquidate(
      underlyingBorrowed: PromiseOrValue<string>,
      underlyingCollateral: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    liquidityData(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    market(underlying: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    marketsCreated(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pool(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    positionsManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    repay(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    repayWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    rewardsManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    scaledCollateralBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    scaledP2PBorrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    scaledP2PSupplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    scaledPoolBorrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    scaledPoolSupplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    setAssetIsCollateral(
      underlying: PromiseOrValue<string>,
      isCollateral: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setAssetIsCollateralOnPool(
      underlying: PromiseOrValue<string>,
      isCollateral: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setDefaultIterations(
      defaultIterations: Types.IterationsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setIsBorrowPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setIsClaimRewardsPaused(
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setIsDeprecated(
      underlying: PromiseOrValue<string>,
      isDeprecated: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setIsLiquidateBorrowPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setIsLiquidateCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setIsP2PDisabled(
      underlying: PromiseOrValue<string>,
      isP2PDisabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setIsPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setIsPausedForAllMarkets(
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setIsRepayPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setIsSupplyCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setIsSupplyPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setIsWithdrawCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setIsWithdrawPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setP2PIndexCursor(
      underlying: PromiseOrValue<string>,
      p2pIndexCursor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setPositionsManager(
      positionsManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setReserveFactor(
      underlying: PromiseOrValue<string>,
      newReserveFactor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setRewardsManager(
      rewardsManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setTreasuryVault(
      treasuryVault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    supply(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    supplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    supplyCollateral(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    supplyCollateralWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    supplyWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    treasuryVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    updatedIndexes(underlying: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    userBorrows(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    userCollaterals(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    userNonce(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdraw(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    withdrawCollateral(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;
  };
}

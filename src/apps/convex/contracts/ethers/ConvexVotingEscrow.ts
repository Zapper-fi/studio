/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export declare namespace CvxLocker {
  export type EarnedDataStruct = {
    token: PromiseOrValue<string>;
    amount: PromiseOrValue<BigNumberish>;
  };

  export type EarnedDataStructOutput = [string, BigNumber] & {
    token: string;
    amount: BigNumber;
  };

  export type LockedBalanceStruct = {
    amount: PromiseOrValue<BigNumberish>;
    boosted: PromiseOrValue<BigNumberish>;
    unlockTime: PromiseOrValue<BigNumberish>;
  };

  export type LockedBalanceStructOutput = [BigNumber, BigNumber, number] & {
    amount: BigNumber;
    boosted: BigNumber;
    unlockTime: number;
  };
}

export interface ConvexVotingEscrowInterface extends utils.Interface {
  functions: {
    'addReward(address,address,bool)': FunctionFragment;
    'approveRewardDistributor(address,address,bool)': FunctionFragment;
    'balanceAtEpochOf(uint256,address)': FunctionFragment;
    'balanceOf(address)': FunctionFragment;
    'balances(address)': FunctionFragment;
    'boostPayment()': FunctionFragment;
    'boostRate()': FunctionFragment;
    'boostedSupply()': FunctionFragment;
    'checkpointEpoch()': FunctionFragment;
    'claimableRewards(address)': FunctionFragment;
    'cvxCrv()': FunctionFragment;
    'cvxcrvStaking()': FunctionFragment;
    'decimals()': FunctionFragment;
    'denominator()': FunctionFragment;
    'epochCount()': FunctionFragment;
    'epochs(uint256)': FunctionFragment;
    'findEpochId(uint256)': FunctionFragment;
    'getReward(address,bool)': FunctionFragment;
    'getReward(address)': FunctionFragment;
    'getRewardForDuration(address)': FunctionFragment;
    'isShutdown()': FunctionFragment;
    'kickExpiredLocks(address)': FunctionFragment;
    'kickRewardEpochDelay()': FunctionFragment;
    'kickRewardPerEpoch()': FunctionFragment;
    'lastTimeRewardApplicable(address)': FunctionFragment;
    'lock(address,uint256,uint256)': FunctionFragment;
    'lockDuration()': FunctionFragment;
    'lockedBalanceOf(address)': FunctionFragment;
    'lockedBalances(address)': FunctionFragment;
    'lockedSupply()': FunctionFragment;
    'maximumBoostPayment()': FunctionFragment;
    'maximumStake()': FunctionFragment;
    'minimumStake()': FunctionFragment;
    'name()': FunctionFragment;
    'nextBoostRate()': FunctionFragment;
    'nextMaximumBoostPayment()': FunctionFragment;
    'notifyRewardAmount(address,uint256)': FunctionFragment;
    'owner()': FunctionFragment;
    'processExpiredLocks(bool)': FunctionFragment;
    'processExpiredLocks(bool,uint256,address)': FunctionFragment;
    'recoverERC20(address,uint256)': FunctionFragment;
    'renounceOwnership()': FunctionFragment;
    'rewardData(address)': FunctionFragment;
    'rewardDistributors(address,address)': FunctionFragment;
    'rewardPerToken(address)': FunctionFragment;
    'rewardTokens(uint256)': FunctionFragment;
    'rewardWeightOf(address)': FunctionFragment;
    'rewards(address,address)': FunctionFragment;
    'rewardsDuration()': FunctionFragment;
    'setApprovals()': FunctionFragment;
    'setBoost(uint256,uint256,address)': FunctionFragment;
    'setKickIncentive(uint256,uint256)': FunctionFragment;
    'setStakeLimits(uint256,uint256)': FunctionFragment;
    'setStakingContract(address)': FunctionFragment;
    'shutdown()': FunctionFragment;
    'stakeOffsetOnLock()': FunctionFragment;
    'stakingProxy()': FunctionFragment;
    'stakingToken()': FunctionFragment;
    'symbol()': FunctionFragment;
    'totalSupply()': FunctionFragment;
    'totalSupplyAtEpoch(uint256)': FunctionFragment;
    'transferOwnership(address)': FunctionFragment;
    'userLocks(address,uint256)': FunctionFragment;
    'userRewardPerTokenPaid(address,address)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'addReward'
      | 'approveRewardDistributor'
      | 'balanceAtEpochOf'
      | 'balanceOf'
      | 'balances'
      | 'boostPayment'
      | 'boostRate'
      | 'boostedSupply'
      | 'checkpointEpoch'
      | 'claimableRewards'
      | 'cvxCrv'
      | 'cvxcrvStaking'
      | 'decimals'
      | 'denominator'
      | 'epochCount'
      | 'epochs'
      | 'findEpochId'
      | 'getReward(address,bool)'
      | 'getReward(address)'
      | 'getRewardForDuration'
      | 'isShutdown'
      | 'kickExpiredLocks'
      | 'kickRewardEpochDelay'
      | 'kickRewardPerEpoch'
      | 'lastTimeRewardApplicable'
      | 'lock'
      | 'lockDuration'
      | 'lockedBalanceOf'
      | 'lockedBalances'
      | 'lockedSupply'
      | 'maximumBoostPayment'
      | 'maximumStake'
      | 'minimumStake'
      | 'name'
      | 'nextBoostRate'
      | 'nextMaximumBoostPayment'
      | 'notifyRewardAmount'
      | 'owner'
      | 'processExpiredLocks(bool)'
      | 'processExpiredLocks(bool,uint256,address)'
      | 'recoverERC20'
      | 'renounceOwnership'
      | 'rewardData'
      | 'rewardDistributors'
      | 'rewardPerToken'
      | 'rewardTokens'
      | 'rewardWeightOf'
      | 'rewards'
      | 'rewardsDuration'
      | 'setApprovals'
      | 'setBoost'
      | 'setKickIncentive'
      | 'setStakeLimits'
      | 'setStakingContract'
      | 'shutdown'
      | 'stakeOffsetOnLock'
      | 'stakingProxy'
      | 'stakingToken'
      | 'symbol'
      | 'totalSupply'
      | 'totalSupplyAtEpoch'
      | 'transferOwnership'
      | 'userLocks'
      | 'userRewardPerTokenPaid',
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: 'addReward',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'approveRewardDistributor',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'balanceAtEpochOf',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'balanceOf', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'balances', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'boostPayment', values?: undefined): string;
  encodeFunctionData(functionFragment: 'boostRate', values?: undefined): string;
  encodeFunctionData(functionFragment: 'boostedSupply', values?: undefined): string;
  encodeFunctionData(functionFragment: 'checkpointEpoch', values?: undefined): string;
  encodeFunctionData(functionFragment: 'claimableRewards', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'cvxCrv', values?: undefined): string;
  encodeFunctionData(functionFragment: 'cvxcrvStaking', values?: undefined): string;
  encodeFunctionData(functionFragment: 'decimals', values?: undefined): string;
  encodeFunctionData(functionFragment: 'denominator', values?: undefined): string;
  encodeFunctionData(functionFragment: 'epochCount', values?: undefined): string;
  encodeFunctionData(functionFragment: 'epochs', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'findEpochId', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'getReward(address,bool)',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'getReward(address)', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getRewardForDuration', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'isShutdown', values?: undefined): string;
  encodeFunctionData(functionFragment: 'kickExpiredLocks', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'kickRewardEpochDelay', values?: undefined): string;
  encodeFunctionData(functionFragment: 'kickRewardPerEpoch', values?: undefined): string;
  encodeFunctionData(functionFragment: 'lastTimeRewardApplicable', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'lock',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'lockDuration', values?: undefined): string;
  encodeFunctionData(functionFragment: 'lockedBalanceOf', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'lockedBalances', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'lockedSupply', values?: undefined): string;
  encodeFunctionData(functionFragment: 'maximumBoostPayment', values?: undefined): string;
  encodeFunctionData(functionFragment: 'maximumStake', values?: undefined): string;
  encodeFunctionData(functionFragment: 'minimumStake', values?: undefined): string;
  encodeFunctionData(functionFragment: 'name', values?: undefined): string;
  encodeFunctionData(functionFragment: 'nextBoostRate', values?: undefined): string;
  encodeFunctionData(functionFragment: 'nextMaximumBoostPayment', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'notifyRewardAmount',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'processExpiredLocks(bool)', values: [PromiseOrValue<boolean>]): string;
  encodeFunctionData(
    functionFragment: 'processExpiredLocks(bool,uint256,address)',
    values: [PromiseOrValue<boolean>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'recoverERC20',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'rewardData', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'rewardDistributors',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'rewardPerToken', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'rewardTokens', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'rewardWeightOf', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'rewards', values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'rewardsDuration', values?: undefined): string;
  encodeFunctionData(functionFragment: 'setApprovals', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'setBoost',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setKickIncentive',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setStakeLimits',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'setStakingContract', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'shutdown', values?: undefined): string;
  encodeFunctionData(functionFragment: 'stakeOffsetOnLock', values?: undefined): string;
  encodeFunctionData(functionFragment: 'stakingProxy', values?: undefined): string;
  encodeFunctionData(functionFragment: 'stakingToken', values?: undefined): string;
  encodeFunctionData(functionFragment: 'symbol', values?: undefined): string;
  encodeFunctionData(functionFragment: 'totalSupply', values?: undefined): string;
  encodeFunctionData(functionFragment: 'totalSupplyAtEpoch', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'transferOwnership', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'userLocks',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'userRewardPerTokenPaid',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;

  decodeFunctionResult(functionFragment: 'addReward', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'approveRewardDistributor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balanceAtEpochOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balances', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'boostPayment', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'boostRate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'boostedSupply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'checkpointEpoch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimableRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cvxCrv', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cvxcrvStaking', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'decimals', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'denominator', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'epochCount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'epochs', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'findEpochId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReward(address,bool)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReward(address)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getRewardForDuration', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isShutdown', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'kickExpiredLocks', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'kickRewardEpochDelay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'kickRewardPerEpoch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lastTimeRewardApplicable', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lock', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lockDuration', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lockedBalanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lockedBalances', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lockedSupply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'maximumBoostPayment', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'maximumStake', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'minimumStake', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'name', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nextBoostRate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nextMaximumBoostPayment', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'notifyRewardAmount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'processExpiredLocks(bool)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'processExpiredLocks(bool,uint256,address)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'recoverERC20', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardDistributors', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardPerToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardWeightOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardsDuration', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setApprovals', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setBoost', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setKickIncentive', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setStakeLimits', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setStakingContract', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'shutdown', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stakeOffsetOnLock', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stakingProxy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stakingToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'symbol', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalSupply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalSupplyAtEpoch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userLocks', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userRewardPerTokenPaid', data: BytesLike): Result;

  events: {
    'KickReward(address,address,uint256)': EventFragment;
    'OwnershipTransferred(address,address)': EventFragment;
    'Recovered(address,uint256)': EventFragment;
    'RewardAdded(address,uint256)': EventFragment;
    'RewardPaid(address,address,uint256)': EventFragment;
    'Staked(address,uint256,uint256,uint256)': EventFragment;
    'Withdrawn(address,uint256,bool)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'KickReward'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Recovered'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardAdded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardPaid'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Staked'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Withdrawn'): EventFragment;
}

export interface KickRewardEventObject {
  _user: string;
  _kicked: string;
  _reward: BigNumber;
}
export type KickRewardEvent = TypedEvent<[string, string, BigNumber], KickRewardEventObject>;

export type KickRewardEventFilter = TypedEventFilter<KickRewardEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<[string, string], OwnershipTransferredEventObject>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export interface RecoveredEventObject {
  _token: string;
  _amount: BigNumber;
}
export type RecoveredEvent = TypedEvent<[string, BigNumber], RecoveredEventObject>;

export type RecoveredEventFilter = TypedEventFilter<RecoveredEvent>;

export interface RewardAddedEventObject {
  _token: string;
  _reward: BigNumber;
}
export type RewardAddedEvent = TypedEvent<[string, BigNumber], RewardAddedEventObject>;

export type RewardAddedEventFilter = TypedEventFilter<RewardAddedEvent>;

export interface RewardPaidEventObject {
  _user: string;
  _rewardsToken: string;
  _reward: BigNumber;
}
export type RewardPaidEvent = TypedEvent<[string, string, BigNumber], RewardPaidEventObject>;

export type RewardPaidEventFilter = TypedEventFilter<RewardPaidEvent>;

export interface StakedEventObject {
  _user: string;
  _paidAmount: BigNumber;
  _lockedAmount: BigNumber;
  _boostedAmount: BigNumber;
}
export type StakedEvent = TypedEvent<[string, BigNumber, BigNumber, BigNumber], StakedEventObject>;

export type StakedEventFilter = TypedEventFilter<StakedEvent>;

export interface WithdrawnEventObject {
  _user: string;
  _amount: BigNumber;
  _relocked: boolean;
}
export type WithdrawnEvent = TypedEvent<[string, BigNumber, boolean], WithdrawnEventObject>;

export type WithdrawnEventFilter = TypedEventFilter<WithdrawnEvent>;

export interface ConvexVotingEscrow extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ConvexVotingEscrowInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    addReward(
      _rewardsToken: PromiseOrValue<string>,
      _distributor: PromiseOrValue<string>,
      _useBoost: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    approveRewardDistributor(
      _rewardsToken: PromiseOrValue<string>,
      _distributor: PromiseOrValue<string>,
      _approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    balanceAtEpochOf(
      _epoch: PromiseOrValue<BigNumberish>,
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { amount: BigNumber }>;

    balanceOf(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber] & { amount: BigNumber }>;

    balances(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, number] & {
        locked: BigNumber;
        boosted: BigNumber;
        nextUnlockIndex: number;
      }
    >;

    boostPayment(overrides?: CallOverrides): Promise<[string]>;

    boostRate(overrides?: CallOverrides): Promise<[BigNumber]>;

    boostedSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    checkpointEpoch(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    claimableRewards(
      _account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [CvxLocker.EarnedDataStructOutput[]] & {
        userRewards: CvxLocker.EarnedDataStructOutput[];
      }
    >;

    cvxCrv(overrides?: CallOverrides): Promise<[string]>;

    cvxcrvStaking(overrides?: CallOverrides): Promise<[string]>;

    decimals(overrides?: CallOverrides): Promise<[number]>;

    denominator(overrides?: CallOverrides): Promise<[BigNumber]>;

    epochCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    epochs(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, number] & { supply: BigNumber; date: number }>;

    findEpochId(
      _time: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { epoch: BigNumber }>;

    'getReward(address,bool)'(
      _account: PromiseOrValue<string>,
      _stake: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'getReward(address)'(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    getRewardForDuration(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    isShutdown(overrides?: CallOverrides): Promise<[boolean]>;

    kickExpiredLocks(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    kickRewardEpochDelay(overrides?: CallOverrides): Promise<[BigNumber]>;

    kickRewardPerEpoch(overrides?: CallOverrides): Promise<[BigNumber]>;

    lastTimeRewardApplicable(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    lock(
      _account: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _spendRatio: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    lockDuration(overrides?: CallOverrides): Promise<[BigNumber]>;

    lockedBalanceOf(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { amount: BigNumber }>;

    lockedBalances(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, CvxLocker.LockedBalanceStructOutput[]] & {
        total: BigNumber;
        unlockable: BigNumber;
        locked: BigNumber;
        lockData: CvxLocker.LockedBalanceStructOutput[];
      }
    >;

    lockedSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    maximumBoostPayment(overrides?: CallOverrides): Promise<[BigNumber]>;

    maximumStake(overrides?: CallOverrides): Promise<[BigNumber]>;

    minimumStake(overrides?: CallOverrides): Promise<[BigNumber]>;

    name(overrides?: CallOverrides): Promise<[string]>;

    nextBoostRate(overrides?: CallOverrides): Promise<[BigNumber]>;

    nextMaximumBoostPayment(overrides?: CallOverrides): Promise<[BigNumber]>;

    notifyRewardAmount(
      _rewardsToken: PromiseOrValue<string>,
      _reward: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    'processExpiredLocks(bool)'(
      _relock: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'processExpiredLocks(bool,uint256,address)'(
      _relock: PromiseOrValue<boolean>,
      _spendRatio: PromiseOrValue<BigNumberish>,
      _withdrawTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    recoverERC20(
      _tokenAddress: PromiseOrValue<string>,
      _tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    rewardData(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [boolean, number, BigNumber, number, BigNumber] & {
        useBoost: boolean;
        periodFinish: number;
        rewardRate: BigNumber;
        lastUpdateTime: number;
        rewardPerTokenStored: BigNumber;
      }
    >;

    rewardDistributors(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    rewardPerToken(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    rewardTokens(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    rewardWeightOf(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { amount: BigNumber }>;

    rewards(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    rewardsDuration(overrides?: CallOverrides): Promise<[BigNumber]>;

    setApprovals(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    setBoost(
      _max: PromiseOrValue<BigNumberish>,
      _rate: PromiseOrValue<BigNumberish>,
      _receivingAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setKickIncentive(
      _rate: PromiseOrValue<BigNumberish>,
      _delay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setStakeLimits(
      _minimum: PromiseOrValue<BigNumberish>,
      _maximum: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setStakingContract(
      _staking: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    shutdown(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    stakeOffsetOnLock(overrides?: CallOverrides): Promise<[BigNumber]>;

    stakingProxy(overrides?: CallOverrides): Promise<[string]>;

    stakingToken(overrides?: CallOverrides): Promise<[string]>;

    symbol(overrides?: CallOverrides): Promise<[string]>;

    totalSupply(overrides?: CallOverrides): Promise<[BigNumber] & { supply: BigNumber }>;

    totalSupplyAtEpoch(
      _epoch: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { supply: BigNumber }>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    userLocks(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, number] & {
        amount: BigNumber;
        boosted: BigNumber;
        unlockTime: number;
      }
    >;

    userRewardPerTokenPaid(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;
  };

  addReward(
    _rewardsToken: PromiseOrValue<string>,
    _distributor: PromiseOrValue<string>,
    _useBoost: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  approveRewardDistributor(
    _rewardsToken: PromiseOrValue<string>,
    _distributor: PromiseOrValue<string>,
    _approved: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  balanceAtEpochOf(
    _epoch: PromiseOrValue<BigNumberish>,
    _user: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  balanceOf(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  balances(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, number] & {
      locked: BigNumber;
      boosted: BigNumber;
      nextUnlockIndex: number;
    }
  >;

  boostPayment(overrides?: CallOverrides): Promise<string>;

  boostRate(overrides?: CallOverrides): Promise<BigNumber>;

  boostedSupply(overrides?: CallOverrides): Promise<BigNumber>;

  checkpointEpoch(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  claimableRewards(
    _account: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<CvxLocker.EarnedDataStructOutput[]>;

  cvxCrv(overrides?: CallOverrides): Promise<string>;

  cvxcrvStaking(overrides?: CallOverrides): Promise<string>;

  decimals(overrides?: CallOverrides): Promise<number>;

  denominator(overrides?: CallOverrides): Promise<BigNumber>;

  epochCount(overrides?: CallOverrides): Promise<BigNumber>;

  epochs(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, number] & { supply: BigNumber; date: number }>;

  findEpochId(_time: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  'getReward(address,bool)'(
    _account: PromiseOrValue<string>,
    _stake: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'getReward(address)'(
    _account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  getRewardForDuration(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  isShutdown(overrides?: CallOverrides): Promise<boolean>;

  kickExpiredLocks(
    _account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  kickRewardEpochDelay(overrides?: CallOverrides): Promise<BigNumber>;

  kickRewardPerEpoch(overrides?: CallOverrides): Promise<BigNumber>;

  lastTimeRewardApplicable(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  lock(
    _account: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    _spendRatio: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  lockDuration(overrides?: CallOverrides): Promise<BigNumber>;

  lockedBalanceOf(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  lockedBalances(
    _user: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber, CvxLocker.LockedBalanceStructOutput[]] & {
      total: BigNumber;
      unlockable: BigNumber;
      locked: BigNumber;
      lockData: CvxLocker.LockedBalanceStructOutput[];
    }
  >;

  lockedSupply(overrides?: CallOverrides): Promise<BigNumber>;

  maximumBoostPayment(overrides?: CallOverrides): Promise<BigNumber>;

  maximumStake(overrides?: CallOverrides): Promise<BigNumber>;

  minimumStake(overrides?: CallOverrides): Promise<BigNumber>;

  name(overrides?: CallOverrides): Promise<string>;

  nextBoostRate(overrides?: CallOverrides): Promise<BigNumber>;

  nextMaximumBoostPayment(overrides?: CallOverrides): Promise<BigNumber>;

  notifyRewardAmount(
    _rewardsToken: PromiseOrValue<string>,
    _reward: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  'processExpiredLocks(bool)'(
    _relock: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'processExpiredLocks(bool,uint256,address)'(
    _relock: PromiseOrValue<boolean>,
    _spendRatio: PromiseOrValue<BigNumberish>,
    _withdrawTo: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  recoverERC20(
    _tokenAddress: PromiseOrValue<string>,
    _tokenAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  rewardData(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [boolean, number, BigNumber, number, BigNumber] & {
      useBoost: boolean;
      periodFinish: number;
      rewardRate: BigNumber;
      lastUpdateTime: number;
      rewardPerTokenStored: BigNumber;
    }
  >;

  rewardDistributors(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  rewardPerToken(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  rewardTokens(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  rewardWeightOf(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  rewards(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  rewardsDuration(overrides?: CallOverrides): Promise<BigNumber>;

  setApprovals(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  setBoost(
    _max: PromiseOrValue<BigNumberish>,
    _rate: PromiseOrValue<BigNumberish>,
    _receivingAddress: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setKickIncentive(
    _rate: PromiseOrValue<BigNumberish>,
    _delay: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setStakeLimits(
    _minimum: PromiseOrValue<BigNumberish>,
    _maximum: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setStakingContract(
    _staking: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  shutdown(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  stakeOffsetOnLock(overrides?: CallOverrides): Promise<BigNumber>;

  stakingProxy(overrides?: CallOverrides): Promise<string>;

  stakingToken(overrides?: CallOverrides): Promise<string>;

  symbol(overrides?: CallOverrides): Promise<string>;

  totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  totalSupplyAtEpoch(_epoch: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  userLocks(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, number] & {
      amount: BigNumber;
      boosted: BigNumber;
      unlockTime: number;
    }
  >;

  userRewardPerTokenPaid(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  callStatic: {
    addReward(
      _rewardsToken: PromiseOrValue<string>,
      _distributor: PromiseOrValue<string>,
      _useBoost: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    approveRewardDistributor(
      _rewardsToken: PromiseOrValue<string>,
      _distributor: PromiseOrValue<string>,
      _approved: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    balanceAtEpochOf(
      _epoch: PromiseOrValue<BigNumberish>,
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    balanceOf(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    balances(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, number] & {
        locked: BigNumber;
        boosted: BigNumber;
        nextUnlockIndex: number;
      }
    >;

    boostPayment(overrides?: CallOverrides): Promise<string>;

    boostRate(overrides?: CallOverrides): Promise<BigNumber>;

    boostedSupply(overrides?: CallOverrides): Promise<BigNumber>;

    checkpointEpoch(overrides?: CallOverrides): Promise<void>;

    claimableRewards(
      _account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<CvxLocker.EarnedDataStructOutput[]>;

    cvxCrv(overrides?: CallOverrides): Promise<string>;

    cvxcrvStaking(overrides?: CallOverrides): Promise<string>;

    decimals(overrides?: CallOverrides): Promise<number>;

    denominator(overrides?: CallOverrides): Promise<BigNumber>;

    epochCount(overrides?: CallOverrides): Promise<BigNumber>;

    epochs(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, number] & { supply: BigNumber; date: number }>;

    findEpochId(_time: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    'getReward(address,bool)'(
      _account: PromiseOrValue<string>,
      _stake: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    'getReward(address)'(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    getRewardForDuration(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    isShutdown(overrides?: CallOverrides): Promise<boolean>;

    kickExpiredLocks(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    kickRewardEpochDelay(overrides?: CallOverrides): Promise<BigNumber>;

    kickRewardPerEpoch(overrides?: CallOverrides): Promise<BigNumber>;

    lastTimeRewardApplicable(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    lock(
      _account: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _spendRatio: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    lockDuration(overrides?: CallOverrides): Promise<BigNumber>;

    lockedBalanceOf(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    lockedBalances(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, CvxLocker.LockedBalanceStructOutput[]] & {
        total: BigNumber;
        unlockable: BigNumber;
        locked: BigNumber;
        lockData: CvxLocker.LockedBalanceStructOutput[];
      }
    >;

    lockedSupply(overrides?: CallOverrides): Promise<BigNumber>;

    maximumBoostPayment(overrides?: CallOverrides): Promise<BigNumber>;

    maximumStake(overrides?: CallOverrides): Promise<BigNumber>;

    minimumStake(overrides?: CallOverrides): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<string>;

    nextBoostRate(overrides?: CallOverrides): Promise<BigNumber>;

    nextMaximumBoostPayment(overrides?: CallOverrides): Promise<BigNumber>;

    notifyRewardAmount(
      _rewardsToken: PromiseOrValue<string>,
      _reward: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    owner(overrides?: CallOverrides): Promise<string>;

    'processExpiredLocks(bool)'(_relock: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;

    'processExpiredLocks(bool,uint256,address)'(
      _relock: PromiseOrValue<boolean>,
      _spendRatio: PromiseOrValue<BigNumberish>,
      _withdrawTo: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    recoverERC20(
      _tokenAddress: PromiseOrValue<string>,
      _tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    rewardData(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [boolean, number, BigNumber, number, BigNumber] & {
        useBoost: boolean;
        periodFinish: number;
        rewardRate: BigNumber;
        lastUpdateTime: number;
        rewardPerTokenStored: BigNumber;
      }
    >;

    rewardDistributors(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    rewardPerToken(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    rewardTokens(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    rewardWeightOf(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    rewards(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    rewardsDuration(overrides?: CallOverrides): Promise<BigNumber>;

    setApprovals(overrides?: CallOverrides): Promise<void>;

    setBoost(
      _max: PromiseOrValue<BigNumberish>,
      _rate: PromiseOrValue<BigNumberish>,
      _receivingAddress: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setKickIncentive(
      _rate: PromiseOrValue<BigNumberish>,
      _delay: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setStakeLimits(
      _minimum: PromiseOrValue<BigNumberish>,
      _maximum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setStakingContract(_staking: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    shutdown(overrides?: CallOverrides): Promise<void>;

    stakeOffsetOnLock(overrides?: CallOverrides): Promise<BigNumber>;

    stakingProxy(overrides?: CallOverrides): Promise<string>;

    stakingToken(overrides?: CallOverrides): Promise<string>;

    symbol(overrides?: CallOverrides): Promise<string>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    totalSupplyAtEpoch(_epoch: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(newOwner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    userLocks(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, number] & {
        amount: BigNumber;
        boosted: BigNumber;
        unlockTime: number;
      }
    >;

    userRewardPerTokenPaid(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;
  };

  filters: {
    'KickReward(address,address,uint256)'(
      _user?: PromiseOrValue<string> | null,
      _kicked?: PromiseOrValue<string> | null,
      _reward?: null,
    ): KickRewardEventFilter;
    KickReward(
      _user?: PromiseOrValue<string> | null,
      _kicked?: PromiseOrValue<string> | null,
      _reward?: null,
    ): KickRewardEventFilter;

    'OwnershipTransferred(address,address)'(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;

    'Recovered(address,uint256)'(_token?: null, _amount?: null): RecoveredEventFilter;
    Recovered(_token?: null, _amount?: null): RecoveredEventFilter;

    'RewardAdded(address,uint256)'(_token?: PromiseOrValue<string> | null, _reward?: null): RewardAddedEventFilter;
    RewardAdded(_token?: PromiseOrValue<string> | null, _reward?: null): RewardAddedEventFilter;

    'RewardPaid(address,address,uint256)'(
      _user?: PromiseOrValue<string> | null,
      _rewardsToken?: PromiseOrValue<string> | null,
      _reward?: null,
    ): RewardPaidEventFilter;
    RewardPaid(
      _user?: PromiseOrValue<string> | null,
      _rewardsToken?: PromiseOrValue<string> | null,
      _reward?: null,
    ): RewardPaidEventFilter;

    'Staked(address,uint256,uint256,uint256)'(
      _user?: PromiseOrValue<string> | null,
      _paidAmount?: null,
      _lockedAmount?: null,
      _boostedAmount?: null,
    ): StakedEventFilter;
    Staked(
      _user?: PromiseOrValue<string> | null,
      _paidAmount?: null,
      _lockedAmount?: null,
      _boostedAmount?: null,
    ): StakedEventFilter;

    'Withdrawn(address,uint256,bool)'(
      _user?: PromiseOrValue<string> | null,
      _amount?: null,
      _relocked?: null,
    ): WithdrawnEventFilter;
    Withdrawn(_user?: PromiseOrValue<string> | null, _amount?: null, _relocked?: null): WithdrawnEventFilter;
  };

  estimateGas: {
    addReward(
      _rewardsToken: PromiseOrValue<string>,
      _distributor: PromiseOrValue<string>,
      _useBoost: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    approveRewardDistributor(
      _rewardsToken: PromiseOrValue<string>,
      _distributor: PromiseOrValue<string>,
      _approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    balanceAtEpochOf(
      _epoch: PromiseOrValue<BigNumberish>,
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    balanceOf(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    balances(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    boostPayment(overrides?: CallOverrides): Promise<BigNumber>;

    boostRate(overrides?: CallOverrides): Promise<BigNumber>;

    boostedSupply(overrides?: CallOverrides): Promise<BigNumber>;

    checkpointEpoch(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    claimableRewards(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    cvxCrv(overrides?: CallOverrides): Promise<BigNumber>;

    cvxcrvStaking(overrides?: CallOverrides): Promise<BigNumber>;

    decimals(overrides?: CallOverrides): Promise<BigNumber>;

    denominator(overrides?: CallOverrides): Promise<BigNumber>;

    epochCount(overrides?: CallOverrides): Promise<BigNumber>;

    epochs(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    findEpochId(_time: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    'getReward(address,bool)'(
      _account: PromiseOrValue<string>,
      _stake: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'getReward(address)'(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    getRewardForDuration(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    isShutdown(overrides?: CallOverrides): Promise<BigNumber>;

    kickExpiredLocks(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    kickRewardEpochDelay(overrides?: CallOverrides): Promise<BigNumber>;

    kickRewardPerEpoch(overrides?: CallOverrides): Promise<BigNumber>;

    lastTimeRewardApplicable(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    lock(
      _account: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _spendRatio: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    lockDuration(overrides?: CallOverrides): Promise<BigNumber>;

    lockedBalanceOf(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    lockedBalances(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    lockedSupply(overrides?: CallOverrides): Promise<BigNumber>;

    maximumBoostPayment(overrides?: CallOverrides): Promise<BigNumber>;

    maximumStake(overrides?: CallOverrides): Promise<BigNumber>;

    minimumStake(overrides?: CallOverrides): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    nextBoostRate(overrides?: CallOverrides): Promise<BigNumber>;

    nextMaximumBoostPayment(overrides?: CallOverrides): Promise<BigNumber>;

    notifyRewardAmount(
      _rewardsToken: PromiseOrValue<string>,
      _reward: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    'processExpiredLocks(bool)'(
      _relock: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'processExpiredLocks(bool,uint256,address)'(
      _relock: PromiseOrValue<boolean>,
      _spendRatio: PromiseOrValue<BigNumberish>,
      _withdrawTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    recoverERC20(
      _tokenAddress: PromiseOrValue<string>,
      _tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    rewardData(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    rewardDistributors(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    rewardPerToken(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    rewardTokens(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    rewardWeightOf(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    rewards(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    rewardsDuration(overrides?: CallOverrides): Promise<BigNumber>;

    setApprovals(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    setBoost(
      _max: PromiseOrValue<BigNumberish>,
      _rate: PromiseOrValue<BigNumberish>,
      _receivingAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setKickIncentive(
      _rate: PromiseOrValue<BigNumberish>,
      _delay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setStakeLimits(
      _minimum: PromiseOrValue<BigNumberish>,
      _maximum: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setStakingContract(
      _staking: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    shutdown(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    stakeOffsetOnLock(overrides?: CallOverrides): Promise<BigNumber>;

    stakingProxy(overrides?: CallOverrides): Promise<BigNumber>;

    stakingToken(overrides?: CallOverrides): Promise<BigNumber>;

    symbol(overrides?: CallOverrides): Promise<BigNumber>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    totalSupplyAtEpoch(_epoch: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    userLocks(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    userRewardPerTokenPaid(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    addReward(
      _rewardsToken: PromiseOrValue<string>,
      _distributor: PromiseOrValue<string>,
      _useBoost: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    approveRewardDistributor(
      _rewardsToken: PromiseOrValue<string>,
      _distributor: PromiseOrValue<string>,
      _approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    balanceAtEpochOf(
      _epoch: PromiseOrValue<BigNumberish>,
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    balanceOf(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    balances(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    boostPayment(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    boostRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    boostedSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    checkpointEpoch(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    claimableRewards(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    cvxCrv(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    cvxcrvStaking(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    denominator(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    epochCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    epochs(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    findEpochId(_time: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'getReward(address,bool)'(
      _account: PromiseOrValue<string>,
      _stake: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'getReward(address)'(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    getRewardForDuration(
      _rewardsToken: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    isShutdown(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    kickExpiredLocks(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    kickRewardEpochDelay(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    kickRewardPerEpoch(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastTimeRewardApplicable(
      _rewardsToken: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    lock(
      _account: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _spendRatio: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    lockDuration(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lockedBalanceOf(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lockedBalances(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lockedSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    maximumBoostPayment(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    maximumStake(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minimumStake(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nextBoostRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nextMaximumBoostPayment(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    notifyRewardAmount(
      _rewardsToken: PromiseOrValue<string>,
      _reward: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'processExpiredLocks(bool)'(
      _relock: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'processExpiredLocks(bool,uint256,address)'(
      _relock: PromiseOrValue<boolean>,
      _spendRatio: PromiseOrValue<BigNumberish>,
      _withdrawTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    recoverERC20(
      _tokenAddress: PromiseOrValue<string>,
      _tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    rewardData(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardDistributors(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    rewardPerToken(_rewardsToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardTokens(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardWeightOf(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewards(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    rewardsDuration(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setApprovals(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    setBoost(
      _max: PromiseOrValue<BigNumberish>,
      _rate: PromiseOrValue<BigNumberish>,
      _receivingAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setKickIncentive(
      _rate: PromiseOrValue<BigNumberish>,
      _delay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setStakeLimits(
      _minimum: PromiseOrValue<BigNumberish>,
      _maximum: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setStakingContract(
      _staking: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    shutdown(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    stakeOffsetOnLock(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    stakingProxy(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    stakingToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalSupplyAtEpoch(_epoch: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    userLocks(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    userRewardPerTokenPaid(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;
  };
}

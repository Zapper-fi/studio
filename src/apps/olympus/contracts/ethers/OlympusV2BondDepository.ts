/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export interface OlympusV2BondDepositoryInterface extends utils.Interface {
  functions: {
    'adjustments(uint256)': FunctionFragment;
    'authority()': FunctionFragment;
    'close(uint256)': FunctionFragment;
    'create(address,uint256[3],bool[2],uint256[2],uint32[2])': FunctionFragment;
    'currentControlVariable(uint256)': FunctionFragment;
    'currentDebt(uint256)': FunctionFragment;
    'daoReward()': FunctionFragment;
    'debtDecay(uint256)': FunctionFragment;
    'debtRatio(uint256)': FunctionFragment;
    'deposit(uint256,uint256,uint256,address,address)': FunctionFragment;
    'getReward()': FunctionFragment;
    'indexesFor(address)': FunctionFragment;
    'isLive(uint256)': FunctionFragment;
    'liveMarkets()': FunctionFragment;
    'liveMarketsFor(address)': FunctionFragment;
    'marketPrice(uint256)': FunctionFragment;
    'markets(uint256)': FunctionFragment;
    'marketsForQuote(address,uint256)': FunctionFragment;
    'metadata(uint256)': FunctionFragment;
    'notes(address,uint256)': FunctionFragment;
    'payoutFor(uint256,uint256)': FunctionFragment;
    'pendingFor(address,uint256)': FunctionFragment;
    'pullNote(address,uint256)': FunctionFragment;
    'pushNote(address,uint256)': FunctionFragment;
    'redeem(address,uint256[],bool)': FunctionFragment;
    'redeemAll(address,bool)': FunctionFragment;
    'refReward()': FunctionFragment;
    'rewards(address)': FunctionFragment;
    'setAuthority(address)': FunctionFragment;
    'setRewards(uint256,uint256)': FunctionFragment;
    'terms(uint256)': FunctionFragment;
    'updateTreasury()': FunctionFragment;
    'whitelist(address)': FunctionFragment;
    'whitelisted(address)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'adjustments'
      | 'authority'
      | 'close'
      | 'create'
      | 'currentControlVariable'
      | 'currentDebt'
      | 'daoReward'
      | 'debtDecay'
      | 'debtRatio'
      | 'deposit'
      | 'getReward'
      | 'indexesFor'
      | 'isLive'
      | 'liveMarkets'
      | 'liveMarketsFor'
      | 'marketPrice'
      | 'markets'
      | 'marketsForQuote'
      | 'metadata'
      | 'notes'
      | 'payoutFor'
      | 'pendingFor'
      | 'pullNote'
      | 'pushNote'
      | 'redeem'
      | 'redeemAll'
      | 'refReward'
      | 'rewards'
      | 'setAuthority'
      | 'setRewards'
      | 'terms'
      | 'updateTreasury'
      | 'whitelist'
      | 'whitelisted',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'adjustments', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'authority', values?: undefined): string;
  encodeFunctionData(functionFragment: 'close', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'create',
    values: [
      PromiseOrValue<string>,
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      [PromiseOrValue<boolean>, PromiseOrValue<boolean>],
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    ],
  ): string;
  encodeFunctionData(functionFragment: 'currentControlVariable', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'currentDebt', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'daoReward', values?: undefined): string;
  encodeFunctionData(functionFragment: 'debtDecay', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'debtRatio', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'deposit',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'getReward', values?: undefined): string;
  encodeFunctionData(functionFragment: 'indexesFor', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'isLive', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'liveMarkets', values?: undefined): string;
  encodeFunctionData(functionFragment: 'liveMarketsFor', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'marketPrice', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'markets', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'marketsForQuote',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'metadata', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'notes', values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'payoutFor',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'pendingFor',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'pullNote',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'pushNote',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'redeem',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>[], PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'redeemAll', values: [PromiseOrValue<string>, PromiseOrValue<boolean>]): string;
  encodeFunctionData(functionFragment: 'refReward', values?: undefined): string;
  encodeFunctionData(functionFragment: 'rewards', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setAuthority', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'setRewards',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'terms', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'updateTreasury', values?: undefined): string;
  encodeFunctionData(functionFragment: 'whitelist', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'whitelisted', values: [PromiseOrValue<string>]): string;

  decodeFunctionResult(functionFragment: 'adjustments', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'authority', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'close', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'create', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'currentControlVariable', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'currentDebt', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'daoReward', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'debtDecay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'debtRatio', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReward', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'indexesFor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isLive', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liveMarkets', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liveMarketsFor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'marketPrice', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'markets', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'marketsForQuote', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'metadata', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'notes', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'payoutFor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pendingFor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pullNote', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pushNote', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'redeem', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'redeemAll', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'refReward', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setAuthority', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'terms', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateTreasury', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'whitelist', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'whitelisted', data: BytesLike): Result;

  events: {
    'AuthorityUpdated(address)': EventFragment;
    'Bond(uint256,uint256,uint256)': EventFragment;
    'CloseMarket(uint256)': EventFragment;
    'CreateMarket(uint256,address,address,uint256)': EventFragment;
    'Tuned(uint256,uint64,uint64)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'AuthorityUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Bond'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CloseMarket'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CreateMarket'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Tuned'): EventFragment;
}

export interface AuthorityUpdatedEventObject {
  authority: string;
}
export type AuthorityUpdatedEvent = TypedEvent<[string], AuthorityUpdatedEventObject>;

export type AuthorityUpdatedEventFilter = TypedEventFilter<AuthorityUpdatedEvent>;

export interface BondEventObject {
  id: BigNumber;
  amount: BigNumber;
  price: BigNumber;
}
export type BondEvent = TypedEvent<[BigNumber, BigNumber, BigNumber], BondEventObject>;

export type BondEventFilter = TypedEventFilter<BondEvent>;

export interface CloseMarketEventObject {
  id: BigNumber;
}
export type CloseMarketEvent = TypedEvent<[BigNumber], CloseMarketEventObject>;

export type CloseMarketEventFilter = TypedEventFilter<CloseMarketEvent>;

export interface CreateMarketEventObject {
  id: BigNumber;
  baseToken: string;
  quoteToken: string;
  initialPrice: BigNumber;
}
export type CreateMarketEvent = TypedEvent<[BigNumber, string, string, BigNumber], CreateMarketEventObject>;

export type CreateMarketEventFilter = TypedEventFilter<CreateMarketEvent>;

export interface TunedEventObject {
  id: BigNumber;
  oldControlVariable: BigNumber;
  newControlVariable: BigNumber;
}
export type TunedEvent = TypedEvent<[BigNumber, BigNumber, BigNumber], TunedEventObject>;

export type TunedEventFilter = TypedEventFilter<TunedEvent>;

export interface OlympusV2BondDepository extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: OlympusV2BondDepositoryInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    adjustments(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, number, number, boolean] & {
        change: BigNumber;
        lastAdjustment: number;
        timeToAdjusted: number;
        active: boolean;
      }
    >;

    authority(overrides?: CallOverrides): Promise<[string]>;

    close(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    create(
      _quoteToken: PromiseOrValue<string>,
      _market: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      _booleans: [PromiseOrValue<boolean>, PromiseOrValue<boolean>],
      _terms: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      _intervals: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    currentControlVariable(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    currentDebt(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    daoReward(overrides?: CallOverrides): Promise<[BigNumber]>;

    debtDecay(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    debtRatio(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    deposit(
      _id: PromiseOrValue<BigNumberish>,
      _amount: PromiseOrValue<BigNumberish>,
      _maxPrice: PromiseOrValue<BigNumberish>,
      _user: PromiseOrValue<string>,
      _referral: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    getReward(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    indexesFor(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber[]]>;

    isLive(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[boolean]>;

    liveMarkets(overrides?: CallOverrides): Promise<[BigNumber[]]>;

    liveMarketsFor(_token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber[]]>;

    marketPrice(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    markets(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, string, boolean, BigNumber, BigNumber, BigNumber, BigNumber] & {
        capacity: BigNumber;
        quoteToken: string;
        capacityInQuote: boolean;
        totalDebt: BigNumber;
        maxPayout: BigNumber;
        sold: BigNumber;
        purchased: BigNumber;
      }
    >;

    marketsForQuote(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    metadata(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [number, number, number, number, number, number] & {
        lastTune: number;
        lastDecay: number;
        length: number;
        depositInterval: number;
        tuneInterval: number;
        quoteDecimals: number;
      }
    >;

    notes(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, number, number, number, number] & {
        payout: BigNumber;
        created: number;
        matured: number;
        redeemed: number;
        marketID: number;
      }
    >;

    payoutFor(
      _amount: PromiseOrValue<BigNumberish>,
      _id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    pendingFor(
      _user: PromiseOrValue<string>,
      _index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, boolean] & { payout_: BigNumber; matured_: boolean }>;

    pullNote(
      _from: PromiseOrValue<string>,
      _index: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    pushNote(
      _to: PromiseOrValue<string>,
      _index: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    redeem(
      _user: PromiseOrValue<string>,
      _indexes: PromiseOrValue<BigNumberish>[],
      _sendgOHM: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    redeemAll(
      _user: PromiseOrValue<string>,
      _sendgOHM: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    refReward(overrides?: CallOverrides): Promise<[BigNumber]>;

    rewards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    setAuthority(
      _newAuthority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setRewards(
      _toFrontEnd: PromiseOrValue<BigNumberish>,
      _toDAO: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    terms(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [boolean, BigNumber, number, number, BigNumber] & {
        fixedTerm: boolean;
        controlVariable: BigNumber;
        vesting: number;
        conclusion: number;
        maxDebt: BigNumber;
      }
    >;

    updateTreasury(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    whitelist(
      _operator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    whitelisted(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
  };

  adjustments(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, number, number, boolean] & {
      change: BigNumber;
      lastAdjustment: number;
      timeToAdjusted: number;
      active: boolean;
    }
  >;

  authority(overrides?: CallOverrides): Promise<string>;

  close(
    _id: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  create(
    _quoteToken: PromiseOrValue<string>,
    _market: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    _booleans: [PromiseOrValue<boolean>, PromiseOrValue<boolean>],
    _terms: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    _intervals: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  currentControlVariable(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  currentDebt(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  daoReward(overrides?: CallOverrides): Promise<BigNumber>;

  debtDecay(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  debtRatio(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  deposit(
    _id: PromiseOrValue<BigNumberish>,
    _amount: PromiseOrValue<BigNumberish>,
    _maxPrice: PromiseOrValue<BigNumberish>,
    _user: PromiseOrValue<string>,
    _referral: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  getReward(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  indexesFor(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber[]>;

  isLive(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>;

  liveMarkets(overrides?: CallOverrides): Promise<BigNumber[]>;

  liveMarketsFor(_token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber[]>;

  marketPrice(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  markets(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, string, boolean, BigNumber, BigNumber, BigNumber, BigNumber] & {
      capacity: BigNumber;
      quoteToken: string;
      capacityInQuote: boolean;
      totalDebt: BigNumber;
      maxPayout: BigNumber;
      sold: BigNumber;
      purchased: BigNumber;
    }
  >;

  marketsForQuote(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  metadata(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [number, number, number, number, number, number] & {
      lastTune: number;
      lastDecay: number;
      length: number;
      depositInterval: number;
      tuneInterval: number;
      quoteDecimals: number;
    }
  >;

  notes(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, number, number, number, number] & {
      payout: BigNumber;
      created: number;
      matured: number;
      redeemed: number;
      marketID: number;
    }
  >;

  payoutFor(
    _amount: PromiseOrValue<BigNumberish>,
    _id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  pendingFor(
    _user: PromiseOrValue<string>,
    _index: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, boolean] & { payout_: BigNumber; matured_: boolean }>;

  pullNote(
    _from: PromiseOrValue<string>,
    _index: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  pushNote(
    _to: PromiseOrValue<string>,
    _index: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  redeem(
    _user: PromiseOrValue<string>,
    _indexes: PromiseOrValue<BigNumberish>[],
    _sendgOHM: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  redeemAll(
    _user: PromiseOrValue<string>,
    _sendgOHM: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  refReward(overrides?: CallOverrides): Promise<BigNumber>;

  rewards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  setAuthority(
    _newAuthority: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setRewards(
    _toFrontEnd: PromiseOrValue<BigNumberish>,
    _toDAO: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  terms(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [boolean, BigNumber, number, number, BigNumber] & {
      fixedTerm: boolean;
      controlVariable: BigNumber;
      vesting: number;
      conclusion: number;
      maxDebt: BigNumber;
    }
  >;

  updateTreasury(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  whitelist(
    _operator: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  whitelisted(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  callStatic: {
    adjustments(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, number, number, boolean] & {
        change: BigNumber;
        lastAdjustment: number;
        timeToAdjusted: number;
        active: boolean;
      }
    >;

    authority(overrides?: CallOverrides): Promise<string>;

    close(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    create(
      _quoteToken: PromiseOrValue<string>,
      _market: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      _booleans: [PromiseOrValue<boolean>, PromiseOrValue<boolean>],
      _terms: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      _intervals: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    currentControlVariable(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    currentDebt(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    daoReward(overrides?: CallOverrides): Promise<BigNumber>;

    debtDecay(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    debtRatio(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    deposit(
      _id: PromiseOrValue<BigNumberish>,
      _amount: PromiseOrValue<BigNumberish>,
      _maxPrice: PromiseOrValue<BigNumberish>,
      _user: PromiseOrValue<string>,
      _referral: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        payout_: BigNumber;
        expiry_: BigNumber;
        index_: BigNumber;
      }
    >;

    getReward(overrides?: CallOverrides): Promise<void>;

    indexesFor(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber[]>;

    isLive(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>;

    liveMarkets(overrides?: CallOverrides): Promise<BigNumber[]>;

    liveMarketsFor(_token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber[]>;

    marketPrice(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    markets(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, string, boolean, BigNumber, BigNumber, BigNumber, BigNumber] & {
        capacity: BigNumber;
        quoteToken: string;
        capacityInQuote: boolean;
        totalDebt: BigNumber;
        maxPayout: BigNumber;
        sold: BigNumber;
        purchased: BigNumber;
      }
    >;

    marketsForQuote(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    metadata(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [number, number, number, number, number, number] & {
        lastTune: number;
        lastDecay: number;
        length: number;
        depositInterval: number;
        tuneInterval: number;
        quoteDecimals: number;
      }
    >;

    notes(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, number, number, number, number] & {
        payout: BigNumber;
        created: number;
        matured: number;
        redeemed: number;
        marketID: number;
      }
    >;

    payoutFor(
      _amount: PromiseOrValue<BigNumberish>,
      _id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    pendingFor(
      _user: PromiseOrValue<string>,
      _index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, boolean] & { payout_: BigNumber; matured_: boolean }>;

    pullNote(
      _from: PromiseOrValue<string>,
      _index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    pushNote(
      _to: PromiseOrValue<string>,
      _index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    redeem(
      _user: PromiseOrValue<string>,
      _indexes: PromiseOrValue<BigNumberish>[],
      _sendgOHM: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    redeemAll(
      _user: PromiseOrValue<string>,
      _sendgOHM: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    refReward(overrides?: CallOverrides): Promise<BigNumber>;

    rewards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    setAuthority(_newAuthority: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setRewards(
      _toFrontEnd: PromiseOrValue<BigNumberish>,
      _toDAO: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    terms(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [boolean, BigNumber, number, number, BigNumber] & {
        fixedTerm: boolean;
        controlVariable: BigNumber;
        vesting: number;
        conclusion: number;
        maxDebt: BigNumber;
      }
    >;

    updateTreasury(overrides?: CallOverrides): Promise<void>;

    whitelist(_operator: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    whitelisted(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
  };

  filters: {
    'AuthorityUpdated(address)'(authority?: PromiseOrValue<string> | null): AuthorityUpdatedEventFilter;
    AuthorityUpdated(authority?: PromiseOrValue<string> | null): AuthorityUpdatedEventFilter;

    'Bond(uint256,uint256,uint256)'(
      id?: PromiseOrValue<BigNumberish> | null,
      amount?: null,
      price?: null,
    ): BondEventFilter;
    Bond(id?: PromiseOrValue<BigNumberish> | null, amount?: null, price?: null): BondEventFilter;

    'CloseMarket(uint256)'(id?: PromiseOrValue<BigNumberish> | null): CloseMarketEventFilter;
    CloseMarket(id?: PromiseOrValue<BigNumberish> | null): CloseMarketEventFilter;

    'CreateMarket(uint256,address,address,uint256)'(
      id?: PromiseOrValue<BigNumberish> | null,
      baseToken?: PromiseOrValue<string> | null,
      quoteToken?: PromiseOrValue<string> | null,
      initialPrice?: null,
    ): CreateMarketEventFilter;
    CreateMarket(
      id?: PromiseOrValue<BigNumberish> | null,
      baseToken?: PromiseOrValue<string> | null,
      quoteToken?: PromiseOrValue<string> | null,
      initialPrice?: null,
    ): CreateMarketEventFilter;

    'Tuned(uint256,uint64,uint64)'(
      id?: PromiseOrValue<BigNumberish> | null,
      oldControlVariable?: null,
      newControlVariable?: null,
    ): TunedEventFilter;
    Tuned(
      id?: PromiseOrValue<BigNumberish> | null,
      oldControlVariable?: null,
      newControlVariable?: null,
    ): TunedEventFilter;
  };

  estimateGas: {
    adjustments(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    authority(overrides?: CallOverrides): Promise<BigNumber>;

    close(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    create(
      _quoteToken: PromiseOrValue<string>,
      _market: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      _booleans: [PromiseOrValue<boolean>, PromiseOrValue<boolean>],
      _terms: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      _intervals: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    currentControlVariable(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    currentDebt(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    daoReward(overrides?: CallOverrides): Promise<BigNumber>;

    debtDecay(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    debtRatio(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    deposit(
      _id: PromiseOrValue<BigNumberish>,
      _amount: PromiseOrValue<BigNumberish>,
      _maxPrice: PromiseOrValue<BigNumberish>,
      _user: PromiseOrValue<string>,
      _referral: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    getReward(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    indexesFor(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    isLive(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    liveMarkets(overrides?: CallOverrides): Promise<BigNumber>;

    liveMarketsFor(_token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    marketPrice(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    markets(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    marketsForQuote(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    metadata(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    notes(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    payoutFor(
      _amount: PromiseOrValue<BigNumberish>,
      _id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    pendingFor(
      _user: PromiseOrValue<string>,
      _index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    pullNote(
      _from: PromiseOrValue<string>,
      _index: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    pushNote(
      _to: PromiseOrValue<string>,
      _index: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    redeem(
      _user: PromiseOrValue<string>,
      _indexes: PromiseOrValue<BigNumberish>[],
      _sendgOHM: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    redeemAll(
      _user: PromiseOrValue<string>,
      _sendgOHM: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    refReward(overrides?: CallOverrides): Promise<BigNumber>;

    rewards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    setAuthority(
      _newAuthority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setRewards(
      _toFrontEnd: PromiseOrValue<BigNumberish>,
      _toDAO: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    terms(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    updateTreasury(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    whitelist(
      _operator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    whitelisted(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    adjustments(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    authority(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    close(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    create(
      _quoteToken: PromiseOrValue<string>,
      _market: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      _booleans: [PromiseOrValue<boolean>, PromiseOrValue<boolean>],
      _terms: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      _intervals: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    currentControlVariable(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    currentDebt(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    daoReward(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    debtDecay(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    debtRatio(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    deposit(
      _id: PromiseOrValue<BigNumberish>,
      _amount: PromiseOrValue<BigNumberish>,
      _maxPrice: PromiseOrValue<BigNumberish>,
      _user: PromiseOrValue<string>,
      _referral: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    getReward(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    indexesFor(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isLive(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    liveMarkets(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    liveMarketsFor(_token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    marketPrice(_id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    markets(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    marketsForQuote(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    metadata(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    notes(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    payoutFor(
      _amount: PromiseOrValue<BigNumberish>,
      _id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    pendingFor(
      _user: PromiseOrValue<string>,
      _index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    pullNote(
      _from: PromiseOrValue<string>,
      _index: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    pushNote(
      _to: PromiseOrValue<string>,
      _index: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    redeem(
      _user: PromiseOrValue<string>,
      _indexes: PromiseOrValue<BigNumberish>[],
      _sendgOHM: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    redeemAll(
      _user: PromiseOrValue<string>,
      _sendgOHM: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    refReward(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setAuthority(
      _newAuthority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setRewards(
      _toFrontEnd: PromiseOrValue<BigNumberish>,
      _toDAO: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    terms(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    updateTreasury(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    whitelist(
      _operator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    whitelisted(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from './common';

export declare namespace BondTellerErc20 {
  export type TermsStruct = {
    startPrice: BigNumberish;
    minimumPrice: BigNumberish;
    maxPayout: BigNumberish;
    priceAdjNum: BigNumberish;
    priceAdjDenom: BigNumberish;
    capacity: BigNumberish;
    capacityIsPayout: boolean;
    startTime: BigNumberish;
    endTime: BigNumberish;
    globalVestingTerm: BigNumberish;
    halfLife: BigNumberish;
  };

  export type TermsStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean,
    number,
    number,
    number,
    number,
  ] & {
    startPrice: BigNumber;
    minimumPrice: BigNumber;
    maxPayout: BigNumber;
    priceAdjNum: BigNumber;
    priceAdjDenom: BigNumber;
    capacity: BigNumber;
    capacityIsPayout: boolean;
    startTime: number;
    endTime: number;
    globalVestingTerm: number;
    halfLife: number;
  };
}

export interface BondTellerErc20Interface extends utils.Interface {
  functions: {
    'DOMAIN_SEPARATOR()': FunctionFragment;
    'PERMIT_TYPEHASH()': FunctionFragment;
    'acceptGovernance()': FunctionFragment;
    'approve(address,uint256)': FunctionFragment;
    'balanceOf(address)': FunctionFragment;
    'baseURI()': FunctionFragment;
    'bondDepo()': FunctionFragment;
    'bondPrice()': FunctionFragment;
    'bonds(uint256)': FunctionFragment;
    'calculateAmountIn(uint256,bool)': FunctionFragment;
    'calculateAmountOut(uint256,bool)': FunctionFragment;
    'calculateMinimalProxyDeploymentAddress(bytes32)': FunctionFragment;
    'capacity()': FunctionFragment;
    'capacityIsPayout()': FunctionFragment;
    'claimPayout(uint256)': FunctionFragment;
    'clone(string,address,address,bool,bytes32)': FunctionFragment;
    'dao()': FunctionFragment;
    'deposit(uint256,uint256,address,bool)': FunctionFragment;
    'depositSigned(uint256,uint256,address,bool,uint256,uint8,bytes32,bytes32)': FunctionFragment;
    'endTime()': FunctionFragment;
    'exists(uint256)': FunctionFragment;
    'getApproved(uint256)': FunctionFragment;
    'globalVestingTerm()': FunctionFragment;
    'governance()': FunctionFragment;
    'governanceIsLocked()': FunctionFragment;
    'halfLife()': FunctionFragment;
    'initialize(string,address,address,address,address,address,address,bool,address)': FunctionFragment;
    'isApprovedForAll(address,address)': FunctionFragment;
    'isPermittable()': FunctionFragment;
    'lastPriceUpdate()': FunctionFragment;
    'lockGovernance()': FunctionFragment;
    'maxPayout()': FunctionFragment;
    'minimumPrice()': FunctionFragment;
    'name()': FunctionFragment;
    'nextPrice()': FunctionFragment;
    'nonces(uint256)': FunctionFragment;
    'numBonds()': FunctionFragment;
    'ownerOf(uint256)': FunctionFragment;
    'pause()': FunctionFragment;
    'paused()': FunctionFragment;
    'pendingGovernance()': FunctionFragment;
    'permit(address,uint256,uint256,uint8,bytes32,bytes32)': FunctionFragment;
    'priceAdjDenom()': FunctionFragment;
    'priceAdjNum()': FunctionFragment;
    'principal()': FunctionFragment;
    'protocolFeeBps()': FunctionFragment;
    'safeTransfer(address,uint256)': FunctionFragment;
    'safeTransferFrom(address,address,uint256)': FunctionFragment;
    'safeTransferFrom(address,address,uint256,bytes)': FunctionFragment;
    'setAddresses(address,address,address,address,address,bool,address)': FunctionFragment;
    'setApprovalForAll(address,bool)': FunctionFragment;
    'setFees(uint256)': FunctionFragment;
    'setPendingGovernance(address)': FunctionFragment;
    'setTerms((uint256,uint256,uint256,uint128,uint128,uint256,bool,uint40,uint40,uint40,uint40))': FunctionFragment;
    'solace()': FunctionFragment;
    'startTime()': FunctionFragment;
    'supportsInterface(bytes4)': FunctionFragment;
    'symbol()': FunctionFragment;
    'termsSet()': FunctionFragment;
    'tokenByIndex(uint256)': FunctionFragment;
    'tokenOfOwnerByIndex(address,uint256)': FunctionFragment;
    'tokenURI(uint256)': FunctionFragment;
    'totalSupply()': FunctionFragment;
    'transfer(address,uint256)': FunctionFragment;
    'transferFrom(address,address,uint256)': FunctionFragment;
    'underwritingPool()': FunctionFragment;
    'unpause()': FunctionFragment;
    'xsLocker()': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'DOMAIN_SEPARATOR'
      | 'PERMIT_TYPEHASH'
      | 'acceptGovernance'
      | 'approve'
      | 'balanceOf'
      | 'baseURI'
      | 'bondDepo'
      | 'bondPrice'
      | 'bonds'
      | 'calculateAmountIn'
      | 'calculateAmountOut'
      | 'calculateMinimalProxyDeploymentAddress'
      | 'capacity'
      | 'capacityIsPayout'
      | 'claimPayout'
      | 'clone'
      | 'dao'
      | 'deposit'
      | 'depositSigned'
      | 'endTime'
      | 'exists'
      | 'getApproved'
      | 'globalVestingTerm'
      | 'governance'
      | 'governanceIsLocked'
      | 'halfLife'
      | 'initialize'
      | 'isApprovedForAll'
      | 'isPermittable'
      | 'lastPriceUpdate'
      | 'lockGovernance'
      | 'maxPayout'
      | 'minimumPrice'
      | 'name'
      | 'nextPrice'
      | 'nonces'
      | 'numBonds'
      | 'ownerOf'
      | 'pause'
      | 'paused'
      | 'pendingGovernance'
      | 'permit'
      | 'priceAdjDenom'
      | 'priceAdjNum'
      | 'principal'
      | 'protocolFeeBps'
      | 'safeTransfer'
      | 'safeTransferFrom(address,address,uint256)'
      | 'safeTransferFrom(address,address,uint256,bytes)'
      | 'setAddresses'
      | 'setApprovalForAll'
      | 'setFees'
      | 'setPendingGovernance'
      | 'setTerms'
      | 'solace'
      | 'startTime'
      | 'supportsInterface'
      | 'symbol'
      | 'termsSet'
      | 'tokenByIndex'
      | 'tokenOfOwnerByIndex'
      | 'tokenURI'
      | 'totalSupply'
      | 'transfer'
      | 'transferFrom'
      | 'underwritingPool'
      | 'unpause'
      | 'xsLocker',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'DOMAIN_SEPARATOR', values?: undefined): string;
  encodeFunctionData(functionFragment: 'PERMIT_TYPEHASH', values?: undefined): string;
  encodeFunctionData(functionFragment: 'acceptGovernance', values?: undefined): string;
  encodeFunctionData(functionFragment: 'approve', values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'balanceOf', values: [string]): string;
  encodeFunctionData(functionFragment: 'baseURI', values?: undefined): string;
  encodeFunctionData(functionFragment: 'bondDepo', values?: undefined): string;
  encodeFunctionData(functionFragment: 'bondPrice', values?: undefined): string;
  encodeFunctionData(functionFragment: 'bonds', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'calculateAmountIn', values: [BigNumberish, boolean]): string;
  encodeFunctionData(functionFragment: 'calculateAmountOut', values: [BigNumberish, boolean]): string;
  encodeFunctionData(functionFragment: 'calculateMinimalProxyDeploymentAddress', values: [BytesLike]): string;
  encodeFunctionData(functionFragment: 'capacity', values?: undefined): string;
  encodeFunctionData(functionFragment: 'capacityIsPayout', values?: undefined): string;
  encodeFunctionData(functionFragment: 'claimPayout', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'clone', values: [string, string, string, boolean, BytesLike]): string;
  encodeFunctionData(functionFragment: 'dao', values?: undefined): string;
  encodeFunctionData(functionFragment: 'deposit', values: [BigNumberish, BigNumberish, string, boolean]): string;
  encodeFunctionData(
    functionFragment: 'depositSigned',
    values: [BigNumberish, BigNumberish, string, boolean, BigNumberish, BigNumberish, BytesLike, BytesLike],
  ): string;
  encodeFunctionData(functionFragment: 'endTime', values?: undefined): string;
  encodeFunctionData(functionFragment: 'exists', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'getApproved', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'globalVestingTerm', values?: undefined): string;
  encodeFunctionData(functionFragment: 'governance', values?: undefined): string;
  encodeFunctionData(functionFragment: 'governanceIsLocked', values?: undefined): string;
  encodeFunctionData(functionFragment: 'halfLife', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'initialize',
    values: [string, string, string, string, string, string, string, boolean, string],
  ): string;
  encodeFunctionData(functionFragment: 'isApprovedForAll', values: [string, string]): string;
  encodeFunctionData(functionFragment: 'isPermittable', values?: undefined): string;
  encodeFunctionData(functionFragment: 'lastPriceUpdate', values?: undefined): string;
  encodeFunctionData(functionFragment: 'lockGovernance', values?: undefined): string;
  encodeFunctionData(functionFragment: 'maxPayout', values?: undefined): string;
  encodeFunctionData(functionFragment: 'minimumPrice', values?: undefined): string;
  encodeFunctionData(functionFragment: 'name', values?: undefined): string;
  encodeFunctionData(functionFragment: 'nextPrice', values?: undefined): string;
  encodeFunctionData(functionFragment: 'nonces', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'numBonds', values?: undefined): string;
  encodeFunctionData(functionFragment: 'ownerOf', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'pause', values?: undefined): string;
  encodeFunctionData(functionFragment: 'paused', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pendingGovernance', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'permit',
    values: [string, BigNumberish, BigNumberish, BigNumberish, BytesLike, BytesLike],
  ): string;
  encodeFunctionData(functionFragment: 'priceAdjDenom', values?: undefined): string;
  encodeFunctionData(functionFragment: 'priceAdjNum', values?: undefined): string;
  encodeFunctionData(functionFragment: 'principal', values?: undefined): string;
  encodeFunctionData(functionFragment: 'protocolFeeBps', values?: undefined): string;
  encodeFunctionData(functionFragment: 'safeTransfer', values: [string, BigNumberish]): string;
  encodeFunctionData(
    functionFragment: 'safeTransferFrom(address,address,uint256)',
    values: [string, string, BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'safeTransferFrom(address,address,uint256,bytes)',
    values: [string, string, BigNumberish, BytesLike],
  ): string;
  encodeFunctionData(
    functionFragment: 'setAddresses',
    values: [string, string, string, string, string, boolean, string],
  ): string;
  encodeFunctionData(functionFragment: 'setApprovalForAll', values: [string, boolean]): string;
  encodeFunctionData(functionFragment: 'setFees', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'setPendingGovernance', values: [string]): string;
  encodeFunctionData(functionFragment: 'setTerms', values: [BondTellerErc20.TermsStruct]): string;
  encodeFunctionData(functionFragment: 'solace', values?: undefined): string;
  encodeFunctionData(functionFragment: 'startTime', values?: undefined): string;
  encodeFunctionData(functionFragment: 'supportsInterface', values: [BytesLike]): string;
  encodeFunctionData(functionFragment: 'symbol', values?: undefined): string;
  encodeFunctionData(functionFragment: 'termsSet', values?: undefined): string;
  encodeFunctionData(functionFragment: 'tokenByIndex', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'tokenOfOwnerByIndex', values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'tokenURI', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'totalSupply', values?: undefined): string;
  encodeFunctionData(functionFragment: 'transfer', values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'transferFrom', values: [string, string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'underwritingPool', values?: undefined): string;
  encodeFunctionData(functionFragment: 'unpause', values?: undefined): string;
  encodeFunctionData(functionFragment: 'xsLocker', values?: undefined): string;

  decodeFunctionResult(functionFragment: 'DOMAIN_SEPARATOR', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'PERMIT_TYPEHASH', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'acceptGovernance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'approve', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'baseURI', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'bondDepo', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'bondPrice', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'bonds', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'calculateAmountIn', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'calculateAmountOut', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'calculateMinimalProxyDeploymentAddress', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'capacity', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'capacityIsPayout', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimPayout', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'clone', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'dao', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'depositSigned', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'endTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exists', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getApproved', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'globalVestingTerm', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'governance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'governanceIsLocked', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'halfLife', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isApprovedForAll', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isPermittable', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lastPriceUpdate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lockGovernance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'maxPayout', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'minimumPrice', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'name', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nextPrice', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nonces', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'numBonds', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'ownerOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pause', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'paused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pendingGovernance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'permit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'priceAdjDenom', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'priceAdjNum', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'principal', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'protocolFeeBps', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'safeTransfer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'safeTransferFrom(address,address,uint256)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'safeTransferFrom(address,address,uint256,bytes)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setAddresses', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setApprovalForAll', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setFees', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setPendingGovernance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setTerms', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'solace', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'startTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'supportsInterface', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'symbol', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'termsSet', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tokenByIndex', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tokenOfOwnerByIndex', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tokenURI', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalSupply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transfer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferFrom', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'underwritingPool', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'unpause', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'xsLocker', data: BytesLike): Result;

  events: {
    'AddressesSet()': EventFragment;
    'Approval(address,address,uint256)': EventFragment;
    'ApprovalForAll(address,address,bool)': EventFragment;
    'BaseURISet(string)': EventFragment;
    'ContractDeployed(address)': EventFragment;
    'CreateBond(uint256,uint256,uint256,uint40,uint40)': EventFragment;
    'FeesSet()': EventFragment;
    'GovernanceLocked()': EventFragment;
    'GovernancePending(address)': EventFragment;
    'GovernanceTransferred(address,address)': EventFragment;
    'Paused()': EventFragment;
    'RedeemBond(uint256,address,uint256)': EventFragment;
    'TermsSet()': EventFragment;
    'Transfer(address,address,uint256)': EventFragment;
    'Unpaused()': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'AddressesSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Approval'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ApprovalForAll'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'BaseURISet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ContractDeployed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CreateBond'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'FeesSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'GovernanceLocked'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'GovernancePending'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'GovernanceTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Paused'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RedeemBond'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TermsSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Transfer'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Unpaused'): EventFragment;
}

export interface AddressesSetEventObject {}
export type AddressesSetEvent = TypedEvent<[], AddressesSetEventObject>;

export type AddressesSetEventFilter = TypedEventFilter<AddressesSetEvent>;

export interface ApprovalEventObject {
  owner: string;
  approved: string;
  tokenId: BigNumber;
}
export type ApprovalEvent = TypedEvent<[string, string, BigNumber], ApprovalEventObject>;

export type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;

export interface ApprovalForAllEventObject {
  owner: string;
  operator: string;
  approved: boolean;
}
export type ApprovalForAllEvent = TypedEvent<[string, string, boolean], ApprovalForAllEventObject>;

export type ApprovalForAllEventFilter = TypedEventFilter<ApprovalForAllEvent>;

export interface BaseURISetEventObject {
  baseURI: string;
}
export type BaseURISetEvent = TypedEvent<[string], BaseURISetEventObject>;

export type BaseURISetEventFilter = TypedEventFilter<BaseURISetEvent>;

export interface ContractDeployedEventObject {
  deployment: string;
}
export type ContractDeployedEvent = TypedEvent<[string], ContractDeployedEventObject>;

export type ContractDeployedEventFilter = TypedEventFilter<ContractDeployedEvent>;

export interface CreateBondEventObject {
  lockID: BigNumber;
  principalAmount: BigNumber;
  payoutAmount: BigNumber;
  vestingStart: number;
  vestingTime: number;
}
export type CreateBondEvent = TypedEvent<[BigNumber, BigNumber, BigNumber, number, number], CreateBondEventObject>;

export type CreateBondEventFilter = TypedEventFilter<CreateBondEvent>;

export interface FeesSetEventObject {}
export type FeesSetEvent = TypedEvent<[], FeesSetEventObject>;

export type FeesSetEventFilter = TypedEventFilter<FeesSetEvent>;

export interface GovernanceLockedEventObject {}
export type GovernanceLockedEvent = TypedEvent<[], GovernanceLockedEventObject>;

export type GovernanceLockedEventFilter = TypedEventFilter<GovernanceLockedEvent>;

export interface GovernancePendingEventObject {
  pendingGovernance: string;
}
export type GovernancePendingEvent = TypedEvent<[string], GovernancePendingEventObject>;

export type GovernancePendingEventFilter = TypedEventFilter<GovernancePendingEvent>;

export interface GovernanceTransferredEventObject {
  oldGovernance: string;
  newGovernance: string;
}
export type GovernanceTransferredEvent = TypedEvent<[string, string], GovernanceTransferredEventObject>;

export type GovernanceTransferredEventFilter = TypedEventFilter<GovernanceTransferredEvent>;

export interface PausedEventObject {}
export type PausedEvent = TypedEvent<[], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface RedeemBondEventObject {
  bondID: BigNumber;
  recipient: string;
  payoutAmount: BigNumber;
}
export type RedeemBondEvent = TypedEvent<[BigNumber, string, BigNumber], RedeemBondEventObject>;

export type RedeemBondEventFilter = TypedEventFilter<RedeemBondEvent>;

export interface TermsSetEventObject {}
export type TermsSetEvent = TypedEvent<[], TermsSetEventObject>;

export type TermsSetEventFilter = TypedEventFilter<TermsSetEvent>;

export interface TransferEventObject {
  from: string;
  to: string;
  tokenId: BigNumber;
}
export type TransferEvent = TypedEvent<[string, string, BigNumber], TransferEventObject>;

export type TransferEventFilter = TypedEventFilter<TransferEvent>;

export interface UnpausedEventObject {}
export type UnpausedEvent = TypedEvent<[], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface BondTellerErc20 extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: BondTellerErc20Interface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string] & { seperator: string }>;

    PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<[string] & { typehash: string }>;

    acceptGovernance(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    approve(
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    balanceOf(owner: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    baseURI(overrides?: CallOverrides): Promise<[string]>;

    bondDepo(overrides?: CallOverrides): Promise<[string]>;

    bondPrice(overrides?: CallOverrides): Promise<[BigNumber] & { price_: BigNumber }>;

    bonds(
      arg0: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, number, number] & {
        payoutAmount: BigNumber;
        payoutAlreadyClaimed: BigNumber;
        principalPaid: BigNumber;
        vestingStart: number;
        localVestingTerm: number;
      }
    >;

    calculateAmountIn(
      amountOut: BigNumberish,
      stake: boolean,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { amountIn: BigNumber }>;

    calculateAmountOut(
      amountIn: BigNumberish,
      stake: boolean,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { amountOut: BigNumber }>;

    calculateMinimalProxyDeploymentAddress(salt: BytesLike, overrides?: CallOverrides): Promise<[string]>;

    capacity(overrides?: CallOverrides): Promise<[BigNumber]>;

    capacityIsPayout(overrides?: CallOverrides): Promise<[boolean]>;

    claimPayout(
      bondID: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    clone(
      name_: string,
      governance_: string,
      principal_: string,
      isPermittable_: boolean,
      salt_: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    dao(overrides?: CallOverrides): Promise<[string]>;

    deposit(
      amount: BigNumberish,
      minAmountOut: BigNumberish,
      depositor: string,
      stake: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    depositSigned(
      amount: BigNumberish,
      minAmountOut: BigNumberish,
      depositor: string,
      stake: boolean,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    endTime(overrides?: CallOverrides): Promise<[number]>;

    exists(tokenID: BigNumberish, overrides?: CallOverrides): Promise<[boolean] & { status: boolean }>;

    getApproved(tokenId: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    globalVestingTerm(overrides?: CallOverrides): Promise<[number]>;

    governance(overrides?: CallOverrides): Promise<[string]>;

    governanceIsLocked(overrides?: CallOverrides): Promise<[boolean]>;

    halfLife(overrides?: CallOverrides): Promise<[BigNumber]>;

    initialize(
      name_: string,
      governance_: string,
      solace_: string,
      xsLocker_: string,
      pool_: string,
      dao_: string,
      principal_: string,
      isPermittable_: boolean,
      bondDepo_: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    isApprovedForAll(owner: string, operator: string, overrides?: CallOverrides): Promise<[boolean]>;

    isPermittable(overrides?: CallOverrides): Promise<[boolean]>;

    lastPriceUpdate(overrides?: CallOverrides): Promise<[BigNumber]>;

    lockGovernance(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    maxPayout(overrides?: CallOverrides): Promise<[BigNumber]>;

    minimumPrice(overrides?: CallOverrides): Promise<[BigNumber]>;

    name(overrides?: CallOverrides): Promise<[string]>;

    nextPrice(overrides?: CallOverrides): Promise<[BigNumber]>;

    nonces(tokenID: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber] & { nonce: BigNumber }>;

    numBonds(overrides?: CallOverrides): Promise<[BigNumber]>;

    ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    pause(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    pendingGovernance(overrides?: CallOverrides): Promise<[string]>;

    permit(
      spender: string,
      tokenID: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    priceAdjDenom(overrides?: CallOverrides): Promise<[BigNumber]>;

    priceAdjNum(overrides?: CallOverrides): Promise<[BigNumber]>;

    principal(overrides?: CallOverrides): Promise<[string]>;

    protocolFeeBps(overrides?: CallOverrides): Promise<[BigNumber]>;

    safeTransfer(
      to: string,
      tokenID: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    'safeTransferFrom(address,address,uint256)'(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    'safeTransferFrom(address,address,uint256,bytes)'(
      from: string,
      to: string,
      tokenId: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    setAddresses(
      solace_: string,
      xsLocker_: string,
      pool_: string,
      dao_: string,
      principal_: string,
      isPermittable_: boolean,
      bondDepo_: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    setFees(
      protocolFee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    setPendingGovernance(
      pendingGovernance_: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    setTerms(
      terms: BondTellerErc20.TermsStruct,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    solace(overrides?: CallOverrides): Promise<[string]>;

    startTime(overrides?: CallOverrides): Promise<[number]>;

    supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<[boolean]>;

    symbol(overrides?: CallOverrides): Promise<[string]>;

    termsSet(overrides?: CallOverrides): Promise<[boolean]>;

    tokenByIndex(index: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;

    tokenOfOwnerByIndex(owner: string, index: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;

    tokenURI(tokenID: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    transfer(
      to: string,
      tokenID: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    transferFrom(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    underwritingPool(overrides?: CallOverrides): Promise<[string]>;

    unpause(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    xsLocker(overrides?: CallOverrides): Promise<[string]>;
  };

  DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

  PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  acceptGovernance(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  approve(
    to: string,
    tokenId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  balanceOf(owner: string, overrides?: CallOverrides): Promise<BigNumber>;

  baseURI(overrides?: CallOverrides): Promise<string>;

  bondDepo(overrides?: CallOverrides): Promise<string>;

  bondPrice(overrides?: CallOverrides): Promise<BigNumber>;

  bonds(
    arg0: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber, number, number] & {
      payoutAmount: BigNumber;
      payoutAlreadyClaimed: BigNumber;
      principalPaid: BigNumber;
      vestingStart: number;
      localVestingTerm: number;
    }
  >;

  calculateAmountIn(amountOut: BigNumberish, stake: boolean, overrides?: CallOverrides): Promise<BigNumber>;

  calculateAmountOut(amountIn: BigNumberish, stake: boolean, overrides?: CallOverrides): Promise<BigNumber>;

  calculateMinimalProxyDeploymentAddress(salt: BytesLike, overrides?: CallOverrides): Promise<string>;

  capacity(overrides?: CallOverrides): Promise<BigNumber>;

  capacityIsPayout(overrides?: CallOverrides): Promise<boolean>;

  claimPayout(
    bondID: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  clone(
    name_: string,
    governance_: string,
    principal_: string,
    isPermittable_: boolean,
    salt_: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  dao(overrides?: CallOverrides): Promise<string>;

  deposit(
    amount: BigNumberish,
    minAmountOut: BigNumberish,
    depositor: string,
    stake: boolean,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  depositSigned(
    amount: BigNumberish,
    minAmountOut: BigNumberish,
    depositor: string,
    stake: boolean,
    deadline: BigNumberish,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  endTime(overrides?: CallOverrides): Promise<number>;

  exists(tokenID: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

  getApproved(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

  globalVestingTerm(overrides?: CallOverrides): Promise<number>;

  governance(overrides?: CallOverrides): Promise<string>;

  governanceIsLocked(overrides?: CallOverrides): Promise<boolean>;

  halfLife(overrides?: CallOverrides): Promise<BigNumber>;

  initialize(
    name_: string,
    governance_: string,
    solace_: string,
    xsLocker_: string,
    pool_: string,
    dao_: string,
    principal_: string,
    isPermittable_: boolean,
    bondDepo_: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  isApprovedForAll(owner: string, operator: string, overrides?: CallOverrides): Promise<boolean>;

  isPermittable(overrides?: CallOverrides): Promise<boolean>;

  lastPriceUpdate(overrides?: CallOverrides): Promise<BigNumber>;

  lockGovernance(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  maxPayout(overrides?: CallOverrides): Promise<BigNumber>;

  minimumPrice(overrides?: CallOverrides): Promise<BigNumber>;

  name(overrides?: CallOverrides): Promise<string>;

  nextPrice(overrides?: CallOverrides): Promise<BigNumber>;

  nonces(tokenID: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  numBonds(overrides?: CallOverrides): Promise<BigNumber>;

  ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

  pause(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  pendingGovernance(overrides?: CallOverrides): Promise<string>;

  permit(
    spender: string,
    tokenID: BigNumberish,
    deadline: BigNumberish,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  priceAdjDenom(overrides?: CallOverrides): Promise<BigNumber>;

  priceAdjNum(overrides?: CallOverrides): Promise<BigNumber>;

  principal(overrides?: CallOverrides): Promise<string>;

  protocolFeeBps(overrides?: CallOverrides): Promise<BigNumber>;

  safeTransfer(
    to: string,
    tokenID: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  'safeTransferFrom(address,address,uint256)'(
    from: string,
    to: string,
    tokenId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  'safeTransferFrom(address,address,uint256,bytes)'(
    from: string,
    to: string,
    tokenId: BigNumberish,
    _data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  setAddresses(
    solace_: string,
    xsLocker_: string,
    pool_: string,
    dao_: string,
    principal_: string,
    isPermittable_: boolean,
    bondDepo_: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  setApprovalForAll(
    operator: string,
    approved: boolean,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  setFees(
    protocolFee: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  setPendingGovernance(
    pendingGovernance_: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  setTerms(
    terms: BondTellerErc20.TermsStruct,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  solace(overrides?: CallOverrides): Promise<string>;

  startTime(overrides?: CallOverrides): Promise<number>;

  supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<boolean>;

  symbol(overrides?: CallOverrides): Promise<string>;

  termsSet(overrides?: CallOverrides): Promise<boolean>;

  tokenByIndex(index: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  tokenOfOwnerByIndex(owner: string, index: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  tokenURI(tokenID: BigNumberish, overrides?: CallOverrides): Promise<string>;

  totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  transfer(
    to: string,
    tokenID: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  transferFrom(
    from: string,
    to: string,
    tokenId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  underwritingPool(overrides?: CallOverrides): Promise<string>;

  unpause(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  xsLocker(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

    PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    acceptGovernance(overrides?: CallOverrides): Promise<void>;

    approve(to: string, tokenId: BigNumberish, overrides?: CallOverrides): Promise<void>;

    balanceOf(owner: string, overrides?: CallOverrides): Promise<BigNumber>;

    baseURI(overrides?: CallOverrides): Promise<string>;

    bondDepo(overrides?: CallOverrides): Promise<string>;

    bondPrice(overrides?: CallOverrides): Promise<BigNumber>;

    bonds(
      arg0: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, number, number] & {
        payoutAmount: BigNumber;
        payoutAlreadyClaimed: BigNumber;
        principalPaid: BigNumber;
        vestingStart: number;
        localVestingTerm: number;
      }
    >;

    calculateAmountIn(amountOut: BigNumberish, stake: boolean, overrides?: CallOverrides): Promise<BigNumber>;

    calculateAmountOut(amountIn: BigNumberish, stake: boolean, overrides?: CallOverrides): Promise<BigNumber>;

    calculateMinimalProxyDeploymentAddress(salt: BytesLike, overrides?: CallOverrides): Promise<string>;

    capacity(overrides?: CallOverrides): Promise<BigNumber>;

    capacityIsPayout(overrides?: CallOverrides): Promise<boolean>;

    claimPayout(bondID: BigNumberish, overrides?: CallOverrides): Promise<void>;

    clone(
      name_: string,
      governance_: string,
      principal_: string,
      isPermittable_: boolean,
      salt_: BytesLike,
      overrides?: CallOverrides,
    ): Promise<string>;

    dao(overrides?: CallOverrides): Promise<string>;

    deposit(
      amount: BigNumberish,
      minAmountOut: BigNumberish,
      depositor: string,
      stake: boolean,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { payout: BigNumber; tokenID: BigNumber }>;

    depositSigned(
      amount: BigNumberish,
      minAmountOut: BigNumberish,
      depositor: string,
      stake: boolean,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { payout: BigNumber; tokenID: BigNumber }>;

    endTime(overrides?: CallOverrides): Promise<number>;

    exists(tokenID: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

    getApproved(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

    globalVestingTerm(overrides?: CallOverrides): Promise<number>;

    governance(overrides?: CallOverrides): Promise<string>;

    governanceIsLocked(overrides?: CallOverrides): Promise<boolean>;

    halfLife(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      name_: string,
      governance_: string,
      solace_: string,
      xsLocker_: string,
      pool_: string,
      dao_: string,
      principal_: string,
      isPermittable_: boolean,
      bondDepo_: string,
      overrides?: CallOverrides,
    ): Promise<void>;

    isApprovedForAll(owner: string, operator: string, overrides?: CallOverrides): Promise<boolean>;

    isPermittable(overrides?: CallOverrides): Promise<boolean>;

    lastPriceUpdate(overrides?: CallOverrides): Promise<BigNumber>;

    lockGovernance(overrides?: CallOverrides): Promise<void>;

    maxPayout(overrides?: CallOverrides): Promise<BigNumber>;

    minimumPrice(overrides?: CallOverrides): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<string>;

    nextPrice(overrides?: CallOverrides): Promise<BigNumber>;

    nonces(tokenID: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    numBonds(overrides?: CallOverrides): Promise<BigNumber>;

    ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

    pause(overrides?: CallOverrides): Promise<void>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    pendingGovernance(overrides?: CallOverrides): Promise<string>;

    permit(
      spender: string,
      tokenID: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides,
    ): Promise<void>;

    priceAdjDenom(overrides?: CallOverrides): Promise<BigNumber>;

    priceAdjNum(overrides?: CallOverrides): Promise<BigNumber>;

    principal(overrides?: CallOverrides): Promise<string>;

    protocolFeeBps(overrides?: CallOverrides): Promise<BigNumber>;

    safeTransfer(to: string, tokenID: BigNumberish, overrides?: CallOverrides): Promise<void>;

    'safeTransferFrom(address,address,uint256)'(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<void>;

    'safeTransferFrom(address,address,uint256,bytes)'(
      from: string,
      to: string,
      tokenId: BigNumberish,
      _data: BytesLike,
      overrides?: CallOverrides,
    ): Promise<void>;

    setAddresses(
      solace_: string,
      xsLocker_: string,
      pool_: string,
      dao_: string,
      principal_: string,
      isPermittable_: boolean,
      bondDepo_: string,
      overrides?: CallOverrides,
    ): Promise<void>;

    setApprovalForAll(operator: string, approved: boolean, overrides?: CallOverrides): Promise<void>;

    setFees(protocolFee: BigNumberish, overrides?: CallOverrides): Promise<void>;

    setPendingGovernance(pendingGovernance_: string, overrides?: CallOverrides): Promise<void>;

    setTerms(terms: BondTellerErc20.TermsStruct, overrides?: CallOverrides): Promise<void>;

    solace(overrides?: CallOverrides): Promise<string>;

    startTime(overrides?: CallOverrides): Promise<number>;

    supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<boolean>;

    symbol(overrides?: CallOverrides): Promise<string>;

    termsSet(overrides?: CallOverrides): Promise<boolean>;

    tokenByIndex(index: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    tokenOfOwnerByIndex(owner: string, index: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    tokenURI(tokenID: BigNumberish, overrides?: CallOverrides): Promise<string>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    transfer(to: string, tokenID: BigNumberish, overrides?: CallOverrides): Promise<void>;

    transferFrom(from: string, to: string, tokenId: BigNumberish, overrides?: CallOverrides): Promise<void>;

    underwritingPool(overrides?: CallOverrides): Promise<string>;

    unpause(overrides?: CallOverrides): Promise<void>;

    xsLocker(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    'AddressesSet()'(): AddressesSetEventFilter;
    AddressesSet(): AddressesSetEventFilter;

    'Approval(address,address,uint256)'(
      owner?: string | null,
      approved?: string | null,
      tokenId?: BigNumberish | null,
    ): ApprovalEventFilter;
    Approval(owner?: string | null, approved?: string | null, tokenId?: BigNumberish | null): ApprovalEventFilter;

    'ApprovalForAll(address,address,bool)'(
      owner?: string | null,
      operator?: string | null,
      approved?: null,
    ): ApprovalForAllEventFilter;
    ApprovalForAll(owner?: string | null, operator?: string | null, approved?: null): ApprovalForAllEventFilter;

    'BaseURISet(string)'(baseURI?: null): BaseURISetEventFilter;
    BaseURISet(baseURI?: null): BaseURISetEventFilter;

    'ContractDeployed(address)'(deployment?: string | null): ContractDeployedEventFilter;
    ContractDeployed(deployment?: string | null): ContractDeployedEventFilter;

    'CreateBond(uint256,uint256,uint256,uint40,uint40)'(
      lockID?: BigNumberish | null,
      principalAmount?: null,
      payoutAmount?: null,
      vestingStart?: null,
      vestingTime?: null,
    ): CreateBondEventFilter;
    CreateBond(
      lockID?: BigNumberish | null,
      principalAmount?: null,
      payoutAmount?: null,
      vestingStart?: null,
      vestingTime?: null,
    ): CreateBondEventFilter;

    'FeesSet()'(): FeesSetEventFilter;
    FeesSet(): FeesSetEventFilter;

    'GovernanceLocked()'(): GovernanceLockedEventFilter;
    GovernanceLocked(): GovernanceLockedEventFilter;

    'GovernancePending(address)'(pendingGovernance?: null): GovernancePendingEventFilter;
    GovernancePending(pendingGovernance?: null): GovernancePendingEventFilter;

    'GovernanceTransferred(address,address)'(
      oldGovernance?: null,
      newGovernance?: null,
    ): GovernanceTransferredEventFilter;
    GovernanceTransferred(oldGovernance?: null, newGovernance?: null): GovernanceTransferredEventFilter;

    'Paused()'(): PausedEventFilter;
    Paused(): PausedEventFilter;

    'RedeemBond(uint256,address,uint256)'(
      bondID?: BigNumberish | null,
      recipient?: null,
      payoutAmount?: null,
    ): RedeemBondEventFilter;
    RedeemBond(bondID?: BigNumberish | null, recipient?: null, payoutAmount?: null): RedeemBondEventFilter;

    'TermsSet()'(): TermsSetEventFilter;
    TermsSet(): TermsSetEventFilter;

    'Transfer(address,address,uint256)'(
      from?: string | null,
      to?: string | null,
      tokenId?: BigNumberish | null,
    ): TransferEventFilter;
    Transfer(from?: string | null, to?: string | null, tokenId?: BigNumberish | null): TransferEventFilter;

    'Unpaused()'(): UnpausedEventFilter;
    Unpaused(): UnpausedEventFilter;
  };

  estimateGas: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber>;

    PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    acceptGovernance(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    approve(
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    balanceOf(owner: string, overrides?: CallOverrides): Promise<BigNumber>;

    baseURI(overrides?: CallOverrides): Promise<BigNumber>;

    bondDepo(overrides?: CallOverrides): Promise<BigNumber>;

    bondPrice(overrides?: CallOverrides): Promise<BigNumber>;

    bonds(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    calculateAmountIn(amountOut: BigNumberish, stake: boolean, overrides?: CallOverrides): Promise<BigNumber>;

    calculateAmountOut(amountIn: BigNumberish, stake: boolean, overrides?: CallOverrides): Promise<BigNumber>;

    calculateMinimalProxyDeploymentAddress(salt: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    capacity(overrides?: CallOverrides): Promise<BigNumber>;

    capacityIsPayout(overrides?: CallOverrides): Promise<BigNumber>;

    claimPayout(bondID: BigNumberish, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    clone(
      name_: string,
      governance_: string,
      principal_: string,
      isPermittable_: boolean,
      salt_: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    dao(overrides?: CallOverrides): Promise<BigNumber>;

    deposit(
      amount: BigNumberish,
      minAmountOut: BigNumberish,
      depositor: string,
      stake: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    depositSigned(
      amount: BigNumberish,
      minAmountOut: BigNumberish,
      depositor: string,
      stake: boolean,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    endTime(overrides?: CallOverrides): Promise<BigNumber>;

    exists(tokenID: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    getApproved(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    globalVestingTerm(overrides?: CallOverrides): Promise<BigNumber>;

    governance(overrides?: CallOverrides): Promise<BigNumber>;

    governanceIsLocked(overrides?: CallOverrides): Promise<BigNumber>;

    halfLife(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      name_: string,
      governance_: string,
      solace_: string,
      xsLocker_: string,
      pool_: string,
      dao_: string,
      principal_: string,
      isPermittable_: boolean,
      bondDepo_: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    isApprovedForAll(owner: string, operator: string, overrides?: CallOverrides): Promise<BigNumber>;

    isPermittable(overrides?: CallOverrides): Promise<BigNumber>;

    lastPriceUpdate(overrides?: CallOverrides): Promise<BigNumber>;

    lockGovernance(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    maxPayout(overrides?: CallOverrides): Promise<BigNumber>;

    minimumPrice(overrides?: CallOverrides): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    nextPrice(overrides?: CallOverrides): Promise<BigNumber>;

    nonces(tokenID: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    numBonds(overrides?: CallOverrides): Promise<BigNumber>;

    ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    pause(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    pendingGovernance(overrides?: CallOverrides): Promise<BigNumber>;

    permit(
      spender: string,
      tokenID: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    priceAdjDenom(overrides?: CallOverrides): Promise<BigNumber>;

    priceAdjNum(overrides?: CallOverrides): Promise<BigNumber>;

    principal(overrides?: CallOverrides): Promise<BigNumber>;

    protocolFeeBps(overrides?: CallOverrides): Promise<BigNumber>;

    safeTransfer(
      to: string,
      tokenID: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    'safeTransferFrom(address,address,uint256)'(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    'safeTransferFrom(address,address,uint256,bytes)'(
      from: string,
      to: string,
      tokenId: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    setAddresses(
      solace_: string,
      xsLocker_: string,
      pool_: string,
      dao_: string,
      principal_: string,
      isPermittable_: boolean,
      bondDepo_: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    setFees(protocolFee: BigNumberish, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    setPendingGovernance(
      pendingGovernance_: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    setTerms(
      terms: BondTellerErc20.TermsStruct,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    solace(overrides?: CallOverrides): Promise<BigNumber>;

    startTime(overrides?: CallOverrides): Promise<BigNumber>;

    supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    symbol(overrides?: CallOverrides): Promise<BigNumber>;

    termsSet(overrides?: CallOverrides): Promise<BigNumber>;

    tokenByIndex(index: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    tokenOfOwnerByIndex(owner: string, index: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    tokenURI(tokenID: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    transfer(
      to: string,
      tokenID: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    transferFrom(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    underwritingPool(overrides?: CallOverrides): Promise<BigNumber>;

    unpause(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    xsLocker(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    acceptGovernance(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    approve(
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    balanceOf(owner: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    baseURI(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bondDepo(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bondPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bonds(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    calculateAmountIn(
      amountOut: BigNumberish,
      stake: boolean,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    calculateAmountOut(
      amountIn: BigNumberish,
      stake: boolean,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    calculateMinimalProxyDeploymentAddress(salt: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    capacity(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    capacityIsPayout(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    claimPayout(
      bondID: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    clone(
      name_: string,
      governance_: string,
      principal_: string,
      isPermittable_: boolean,
      salt_: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    dao(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    deposit(
      amount: BigNumberish,
      minAmountOut: BigNumberish,
      depositor: string,
      stake: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    depositSigned(
      amount: BigNumberish,
      minAmountOut: BigNumberish,
      depositor: string,
      stake: boolean,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    endTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    exists(tokenID: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getApproved(tokenId: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    globalVestingTerm(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    governance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    governanceIsLocked(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    halfLife(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initialize(
      name_: string,
      governance_: string,
      solace_: string,
      xsLocker_: string,
      pool_: string,
      dao_: string,
      principal_: string,
      isPermittable_: boolean,
      bondDepo_: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    isApprovedForAll(owner: string, operator: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isPermittable(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastPriceUpdate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lockGovernance(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    maxPayout(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minimumPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nextPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nonces(tokenID: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    numBonds(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pause(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingGovernance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    permit(
      spender: string,
      tokenID: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    priceAdjDenom(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    priceAdjNum(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    principal(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    protocolFeeBps(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    safeTransfer(
      to: string,
      tokenID: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    'safeTransferFrom(address,address,uint256)'(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    'safeTransferFrom(address,address,uint256,bytes)'(
      from: string,
      to: string,
      tokenId: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    setAddresses(
      solace_: string,
      xsLocker_: string,
      pool_: string,
      dao_: string,
      principal_: string,
      isPermittable_: boolean,
      bondDepo_: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    setFees(
      protocolFee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    setPendingGovernance(
      pendingGovernance_: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    setTerms(
      terms: BondTellerErc20.TermsStruct,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    solace(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    startTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    termsSet(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokenByIndex(index: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokenOfOwnerByIndex(owner: string, index: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokenURI(tokenID: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transfer(
      to: string,
      tokenID: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    transferFrom(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    underwritingPool(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    unpause(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    xsLocker(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}

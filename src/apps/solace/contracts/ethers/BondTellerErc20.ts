/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export declare namespace BondTellerErc20 {
  export type TermsStruct = {
    startPrice: PromiseOrValue<BigNumberish>;
    minimumPrice: PromiseOrValue<BigNumberish>;
    maxPayout: PromiseOrValue<BigNumberish>;
    priceAdjNum: PromiseOrValue<BigNumberish>;
    priceAdjDenom: PromiseOrValue<BigNumberish>;
    capacity: PromiseOrValue<BigNumberish>;
    capacityIsPayout: PromiseOrValue<boolean>;
    startTime: PromiseOrValue<BigNumberish>;
    endTime: PromiseOrValue<BigNumberish>;
    globalVestingTerm: PromiseOrValue<BigNumberish>;
    halfLife: PromiseOrValue<BigNumberish>;
  };

  export type TermsStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean,
    number,
    number,
    number,
    number,
  ] & {
    startPrice: BigNumber;
    minimumPrice: BigNumber;
    maxPayout: BigNumber;
    priceAdjNum: BigNumber;
    priceAdjDenom: BigNumber;
    capacity: BigNumber;
    capacityIsPayout: boolean;
    startTime: number;
    endTime: number;
    globalVestingTerm: number;
    halfLife: number;
  };
}

export interface BondTellerErc20Interface extends utils.Interface {
  functions: {
    'DOMAIN_SEPARATOR()': FunctionFragment;
    'PERMIT_TYPEHASH()': FunctionFragment;
    'acceptGovernance()': FunctionFragment;
    'approve(address,uint256)': FunctionFragment;
    'balanceOf(address)': FunctionFragment;
    'baseURI()': FunctionFragment;
    'bondDepo()': FunctionFragment;
    'bondPrice()': FunctionFragment;
    'bonds(uint256)': FunctionFragment;
    'calculateAmountIn(uint256,bool)': FunctionFragment;
    'calculateAmountOut(uint256,bool)': FunctionFragment;
    'calculateMinimalProxyDeploymentAddress(bytes32)': FunctionFragment;
    'capacity()': FunctionFragment;
    'capacityIsPayout()': FunctionFragment;
    'claimPayout(uint256)': FunctionFragment;
    'clone(string,address,address,bool,bytes32)': FunctionFragment;
    'dao()': FunctionFragment;
    'deposit(uint256,uint256,address,bool)': FunctionFragment;
    'depositSigned(uint256,uint256,address,bool,uint256,uint8,bytes32,bytes32)': FunctionFragment;
    'endTime()': FunctionFragment;
    'exists(uint256)': FunctionFragment;
    'getApproved(uint256)': FunctionFragment;
    'globalVestingTerm()': FunctionFragment;
    'governance()': FunctionFragment;
    'governanceIsLocked()': FunctionFragment;
    'halfLife()': FunctionFragment;
    'initialize(string,address,address,address,address,address,address,bool,address)': FunctionFragment;
    'isApprovedForAll(address,address)': FunctionFragment;
    'isPermittable()': FunctionFragment;
    'lastPriceUpdate()': FunctionFragment;
    'lockGovernance()': FunctionFragment;
    'maxPayout()': FunctionFragment;
    'minimumPrice()': FunctionFragment;
    'name()': FunctionFragment;
    'nextPrice()': FunctionFragment;
    'nonces(uint256)': FunctionFragment;
    'numBonds()': FunctionFragment;
    'ownerOf(uint256)': FunctionFragment;
    'pause()': FunctionFragment;
    'paused()': FunctionFragment;
    'pendingGovernance()': FunctionFragment;
    'permit(address,uint256,uint256,uint8,bytes32,bytes32)': FunctionFragment;
    'priceAdjDenom()': FunctionFragment;
    'priceAdjNum()': FunctionFragment;
    'principal()': FunctionFragment;
    'protocolFeeBps()': FunctionFragment;
    'safeTransfer(address,uint256)': FunctionFragment;
    'safeTransferFrom(address,address,uint256)': FunctionFragment;
    'safeTransferFrom(address,address,uint256,bytes)': FunctionFragment;
    'setAddresses(address,address,address,address,address,bool,address)': FunctionFragment;
    'setApprovalForAll(address,bool)': FunctionFragment;
    'setFees(uint256)': FunctionFragment;
    'setPendingGovernance(address)': FunctionFragment;
    'setTerms((uint256,uint256,uint256,uint128,uint128,uint256,bool,uint40,uint40,uint40,uint40))': FunctionFragment;
    'solace()': FunctionFragment;
    'startTime()': FunctionFragment;
    'supportsInterface(bytes4)': FunctionFragment;
    'symbol()': FunctionFragment;
    'termsSet()': FunctionFragment;
    'tokenByIndex(uint256)': FunctionFragment;
    'tokenOfOwnerByIndex(address,uint256)': FunctionFragment;
    'tokenURI(uint256)': FunctionFragment;
    'totalSupply()': FunctionFragment;
    'transfer(address,uint256)': FunctionFragment;
    'transferFrom(address,address,uint256)': FunctionFragment;
    'underwritingPool()': FunctionFragment;
    'unpause()': FunctionFragment;
    'xsLocker()': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'DOMAIN_SEPARATOR'
      | 'PERMIT_TYPEHASH'
      | 'acceptGovernance'
      | 'approve'
      | 'balanceOf'
      | 'baseURI'
      | 'bondDepo'
      | 'bondPrice'
      | 'bonds'
      | 'calculateAmountIn'
      | 'calculateAmountOut'
      | 'calculateMinimalProxyDeploymentAddress'
      | 'capacity'
      | 'capacityIsPayout'
      | 'claimPayout'
      | 'clone'
      | 'dao'
      | 'deposit'
      | 'depositSigned'
      | 'endTime'
      | 'exists'
      | 'getApproved'
      | 'globalVestingTerm'
      | 'governance'
      | 'governanceIsLocked'
      | 'halfLife'
      | 'initialize'
      | 'isApprovedForAll'
      | 'isPermittable'
      | 'lastPriceUpdate'
      | 'lockGovernance'
      | 'maxPayout'
      | 'minimumPrice'
      | 'name'
      | 'nextPrice'
      | 'nonces'
      | 'numBonds'
      | 'ownerOf'
      | 'pause'
      | 'paused'
      | 'pendingGovernance'
      | 'permit'
      | 'priceAdjDenom'
      | 'priceAdjNum'
      | 'principal'
      | 'protocolFeeBps'
      | 'safeTransfer'
      | 'safeTransferFrom(address,address,uint256)'
      | 'safeTransferFrom(address,address,uint256,bytes)'
      | 'setAddresses'
      | 'setApprovalForAll'
      | 'setFees'
      | 'setPendingGovernance'
      | 'setTerms'
      | 'solace'
      | 'startTime'
      | 'supportsInterface'
      | 'symbol'
      | 'termsSet'
      | 'tokenByIndex'
      | 'tokenOfOwnerByIndex'
      | 'tokenURI'
      | 'totalSupply'
      | 'transfer'
      | 'transferFrom'
      | 'underwritingPool'
      | 'unpause'
      | 'xsLocker',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'DOMAIN_SEPARATOR', values?: undefined): string;
  encodeFunctionData(functionFragment: 'PERMIT_TYPEHASH', values?: undefined): string;
  encodeFunctionData(functionFragment: 'acceptGovernance', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'approve',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'balanceOf', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'baseURI', values?: undefined): string;
  encodeFunctionData(functionFragment: 'bondDepo', values?: undefined): string;
  encodeFunctionData(functionFragment: 'bondPrice', values?: undefined): string;
  encodeFunctionData(functionFragment: 'bonds', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'calculateAmountIn',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'calculateAmountOut',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'calculateMinimalProxyDeploymentAddress',
    values: [PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(functionFragment: 'capacity', values?: undefined): string;
  encodeFunctionData(functionFragment: 'capacityIsPayout', values?: undefined): string;
  encodeFunctionData(functionFragment: 'claimPayout', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'clone',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'dao', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'deposit',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'depositSigned',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'endTime', values?: undefined): string;
  encodeFunctionData(functionFragment: 'exists', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getApproved', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'globalVestingTerm', values?: undefined): string;
  encodeFunctionData(functionFragment: 'governance', values?: undefined): string;
  encodeFunctionData(functionFragment: 'governanceIsLocked', values?: undefined): string;
  encodeFunctionData(functionFragment: 'halfLife', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'initialize',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<string>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'isApprovedForAll',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'isPermittable', values?: undefined): string;
  encodeFunctionData(functionFragment: 'lastPriceUpdate', values?: undefined): string;
  encodeFunctionData(functionFragment: 'lockGovernance', values?: undefined): string;
  encodeFunctionData(functionFragment: 'maxPayout', values?: undefined): string;
  encodeFunctionData(functionFragment: 'minimumPrice', values?: undefined): string;
  encodeFunctionData(functionFragment: 'name', values?: undefined): string;
  encodeFunctionData(functionFragment: 'nextPrice', values?: undefined): string;
  encodeFunctionData(functionFragment: 'nonces', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'numBonds', values?: undefined): string;
  encodeFunctionData(functionFragment: 'ownerOf', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'pause', values?: undefined): string;
  encodeFunctionData(functionFragment: 'paused', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pendingGovernance', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'permit',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'priceAdjDenom', values?: undefined): string;
  encodeFunctionData(functionFragment: 'priceAdjNum', values?: undefined): string;
  encodeFunctionData(functionFragment: 'principal', values?: undefined): string;
  encodeFunctionData(functionFragment: 'protocolFeeBps', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'safeTransfer',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'safeTransferFrom(address,address,uint256)',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'safeTransferFrom(address,address,uint256,bytes)',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setAddresses',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<string>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'setApprovalForAll',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'setFees', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setPendingGovernance', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setTerms', values: [BondTellerErc20.TermsStruct]): string;
  encodeFunctionData(functionFragment: 'solace', values?: undefined): string;
  encodeFunctionData(functionFragment: 'startTime', values?: undefined): string;
  encodeFunctionData(functionFragment: 'supportsInterface', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(functionFragment: 'symbol', values?: undefined): string;
  encodeFunctionData(functionFragment: 'termsSet', values?: undefined): string;
  encodeFunctionData(functionFragment: 'tokenByIndex', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'tokenOfOwnerByIndex',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'tokenURI', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'totalSupply', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'transfer',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'transferFrom',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'underwritingPool', values?: undefined): string;
  encodeFunctionData(functionFragment: 'unpause', values?: undefined): string;
  encodeFunctionData(functionFragment: 'xsLocker', values?: undefined): string;

  decodeFunctionResult(functionFragment: 'DOMAIN_SEPARATOR', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'PERMIT_TYPEHASH', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'acceptGovernance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'approve', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'baseURI', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'bondDepo', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'bondPrice', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'bonds', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'calculateAmountIn', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'calculateAmountOut', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'calculateMinimalProxyDeploymentAddress', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'capacity', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'capacityIsPayout', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimPayout', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'clone', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'dao', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'depositSigned', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'endTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exists', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getApproved', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'globalVestingTerm', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'governance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'governanceIsLocked', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'halfLife', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isApprovedForAll', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isPermittable', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lastPriceUpdate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lockGovernance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'maxPayout', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'minimumPrice', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'name', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nextPrice', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nonces', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'numBonds', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'ownerOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pause', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'paused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pendingGovernance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'permit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'priceAdjDenom', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'priceAdjNum', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'principal', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'protocolFeeBps', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'safeTransfer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'safeTransferFrom(address,address,uint256)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'safeTransferFrom(address,address,uint256,bytes)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setAddresses', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setApprovalForAll', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setFees', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setPendingGovernance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setTerms', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'solace', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'startTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'supportsInterface', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'symbol', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'termsSet', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tokenByIndex', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tokenOfOwnerByIndex', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tokenURI', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalSupply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transfer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferFrom', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'underwritingPool', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'unpause', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'xsLocker', data: BytesLike): Result;

  events: {
    'AddressesSet()': EventFragment;
    'Approval(address,address,uint256)': EventFragment;
    'ApprovalForAll(address,address,bool)': EventFragment;
    'BaseURISet(string)': EventFragment;
    'ContractDeployed(address)': EventFragment;
    'CreateBond(uint256,uint256,uint256,uint40,uint40)': EventFragment;
    'FeesSet()': EventFragment;
    'GovernanceLocked()': EventFragment;
    'GovernancePending(address)': EventFragment;
    'GovernanceTransferred(address,address)': EventFragment;
    'Paused()': EventFragment;
    'RedeemBond(uint256,address,uint256)': EventFragment;
    'TermsSet()': EventFragment;
    'Transfer(address,address,uint256)': EventFragment;
    'Unpaused()': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'AddressesSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Approval'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ApprovalForAll'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'BaseURISet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ContractDeployed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CreateBond'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'FeesSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'GovernanceLocked'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'GovernancePending'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'GovernanceTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Paused'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RedeemBond'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TermsSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Transfer'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Unpaused'): EventFragment;
}

export interface AddressesSetEventObject {}
export type AddressesSetEvent = TypedEvent<[], AddressesSetEventObject>;

export type AddressesSetEventFilter = TypedEventFilter<AddressesSetEvent>;

export interface ApprovalEventObject {
  owner: string;
  approved: string;
  tokenId: BigNumber;
}
export type ApprovalEvent = TypedEvent<[string, string, BigNumber], ApprovalEventObject>;

export type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;

export interface ApprovalForAllEventObject {
  owner: string;
  operator: string;
  approved: boolean;
}
export type ApprovalForAllEvent = TypedEvent<[string, string, boolean], ApprovalForAllEventObject>;

export type ApprovalForAllEventFilter = TypedEventFilter<ApprovalForAllEvent>;

export interface BaseURISetEventObject {
  baseURI: string;
}
export type BaseURISetEvent = TypedEvent<[string], BaseURISetEventObject>;

export type BaseURISetEventFilter = TypedEventFilter<BaseURISetEvent>;

export interface ContractDeployedEventObject {
  deployment: string;
}
export type ContractDeployedEvent = TypedEvent<[string], ContractDeployedEventObject>;

export type ContractDeployedEventFilter = TypedEventFilter<ContractDeployedEvent>;

export interface CreateBondEventObject {
  lockID: BigNumber;
  principalAmount: BigNumber;
  payoutAmount: BigNumber;
  vestingStart: number;
  vestingTime: number;
}
export type CreateBondEvent = TypedEvent<[BigNumber, BigNumber, BigNumber, number, number], CreateBondEventObject>;

export type CreateBondEventFilter = TypedEventFilter<CreateBondEvent>;

export interface FeesSetEventObject {}
export type FeesSetEvent = TypedEvent<[], FeesSetEventObject>;

export type FeesSetEventFilter = TypedEventFilter<FeesSetEvent>;

export interface GovernanceLockedEventObject {}
export type GovernanceLockedEvent = TypedEvent<[], GovernanceLockedEventObject>;

export type GovernanceLockedEventFilter = TypedEventFilter<GovernanceLockedEvent>;

export interface GovernancePendingEventObject {
  pendingGovernance: string;
}
export type GovernancePendingEvent = TypedEvent<[string], GovernancePendingEventObject>;

export type GovernancePendingEventFilter = TypedEventFilter<GovernancePendingEvent>;

export interface GovernanceTransferredEventObject {
  oldGovernance: string;
  newGovernance: string;
}
export type GovernanceTransferredEvent = TypedEvent<[string, string], GovernanceTransferredEventObject>;

export type GovernanceTransferredEventFilter = TypedEventFilter<GovernanceTransferredEvent>;

export interface PausedEventObject {}
export type PausedEvent = TypedEvent<[], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface RedeemBondEventObject {
  bondID: BigNumber;
  recipient: string;
  payoutAmount: BigNumber;
}
export type RedeemBondEvent = TypedEvent<[BigNumber, string, BigNumber], RedeemBondEventObject>;

export type RedeemBondEventFilter = TypedEventFilter<RedeemBondEvent>;

export interface TermsSetEventObject {}
export type TermsSetEvent = TypedEvent<[], TermsSetEventObject>;

export type TermsSetEventFilter = TypedEventFilter<TermsSetEvent>;

export interface TransferEventObject {
  from: string;
  to: string;
  tokenId: BigNumber;
}
export type TransferEvent = TypedEvent<[string, string, BigNumber], TransferEventObject>;

export type TransferEventFilter = TypedEventFilter<TransferEvent>;

export interface UnpausedEventObject {}
export type UnpausedEvent = TypedEvent<[], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface BondTellerErc20 extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: BondTellerErc20Interface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string] & { seperator: string }>;

    PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<[string] & { typehash: string }>;

    acceptGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    approve(
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    balanceOf(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    baseURI(overrides?: CallOverrides): Promise<[string]>;

    bondDepo(overrides?: CallOverrides): Promise<[string]>;

    bondPrice(overrides?: CallOverrides): Promise<[BigNumber] & { price_: BigNumber }>;

    bonds(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, number, number] & {
        payoutAmount: BigNumber;
        payoutAlreadyClaimed: BigNumber;
        principalPaid: BigNumber;
        vestingStart: number;
        localVestingTerm: number;
      }
    >;

    calculateAmountIn(
      amountOut: PromiseOrValue<BigNumberish>,
      stake: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { amountIn: BigNumber }>;

    calculateAmountOut(
      amountIn: PromiseOrValue<BigNumberish>,
      stake: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { amountOut: BigNumber }>;

    calculateMinimalProxyDeploymentAddress(
      salt: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<[string]>;

    capacity(overrides?: CallOverrides): Promise<[BigNumber]>;

    capacityIsPayout(overrides?: CallOverrides): Promise<[boolean]>;

    claimPayout(
      bondID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    clone(
      name_: PromiseOrValue<string>,
      governance_: PromiseOrValue<string>,
      principal_: PromiseOrValue<string>,
      isPermittable_: PromiseOrValue<boolean>,
      salt_: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    dao(overrides?: CallOverrides): Promise<[string]>;

    deposit(
      amount: PromiseOrValue<BigNumberish>,
      minAmountOut: PromiseOrValue<BigNumberish>,
      depositor: PromiseOrValue<string>,
      stake: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    depositSigned(
      amount: PromiseOrValue<BigNumberish>,
      minAmountOut: PromiseOrValue<BigNumberish>,
      depositor: PromiseOrValue<string>,
      stake: PromiseOrValue<boolean>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    endTime(overrides?: CallOverrides): Promise<[number]>;

    exists(tokenID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[boolean] & { status: boolean }>;

    getApproved(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    globalVestingTerm(overrides?: CallOverrides): Promise<[number]>;

    governance(overrides?: CallOverrides): Promise<[string]>;

    governanceIsLocked(overrides?: CallOverrides): Promise<[boolean]>;

    halfLife(overrides?: CallOverrides): Promise<[BigNumber]>;

    initialize(
      name_: PromiseOrValue<string>,
      governance_: PromiseOrValue<string>,
      solace_: PromiseOrValue<string>,
      xsLocker_: PromiseOrValue<string>,
      pool_: PromiseOrValue<string>,
      dao_: PromiseOrValue<string>,
      principal_: PromiseOrValue<string>,
      isPermittable_: PromiseOrValue<boolean>,
      bondDepo_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    isApprovedForAll(
      owner: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    isPermittable(overrides?: CallOverrides): Promise<[boolean]>;

    lastPriceUpdate(overrides?: CallOverrides): Promise<[BigNumber]>;

    lockGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    maxPayout(overrides?: CallOverrides): Promise<[BigNumber]>;

    minimumPrice(overrides?: CallOverrides): Promise<[BigNumber]>;

    name(overrides?: CallOverrides): Promise<[string]>;

    nextPrice(overrides?: CallOverrides): Promise<[BigNumber]>;

    nonces(
      tokenID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { nonce: BigNumber }>;

    numBonds(overrides?: CallOverrides): Promise<[BigNumber]>;

    ownerOf(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    pendingGovernance(overrides?: CallOverrides): Promise<[string]>;

    permit(
      spender: PromiseOrValue<string>,
      tokenID: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    priceAdjDenom(overrides?: CallOverrides): Promise<[BigNumber]>;

    priceAdjNum(overrides?: CallOverrides): Promise<[BigNumber]>;

    principal(overrides?: CallOverrides): Promise<[string]>;

    protocolFeeBps(overrides?: CallOverrides): Promise<[BigNumber]>;

    safeTransfer(
      to: PromiseOrValue<string>,
      tokenID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'safeTransferFrom(address,address,uint256)'(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'safeTransferFrom(address,address,uint256,bytes)'(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      _data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setAddresses(
      solace_: PromiseOrValue<string>,
      xsLocker_: PromiseOrValue<string>,
      pool_: PromiseOrValue<string>,
      dao_: PromiseOrValue<string>,
      principal_: PromiseOrValue<string>,
      isPermittable_: PromiseOrValue<boolean>,
      bondDepo_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setFees(
      protocolFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setPendingGovernance(
      pendingGovernance_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setTerms(
      terms: BondTellerErc20.TermsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    solace(overrides?: CallOverrides): Promise<[string]>;

    startTime(overrides?: CallOverrides): Promise<[number]>;

    supportsInterface(interfaceId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[boolean]>;

    symbol(overrides?: CallOverrides): Promise<[string]>;

    termsSet(overrides?: CallOverrides): Promise<[boolean]>;

    tokenByIndex(index: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    tokenOfOwnerByIndex(
      owner: PromiseOrValue<string>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    tokenURI(tokenID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    transfer(
      to: PromiseOrValue<string>,
      tokenID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    transferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    underwritingPool(overrides?: CallOverrides): Promise<[string]>;

    unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    xsLocker(overrides?: CallOverrides): Promise<[string]>;
  };

  DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

  PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  acceptGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  approve(
    to: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  balanceOf(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  baseURI(overrides?: CallOverrides): Promise<string>;

  bondDepo(overrides?: CallOverrides): Promise<string>;

  bondPrice(overrides?: CallOverrides): Promise<BigNumber>;

  bonds(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber, number, number] & {
      payoutAmount: BigNumber;
      payoutAlreadyClaimed: BigNumber;
      principalPaid: BigNumber;
      vestingStart: number;
      localVestingTerm: number;
    }
  >;

  calculateAmountIn(
    amountOut: PromiseOrValue<BigNumberish>,
    stake: PromiseOrValue<boolean>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  calculateAmountOut(
    amountIn: PromiseOrValue<BigNumberish>,
    stake: PromiseOrValue<boolean>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  calculateMinimalProxyDeploymentAddress(salt: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

  capacity(overrides?: CallOverrides): Promise<BigNumber>;

  capacityIsPayout(overrides?: CallOverrides): Promise<boolean>;

  claimPayout(
    bondID: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  clone(
    name_: PromiseOrValue<string>,
    governance_: PromiseOrValue<string>,
    principal_: PromiseOrValue<string>,
    isPermittable_: PromiseOrValue<boolean>,
    salt_: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  dao(overrides?: CallOverrides): Promise<string>;

  deposit(
    amount: PromiseOrValue<BigNumberish>,
    minAmountOut: PromiseOrValue<BigNumberish>,
    depositor: PromiseOrValue<string>,
    stake: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  depositSigned(
    amount: PromiseOrValue<BigNumberish>,
    minAmountOut: PromiseOrValue<BigNumberish>,
    depositor: PromiseOrValue<string>,
    stake: PromiseOrValue<boolean>,
    deadline: PromiseOrValue<BigNumberish>,
    v: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    s: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  endTime(overrides?: CallOverrides): Promise<number>;

  exists(tokenID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>;

  getApproved(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  globalVestingTerm(overrides?: CallOverrides): Promise<number>;

  governance(overrides?: CallOverrides): Promise<string>;

  governanceIsLocked(overrides?: CallOverrides): Promise<boolean>;

  halfLife(overrides?: CallOverrides): Promise<BigNumber>;

  initialize(
    name_: PromiseOrValue<string>,
    governance_: PromiseOrValue<string>,
    solace_: PromiseOrValue<string>,
    xsLocker_: PromiseOrValue<string>,
    pool_: PromiseOrValue<string>,
    dao_: PromiseOrValue<string>,
    principal_: PromiseOrValue<string>,
    isPermittable_: PromiseOrValue<boolean>,
    bondDepo_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  isApprovedForAll(
    owner: PromiseOrValue<string>,
    operator: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  isPermittable(overrides?: CallOverrides): Promise<boolean>;

  lastPriceUpdate(overrides?: CallOverrides): Promise<BigNumber>;

  lockGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  maxPayout(overrides?: CallOverrides): Promise<BigNumber>;

  minimumPrice(overrides?: CallOverrides): Promise<BigNumber>;

  name(overrides?: CallOverrides): Promise<string>;

  nextPrice(overrides?: CallOverrides): Promise<BigNumber>;

  nonces(tokenID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  numBonds(overrides?: CallOverrides): Promise<BigNumber>;

  ownerOf(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  pendingGovernance(overrides?: CallOverrides): Promise<string>;

  permit(
    spender: PromiseOrValue<string>,
    tokenID: PromiseOrValue<BigNumberish>,
    deadline: PromiseOrValue<BigNumberish>,
    v: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    s: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  priceAdjDenom(overrides?: CallOverrides): Promise<BigNumber>;

  priceAdjNum(overrides?: CallOverrides): Promise<BigNumber>;

  principal(overrides?: CallOverrides): Promise<string>;

  protocolFeeBps(overrides?: CallOverrides): Promise<BigNumber>;

  safeTransfer(
    to: PromiseOrValue<string>,
    tokenID: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'safeTransferFrom(address,address,uint256)'(
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'safeTransferFrom(address,address,uint256,bytes)'(
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    _data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setAddresses(
    solace_: PromiseOrValue<string>,
    xsLocker_: PromiseOrValue<string>,
    pool_: PromiseOrValue<string>,
    dao_: PromiseOrValue<string>,
    principal_: PromiseOrValue<string>,
    isPermittable_: PromiseOrValue<boolean>,
    bondDepo_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setApprovalForAll(
    operator: PromiseOrValue<string>,
    approved: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setFees(
    protocolFee: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setPendingGovernance(
    pendingGovernance_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setTerms(
    terms: BondTellerErc20.TermsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  solace(overrides?: CallOverrides): Promise<string>;

  startTime(overrides?: CallOverrides): Promise<number>;

  supportsInterface(interfaceId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;

  symbol(overrides?: CallOverrides): Promise<string>;

  termsSet(overrides?: CallOverrides): Promise<boolean>;

  tokenByIndex(index: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  tokenOfOwnerByIndex(
    owner: PromiseOrValue<string>,
    index: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  tokenURI(tokenID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  transfer(
    to: PromiseOrValue<string>,
    tokenID: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  transferFrom(
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  underwritingPool(overrides?: CallOverrides): Promise<string>;

  unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  xsLocker(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

    PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    acceptGovernance(overrides?: CallOverrides): Promise<void>;

    approve(
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    balanceOf(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    baseURI(overrides?: CallOverrides): Promise<string>;

    bondDepo(overrides?: CallOverrides): Promise<string>;

    bondPrice(overrides?: CallOverrides): Promise<BigNumber>;

    bonds(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, number, number] & {
        payoutAmount: BigNumber;
        payoutAlreadyClaimed: BigNumber;
        principalPaid: BigNumber;
        vestingStart: number;
        localVestingTerm: number;
      }
    >;

    calculateAmountIn(
      amountOut: PromiseOrValue<BigNumberish>,
      stake: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    calculateAmountOut(
      amountIn: PromiseOrValue<BigNumberish>,
      stake: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    calculateMinimalProxyDeploymentAddress(salt: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

    capacity(overrides?: CallOverrides): Promise<BigNumber>;

    capacityIsPayout(overrides?: CallOverrides): Promise<boolean>;

    claimPayout(bondID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    clone(
      name_: PromiseOrValue<string>,
      governance_: PromiseOrValue<string>,
      principal_: PromiseOrValue<string>,
      isPermittable_: PromiseOrValue<boolean>,
      salt_: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<string>;

    dao(overrides?: CallOverrides): Promise<string>;

    deposit(
      amount: PromiseOrValue<BigNumberish>,
      minAmountOut: PromiseOrValue<BigNumberish>,
      depositor: PromiseOrValue<string>,
      stake: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { payout: BigNumber; tokenID: BigNumber }>;

    depositSigned(
      amount: PromiseOrValue<BigNumberish>,
      minAmountOut: PromiseOrValue<BigNumberish>,
      depositor: PromiseOrValue<string>,
      stake: PromiseOrValue<boolean>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { payout: BigNumber; tokenID: BigNumber }>;

    endTime(overrides?: CallOverrides): Promise<number>;

    exists(tokenID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>;

    getApproved(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    globalVestingTerm(overrides?: CallOverrides): Promise<number>;

    governance(overrides?: CallOverrides): Promise<string>;

    governanceIsLocked(overrides?: CallOverrides): Promise<boolean>;

    halfLife(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      name_: PromiseOrValue<string>,
      governance_: PromiseOrValue<string>,
      solace_: PromiseOrValue<string>,
      xsLocker_: PromiseOrValue<string>,
      pool_: PromiseOrValue<string>,
      dao_: PromiseOrValue<string>,
      principal_: PromiseOrValue<string>,
      isPermittable_: PromiseOrValue<boolean>,
      bondDepo_: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    isApprovedForAll(
      owner: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    isPermittable(overrides?: CallOverrides): Promise<boolean>;

    lastPriceUpdate(overrides?: CallOverrides): Promise<BigNumber>;

    lockGovernance(overrides?: CallOverrides): Promise<void>;

    maxPayout(overrides?: CallOverrides): Promise<BigNumber>;

    minimumPrice(overrides?: CallOverrides): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<string>;

    nextPrice(overrides?: CallOverrides): Promise<BigNumber>;

    nonces(tokenID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    numBonds(overrides?: CallOverrides): Promise<BigNumber>;

    ownerOf(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    pause(overrides?: CallOverrides): Promise<void>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    pendingGovernance(overrides?: CallOverrides): Promise<string>;

    permit(
      spender: PromiseOrValue<string>,
      tokenID: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    priceAdjDenom(overrides?: CallOverrides): Promise<BigNumber>;

    priceAdjNum(overrides?: CallOverrides): Promise<BigNumber>;

    principal(overrides?: CallOverrides): Promise<string>;

    protocolFeeBps(overrides?: CallOverrides): Promise<BigNumber>;

    safeTransfer(
      to: PromiseOrValue<string>,
      tokenID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    'safeTransferFrom(address,address,uint256)'(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    'safeTransferFrom(address,address,uint256,bytes)'(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      _data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setAddresses(
      solace_: PromiseOrValue<string>,
      xsLocker_: PromiseOrValue<string>,
      pool_: PromiseOrValue<string>,
      dao_: PromiseOrValue<string>,
      principal_: PromiseOrValue<string>,
      isPermittable_: PromiseOrValue<boolean>,
      bondDepo_: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setFees(protocolFee: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setPendingGovernance(pendingGovernance_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setTerms(terms: BondTellerErc20.TermsStruct, overrides?: CallOverrides): Promise<void>;

    solace(overrides?: CallOverrides): Promise<string>;

    startTime(overrides?: CallOverrides): Promise<number>;

    supportsInterface(interfaceId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;

    symbol(overrides?: CallOverrides): Promise<string>;

    termsSet(overrides?: CallOverrides): Promise<boolean>;

    tokenByIndex(index: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    tokenOfOwnerByIndex(
      owner: PromiseOrValue<string>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    tokenURI(tokenID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    transfer(
      to: PromiseOrValue<string>,
      tokenID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    transferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    underwritingPool(overrides?: CallOverrides): Promise<string>;

    unpause(overrides?: CallOverrides): Promise<void>;

    xsLocker(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    'AddressesSet()'(): AddressesSetEventFilter;
    AddressesSet(): AddressesSetEventFilter;

    'Approval(address,address,uint256)'(
      owner?: PromiseOrValue<string> | null,
      approved?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null,
    ): ApprovalEventFilter;
    Approval(
      owner?: PromiseOrValue<string> | null,
      approved?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null,
    ): ApprovalEventFilter;

    'ApprovalForAll(address,address,bool)'(
      owner?: PromiseOrValue<string> | null,
      operator?: PromiseOrValue<string> | null,
      approved?: null,
    ): ApprovalForAllEventFilter;
    ApprovalForAll(
      owner?: PromiseOrValue<string> | null,
      operator?: PromiseOrValue<string> | null,
      approved?: null,
    ): ApprovalForAllEventFilter;

    'BaseURISet(string)'(baseURI?: null): BaseURISetEventFilter;
    BaseURISet(baseURI?: null): BaseURISetEventFilter;

    'ContractDeployed(address)'(deployment?: PromiseOrValue<string> | null): ContractDeployedEventFilter;
    ContractDeployed(deployment?: PromiseOrValue<string> | null): ContractDeployedEventFilter;

    'CreateBond(uint256,uint256,uint256,uint40,uint40)'(
      lockID?: PromiseOrValue<BigNumberish> | null,
      principalAmount?: null,
      payoutAmount?: null,
      vestingStart?: null,
      vestingTime?: null,
    ): CreateBondEventFilter;
    CreateBond(
      lockID?: PromiseOrValue<BigNumberish> | null,
      principalAmount?: null,
      payoutAmount?: null,
      vestingStart?: null,
      vestingTime?: null,
    ): CreateBondEventFilter;

    'FeesSet()'(): FeesSetEventFilter;
    FeesSet(): FeesSetEventFilter;

    'GovernanceLocked()'(): GovernanceLockedEventFilter;
    GovernanceLocked(): GovernanceLockedEventFilter;

    'GovernancePending(address)'(pendingGovernance?: null): GovernancePendingEventFilter;
    GovernancePending(pendingGovernance?: null): GovernancePendingEventFilter;

    'GovernanceTransferred(address,address)'(
      oldGovernance?: null,
      newGovernance?: null,
    ): GovernanceTransferredEventFilter;
    GovernanceTransferred(oldGovernance?: null, newGovernance?: null): GovernanceTransferredEventFilter;

    'Paused()'(): PausedEventFilter;
    Paused(): PausedEventFilter;

    'RedeemBond(uint256,address,uint256)'(
      bondID?: PromiseOrValue<BigNumberish> | null,
      recipient?: null,
      payoutAmount?: null,
    ): RedeemBondEventFilter;
    RedeemBond(
      bondID?: PromiseOrValue<BigNumberish> | null,
      recipient?: null,
      payoutAmount?: null,
    ): RedeemBondEventFilter;

    'TermsSet()'(): TermsSetEventFilter;
    TermsSet(): TermsSetEventFilter;

    'Transfer(address,address,uint256)'(
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null,
    ): TransferEventFilter;
    Transfer(
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null,
    ): TransferEventFilter;

    'Unpaused()'(): UnpausedEventFilter;
    Unpaused(): UnpausedEventFilter;
  };

  estimateGas: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber>;

    PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    acceptGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    approve(
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    balanceOf(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    baseURI(overrides?: CallOverrides): Promise<BigNumber>;

    bondDepo(overrides?: CallOverrides): Promise<BigNumber>;

    bondPrice(overrides?: CallOverrides): Promise<BigNumber>;

    bonds(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    calculateAmountIn(
      amountOut: PromiseOrValue<BigNumberish>,
      stake: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    calculateAmountOut(
      amountIn: PromiseOrValue<BigNumberish>,
      stake: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    calculateMinimalProxyDeploymentAddress(
      salt: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    capacity(overrides?: CallOverrides): Promise<BigNumber>;

    capacityIsPayout(overrides?: CallOverrides): Promise<BigNumber>;

    claimPayout(
      bondID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    clone(
      name_: PromiseOrValue<string>,
      governance_: PromiseOrValue<string>,
      principal_: PromiseOrValue<string>,
      isPermittable_: PromiseOrValue<boolean>,
      salt_: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    dao(overrides?: CallOverrides): Promise<BigNumber>;

    deposit(
      amount: PromiseOrValue<BigNumberish>,
      minAmountOut: PromiseOrValue<BigNumberish>,
      depositor: PromiseOrValue<string>,
      stake: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    depositSigned(
      amount: PromiseOrValue<BigNumberish>,
      minAmountOut: PromiseOrValue<BigNumberish>,
      depositor: PromiseOrValue<string>,
      stake: PromiseOrValue<boolean>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    endTime(overrides?: CallOverrides): Promise<BigNumber>;

    exists(tokenID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getApproved(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    globalVestingTerm(overrides?: CallOverrides): Promise<BigNumber>;

    governance(overrides?: CallOverrides): Promise<BigNumber>;

    governanceIsLocked(overrides?: CallOverrides): Promise<BigNumber>;

    halfLife(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      name_: PromiseOrValue<string>,
      governance_: PromiseOrValue<string>,
      solace_: PromiseOrValue<string>,
      xsLocker_: PromiseOrValue<string>,
      pool_: PromiseOrValue<string>,
      dao_: PromiseOrValue<string>,
      principal_: PromiseOrValue<string>,
      isPermittable_: PromiseOrValue<boolean>,
      bondDepo_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    isApprovedForAll(
      owner: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    isPermittable(overrides?: CallOverrides): Promise<BigNumber>;

    lastPriceUpdate(overrides?: CallOverrides): Promise<BigNumber>;

    lockGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    maxPayout(overrides?: CallOverrides): Promise<BigNumber>;

    minimumPrice(overrides?: CallOverrides): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    nextPrice(overrides?: CallOverrides): Promise<BigNumber>;

    nonces(tokenID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    numBonds(overrides?: CallOverrides): Promise<BigNumber>;

    ownerOf(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    pendingGovernance(overrides?: CallOverrides): Promise<BigNumber>;

    permit(
      spender: PromiseOrValue<string>,
      tokenID: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    priceAdjDenom(overrides?: CallOverrides): Promise<BigNumber>;

    priceAdjNum(overrides?: CallOverrides): Promise<BigNumber>;

    principal(overrides?: CallOverrides): Promise<BigNumber>;

    protocolFeeBps(overrides?: CallOverrides): Promise<BigNumber>;

    safeTransfer(
      to: PromiseOrValue<string>,
      tokenID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'safeTransferFrom(address,address,uint256)'(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'safeTransferFrom(address,address,uint256,bytes)'(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      _data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setAddresses(
      solace_: PromiseOrValue<string>,
      xsLocker_: PromiseOrValue<string>,
      pool_: PromiseOrValue<string>,
      dao_: PromiseOrValue<string>,
      principal_: PromiseOrValue<string>,
      isPermittable_: PromiseOrValue<boolean>,
      bondDepo_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setFees(
      protocolFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setPendingGovernance(
      pendingGovernance_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setTerms(
      terms: BondTellerErc20.TermsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    solace(overrides?: CallOverrides): Promise<BigNumber>;

    startTime(overrides?: CallOverrides): Promise<BigNumber>;

    supportsInterface(interfaceId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    symbol(overrides?: CallOverrides): Promise<BigNumber>;

    termsSet(overrides?: CallOverrides): Promise<BigNumber>;

    tokenByIndex(index: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    tokenOfOwnerByIndex(
      owner: PromiseOrValue<string>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    tokenURI(tokenID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    transfer(
      to: PromiseOrValue<string>,
      tokenID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    transferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    underwritingPool(overrides?: CallOverrides): Promise<BigNumber>;

    unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    xsLocker(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    acceptGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    approve(
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    balanceOf(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    baseURI(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bondDepo(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bondPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bonds(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    calculateAmountIn(
      amountOut: PromiseOrValue<BigNumberish>,
      stake: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    calculateAmountOut(
      amountIn: PromiseOrValue<BigNumberish>,
      stake: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    calculateMinimalProxyDeploymentAddress(
      salt: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    capacity(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    capacityIsPayout(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    claimPayout(
      bondID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    clone(
      name_: PromiseOrValue<string>,
      governance_: PromiseOrValue<string>,
      principal_: PromiseOrValue<string>,
      isPermittable_: PromiseOrValue<boolean>,
      salt_: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    dao(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    deposit(
      amount: PromiseOrValue<BigNumberish>,
      minAmountOut: PromiseOrValue<BigNumberish>,
      depositor: PromiseOrValue<string>,
      stake: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    depositSigned(
      amount: PromiseOrValue<BigNumberish>,
      minAmountOut: PromiseOrValue<BigNumberish>,
      depositor: PromiseOrValue<string>,
      stake: PromiseOrValue<boolean>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    endTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    exists(tokenID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getApproved(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    globalVestingTerm(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    governance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    governanceIsLocked(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    halfLife(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initialize(
      name_: PromiseOrValue<string>,
      governance_: PromiseOrValue<string>,
      solace_: PromiseOrValue<string>,
      xsLocker_: PromiseOrValue<string>,
      pool_: PromiseOrValue<string>,
      dao_: PromiseOrValue<string>,
      principal_: PromiseOrValue<string>,
      isPermittable_: PromiseOrValue<boolean>,
      bondDepo_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    isApprovedForAll(
      owner: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    isPermittable(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastPriceUpdate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lockGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    maxPayout(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minimumPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nextPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nonces(tokenID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    numBonds(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ownerOf(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingGovernance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    permit(
      spender: PromiseOrValue<string>,
      tokenID: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    priceAdjDenom(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    priceAdjNum(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    principal(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    protocolFeeBps(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    safeTransfer(
      to: PromiseOrValue<string>,
      tokenID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'safeTransferFrom(address,address,uint256)'(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'safeTransferFrom(address,address,uint256,bytes)'(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      _data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setAddresses(
      solace_: PromiseOrValue<string>,
      xsLocker_: PromiseOrValue<string>,
      pool_: PromiseOrValue<string>,
      dao_: PromiseOrValue<string>,
      principal_: PromiseOrValue<string>,
      isPermittable_: PromiseOrValue<boolean>,
      bondDepo_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setFees(
      protocolFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setPendingGovernance(
      pendingGovernance_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setTerms(
      terms: BondTellerErc20.TermsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    solace(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    startTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    supportsInterface(interfaceId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    termsSet(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokenByIndex(index: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokenOfOwnerByIndex(
      owner: PromiseOrValue<string>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    tokenURI(tokenID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transfer(
      to: PromiseOrValue<string>,
      tokenID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    transferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    underwritingPool(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    xsLocker(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export type LockStruct = {
  amount: PromiseOrValue<BigNumberish>;
  end: PromiseOrValue<BigNumberish>;
};

export type LockStructOutput = [BigNumber, BigNumber] & {
  amount: BigNumber;
  end: BigNumber;
};

export declare namespace IStakingRewards {
  export type StakedLockInfoStruct = {
    value: PromiseOrValue<BigNumberish>;
    rewardDebt: PromiseOrValue<BigNumberish>;
    unpaidRewards: PromiseOrValue<BigNumberish>;
    owner: PromiseOrValue<string>;
  };

  export type StakedLockInfoStructOutput = [BigNumber, BigNumber, BigNumber, string] & {
    value: BigNumber;
    rewardDebt: BigNumber;
    unpaidRewards: BigNumber;
    owner: string;
  };
}

export interface StakingRewardsInterface extends utils.Interface {
  functions: {
    'MAX_LOCK_DURATION()': FunctionFragment;
    'MAX_LOCK_MULTIPLIER_BPS()': FunctionFragment;
    'UNLOCKED_MULTIPLIER_BPS()': FunctionFragment;
    'accRewardPerShare()': FunctionFragment;
    'acceptGovernance()': FunctionFragment;
    'compoundLock(uint256)': FunctionFragment;
    'compoundLocks(uint256[],uint256)': FunctionFragment;
    'endTime()': FunctionFragment;
    'getRewardAmountDistributed(uint256,uint256)': FunctionFragment;
    'governance()': FunctionFragment;
    'governanceIsLocked()': FunctionFragment;
    'harvestLock(uint256)': FunctionFragment;
    'harvestLocks(uint256[])': FunctionFragment;
    'lastRewardTime()': FunctionFragment;
    'lockGovernance()': FunctionFragment;
    'pendingGovernance()': FunctionFragment;
    'pendingRewardsOfLock(uint256)': FunctionFragment;
    'registerLockEvent(uint256,address,address,(uint256,uint256),(uint256,uint256))': FunctionFragment;
    'rescueTokens(address,uint256,address)': FunctionFragment;
    'rewardPerSecond()': FunctionFragment;
    'setPendingGovernance(address)': FunctionFragment;
    'setRewards(uint256)': FunctionFragment;
    'setTimes(uint256,uint256)': FunctionFragment;
    'solace()': FunctionFragment;
    'stakedLockInfo(uint256)': FunctionFragment;
    'startTime()': FunctionFragment;
    'update()': FunctionFragment;
    'valueStaked()': FunctionFragment;
    'xsLocker()': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'MAX_LOCK_DURATION'
      | 'MAX_LOCK_MULTIPLIER_BPS'
      | 'UNLOCKED_MULTIPLIER_BPS'
      | 'accRewardPerShare'
      | 'acceptGovernance'
      | 'compoundLock'
      | 'compoundLocks'
      | 'endTime'
      | 'getRewardAmountDistributed'
      | 'governance'
      | 'governanceIsLocked'
      | 'harvestLock'
      | 'harvestLocks'
      | 'lastRewardTime'
      | 'lockGovernance'
      | 'pendingGovernance'
      | 'pendingRewardsOfLock'
      | 'registerLockEvent'
      | 'rescueTokens'
      | 'rewardPerSecond'
      | 'setPendingGovernance'
      | 'setRewards'
      | 'setTimes'
      | 'solace'
      | 'stakedLockInfo'
      | 'startTime'
      | 'update'
      | 'valueStaked'
      | 'xsLocker',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'MAX_LOCK_DURATION', values?: undefined): string;
  encodeFunctionData(functionFragment: 'MAX_LOCK_MULTIPLIER_BPS', values?: undefined): string;
  encodeFunctionData(functionFragment: 'UNLOCKED_MULTIPLIER_BPS', values?: undefined): string;
  encodeFunctionData(functionFragment: 'accRewardPerShare', values?: undefined): string;
  encodeFunctionData(functionFragment: 'acceptGovernance', values?: undefined): string;
  encodeFunctionData(functionFragment: 'compoundLock', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'compoundLocks',
    values: [PromiseOrValue<BigNumberish>[], PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'endTime', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'getRewardAmountDistributed',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'governance', values?: undefined): string;
  encodeFunctionData(functionFragment: 'governanceIsLocked', values?: undefined): string;
  encodeFunctionData(functionFragment: 'harvestLock', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'harvestLocks', values: [PromiseOrValue<BigNumberish>[]]): string;
  encodeFunctionData(functionFragment: 'lastRewardTime', values?: undefined): string;
  encodeFunctionData(functionFragment: 'lockGovernance', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pendingGovernance', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pendingRewardsOfLock', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'registerLockEvent',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>, PromiseOrValue<string>, LockStruct, LockStruct],
  ): string;
  encodeFunctionData(
    functionFragment: 'rescueTokens',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'rewardPerSecond', values?: undefined): string;
  encodeFunctionData(functionFragment: 'setPendingGovernance', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setRewards', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'setTimes',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'solace', values?: undefined): string;
  encodeFunctionData(functionFragment: 'stakedLockInfo', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'startTime', values?: undefined): string;
  encodeFunctionData(functionFragment: 'update', values?: undefined): string;
  encodeFunctionData(functionFragment: 'valueStaked', values?: undefined): string;
  encodeFunctionData(functionFragment: 'xsLocker', values?: undefined): string;

  decodeFunctionResult(functionFragment: 'MAX_LOCK_DURATION', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'MAX_LOCK_MULTIPLIER_BPS', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'UNLOCKED_MULTIPLIER_BPS', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'accRewardPerShare', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'acceptGovernance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'compoundLock', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'compoundLocks', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'endTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getRewardAmountDistributed', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'governance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'governanceIsLocked', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'harvestLock', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'harvestLocks', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lastRewardTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lockGovernance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pendingGovernance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pendingRewardsOfLock', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'registerLockEvent', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rescueTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardPerSecond', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setPendingGovernance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setTimes', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'solace', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stakedLockInfo', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'startTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'update', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'valueStaked', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'xsLocker', data: BytesLike): Result;

  events: {
    'FarmTimesSet(uint256,uint256)': EventFragment;
    'GovernanceLocked()': EventFragment;
    'GovernancePending(address)': EventFragment;
    'GovernanceTransferred(address,address)': EventFragment;
    'LockUpdated(uint256)': EventFragment;
    'RewardsSet(uint256)': EventFragment;
    'Updated()': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'FarmTimesSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'GovernanceLocked'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'GovernancePending'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'GovernanceTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LockUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardsSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Updated'): EventFragment;
}

export interface FarmTimesSetEventObject {
  startTime: BigNumber;
  endTime: BigNumber;
}
export type FarmTimesSetEvent = TypedEvent<[BigNumber, BigNumber], FarmTimesSetEventObject>;

export type FarmTimesSetEventFilter = TypedEventFilter<FarmTimesSetEvent>;

export interface GovernanceLockedEventObject {}
export type GovernanceLockedEvent = TypedEvent<[], GovernanceLockedEventObject>;

export type GovernanceLockedEventFilter = TypedEventFilter<GovernanceLockedEvent>;

export interface GovernancePendingEventObject {
  pendingGovernance: string;
}
export type GovernancePendingEvent = TypedEvent<[string], GovernancePendingEventObject>;

export type GovernancePendingEventFilter = TypedEventFilter<GovernancePendingEvent>;

export interface GovernanceTransferredEventObject {
  oldGovernance: string;
  newGovernance: string;
}
export type GovernanceTransferredEvent = TypedEvent<[string, string], GovernanceTransferredEventObject>;

export type GovernanceTransferredEventFilter = TypedEventFilter<GovernanceTransferredEvent>;

export interface LockUpdatedEventObject {
  xsLockID: BigNumber;
}
export type LockUpdatedEvent = TypedEvent<[BigNumber], LockUpdatedEventObject>;

export type LockUpdatedEventFilter = TypedEventFilter<LockUpdatedEvent>;

export interface RewardsSetEventObject {
  rewardPerSecond: BigNumber;
}
export type RewardsSetEvent = TypedEvent<[BigNumber], RewardsSetEventObject>;

export type RewardsSetEventFilter = TypedEventFilter<RewardsSetEvent>;

export interface UpdatedEventObject {}
export type UpdatedEvent = TypedEvent<[], UpdatedEventObject>;

export type UpdatedEventFilter = TypedEventFilter<UpdatedEvent>;

export interface StakingRewards extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: StakingRewardsInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    MAX_LOCK_DURATION(overrides?: CallOverrides): Promise<[BigNumber]>;

    MAX_LOCK_MULTIPLIER_BPS(overrides?: CallOverrides): Promise<[BigNumber]>;

    UNLOCKED_MULTIPLIER_BPS(overrides?: CallOverrides): Promise<[BigNumber]>;

    accRewardPerShare(overrides?: CallOverrides): Promise<[BigNumber]>;

    acceptGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    compoundLock(
      xsLockID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    compoundLocks(
      xsLockIDs: PromiseOrValue<BigNumberish>[],
      increasedLockID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    endTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    getRewardAmountDistributed(
      from: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { amount: BigNumber }>;

    governance(overrides?: CallOverrides): Promise<[string]>;

    governanceIsLocked(overrides?: CallOverrides): Promise<[boolean]>;

    harvestLock(
      xsLockID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    harvestLocks(
      xsLockIDs: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    lastRewardTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    lockGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    pendingGovernance(overrides?: CallOverrides): Promise<[string]>;

    pendingRewardsOfLock(
      xsLockID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { reward: BigNumber }>;

    registerLockEvent(
      xsLockID: PromiseOrValue<BigNumberish>,
      oldOwner: PromiseOrValue<string>,
      newOwner: PromiseOrValue<string>,
      oldLock: LockStruct,
      newLock: LockStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    rescueTokens(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      receiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    rewardPerSecond(overrides?: CallOverrides): Promise<[BigNumber]>;

    setPendingGovernance(
      pendingGovernance_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setRewards(
      rewardPerSecond_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setTimes(
      startTime_: PromiseOrValue<BigNumberish>,
      endTime_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    solace(overrides?: CallOverrides): Promise<[string]>;

    stakedLockInfo(
      xsLockID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[IStakingRewards.StakedLockInfoStructOutput]>;

    startTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    update(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    valueStaked(overrides?: CallOverrides): Promise<[BigNumber]>;

    xsLocker(overrides?: CallOverrides): Promise<[string]>;
  };

  MAX_LOCK_DURATION(overrides?: CallOverrides): Promise<BigNumber>;

  MAX_LOCK_MULTIPLIER_BPS(overrides?: CallOverrides): Promise<BigNumber>;

  UNLOCKED_MULTIPLIER_BPS(overrides?: CallOverrides): Promise<BigNumber>;

  accRewardPerShare(overrides?: CallOverrides): Promise<BigNumber>;

  acceptGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  compoundLock(
    xsLockID: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  compoundLocks(
    xsLockIDs: PromiseOrValue<BigNumberish>[],
    increasedLockID: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  endTime(overrides?: CallOverrides): Promise<BigNumber>;

  getRewardAmountDistributed(
    from: PromiseOrValue<BigNumberish>,
    to: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  governance(overrides?: CallOverrides): Promise<string>;

  governanceIsLocked(overrides?: CallOverrides): Promise<boolean>;

  harvestLock(
    xsLockID: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  harvestLocks(
    xsLockIDs: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  lastRewardTime(overrides?: CallOverrides): Promise<BigNumber>;

  lockGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  pendingGovernance(overrides?: CallOverrides): Promise<string>;

  pendingRewardsOfLock(xsLockID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  registerLockEvent(
    xsLockID: PromiseOrValue<BigNumberish>,
    oldOwner: PromiseOrValue<string>,
    newOwner: PromiseOrValue<string>,
    oldLock: LockStruct,
    newLock: LockStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  rescueTokens(
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    receiver: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  rewardPerSecond(overrides?: CallOverrides): Promise<BigNumber>;

  setPendingGovernance(
    pendingGovernance_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setRewards(
    rewardPerSecond_: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setTimes(
    startTime_: PromiseOrValue<BigNumberish>,
    endTime_: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  solace(overrides?: CallOverrides): Promise<string>;

  stakedLockInfo(
    xsLockID: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<IStakingRewards.StakedLockInfoStructOutput>;

  startTime(overrides?: CallOverrides): Promise<BigNumber>;

  update(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  valueStaked(overrides?: CallOverrides): Promise<BigNumber>;

  xsLocker(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    MAX_LOCK_DURATION(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_LOCK_MULTIPLIER_BPS(overrides?: CallOverrides): Promise<BigNumber>;

    UNLOCKED_MULTIPLIER_BPS(overrides?: CallOverrides): Promise<BigNumber>;

    accRewardPerShare(overrides?: CallOverrides): Promise<BigNumber>;

    acceptGovernance(overrides?: CallOverrides): Promise<void>;

    compoundLock(xsLockID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    compoundLocks(
      xsLockIDs: PromiseOrValue<BigNumberish>[],
      increasedLockID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    endTime(overrides?: CallOverrides): Promise<BigNumber>;

    getRewardAmountDistributed(
      from: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    governance(overrides?: CallOverrides): Promise<string>;

    governanceIsLocked(overrides?: CallOverrides): Promise<boolean>;

    harvestLock(xsLockID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    harvestLocks(xsLockIDs: PromiseOrValue<BigNumberish>[], overrides?: CallOverrides): Promise<void>;

    lastRewardTime(overrides?: CallOverrides): Promise<BigNumber>;

    lockGovernance(overrides?: CallOverrides): Promise<void>;

    pendingGovernance(overrides?: CallOverrides): Promise<string>;

    pendingRewardsOfLock(xsLockID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    registerLockEvent(
      xsLockID: PromiseOrValue<BigNumberish>,
      oldOwner: PromiseOrValue<string>,
      newOwner: PromiseOrValue<string>,
      oldLock: LockStruct,
      newLock: LockStruct,
      overrides?: CallOverrides,
    ): Promise<void>;

    rescueTokens(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      receiver: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    rewardPerSecond(overrides?: CallOverrides): Promise<BigNumber>;

    setPendingGovernance(pendingGovernance_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setRewards(rewardPerSecond_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setTimes(
      startTime_: PromiseOrValue<BigNumberish>,
      endTime_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    solace(overrides?: CallOverrides): Promise<string>;

    stakedLockInfo(
      xsLockID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<IStakingRewards.StakedLockInfoStructOutput>;

    startTime(overrides?: CallOverrides): Promise<BigNumber>;

    update(overrides?: CallOverrides): Promise<void>;

    valueStaked(overrides?: CallOverrides): Promise<BigNumber>;

    xsLocker(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    'FarmTimesSet(uint256,uint256)'(startTime?: null, endTime?: null): FarmTimesSetEventFilter;
    FarmTimesSet(startTime?: null, endTime?: null): FarmTimesSetEventFilter;

    'GovernanceLocked()'(): GovernanceLockedEventFilter;
    GovernanceLocked(): GovernanceLockedEventFilter;

    'GovernancePending(address)'(pendingGovernance?: null): GovernancePendingEventFilter;
    GovernancePending(pendingGovernance?: null): GovernancePendingEventFilter;

    'GovernanceTransferred(address,address)'(
      oldGovernance?: null,
      newGovernance?: null,
    ): GovernanceTransferredEventFilter;
    GovernanceTransferred(oldGovernance?: null, newGovernance?: null): GovernanceTransferredEventFilter;

    'LockUpdated(uint256)'(xsLockID?: PromiseOrValue<BigNumberish> | null): LockUpdatedEventFilter;
    LockUpdated(xsLockID?: PromiseOrValue<BigNumberish> | null): LockUpdatedEventFilter;

    'RewardsSet(uint256)'(rewardPerSecond?: null): RewardsSetEventFilter;
    RewardsSet(rewardPerSecond?: null): RewardsSetEventFilter;

    'Updated()'(): UpdatedEventFilter;
    Updated(): UpdatedEventFilter;
  };

  estimateGas: {
    MAX_LOCK_DURATION(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_LOCK_MULTIPLIER_BPS(overrides?: CallOverrides): Promise<BigNumber>;

    UNLOCKED_MULTIPLIER_BPS(overrides?: CallOverrides): Promise<BigNumber>;

    accRewardPerShare(overrides?: CallOverrides): Promise<BigNumber>;

    acceptGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    compoundLock(
      xsLockID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    compoundLocks(
      xsLockIDs: PromiseOrValue<BigNumberish>[],
      increasedLockID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    endTime(overrides?: CallOverrides): Promise<BigNumber>;

    getRewardAmountDistributed(
      from: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    governance(overrides?: CallOverrides): Promise<BigNumber>;

    governanceIsLocked(overrides?: CallOverrides): Promise<BigNumber>;

    harvestLock(
      xsLockID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    harvestLocks(
      xsLockIDs: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    lastRewardTime(overrides?: CallOverrides): Promise<BigNumber>;

    lockGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    pendingGovernance(overrides?: CallOverrides): Promise<BigNumber>;

    pendingRewardsOfLock(xsLockID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    registerLockEvent(
      xsLockID: PromiseOrValue<BigNumberish>,
      oldOwner: PromiseOrValue<string>,
      newOwner: PromiseOrValue<string>,
      oldLock: LockStruct,
      newLock: LockStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    rescueTokens(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      receiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    rewardPerSecond(overrides?: CallOverrides): Promise<BigNumber>;

    setPendingGovernance(
      pendingGovernance_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setRewards(
      rewardPerSecond_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setTimes(
      startTime_: PromiseOrValue<BigNumberish>,
      endTime_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    solace(overrides?: CallOverrides): Promise<BigNumber>;

    stakedLockInfo(xsLockID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    startTime(overrides?: CallOverrides): Promise<BigNumber>;

    update(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    valueStaked(overrides?: CallOverrides): Promise<BigNumber>;

    xsLocker(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    MAX_LOCK_DURATION(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAX_LOCK_MULTIPLIER_BPS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    UNLOCKED_MULTIPLIER_BPS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    accRewardPerShare(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    acceptGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    compoundLock(
      xsLockID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    compoundLocks(
      xsLockIDs: PromiseOrValue<BigNumberish>[],
      increasedLockID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    endTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getRewardAmountDistributed(
      from: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    governance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    governanceIsLocked(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    harvestLock(
      xsLockID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    harvestLocks(
      xsLockIDs: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    lastRewardTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lockGovernance(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    pendingGovernance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingRewardsOfLock(
      xsLockID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    registerLockEvent(
      xsLockID: PromiseOrValue<BigNumberish>,
      oldOwner: PromiseOrValue<string>,
      newOwner: PromiseOrValue<string>,
      oldLock: LockStruct,
      newLock: LockStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    rescueTokens(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      receiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    rewardPerSecond(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setPendingGovernance(
      pendingGovernance_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setRewards(
      rewardPerSecond_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setTimes(
      startTime_: PromiseOrValue<BigNumberish>,
      endTime_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    solace(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    stakedLockInfo(xsLockID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    startTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    update(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    valueStaked(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    xsLocker(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}

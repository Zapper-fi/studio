/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export interface RenDarknodeRegistryInterface extends utils.Interface {
  functions: {
    'VERSION()': FunctionFragment;
    'blacklistRecoverableToken(address)': FunctionFragment;
    'claimOwnership()': FunctionFragment;
    'claimStoreOwnership()': FunctionFragment;
    'currentEpoch()': FunctionFragment;
    'darknodePayment()': FunctionFragment;
    'deregister(address)': FunctionFragment;
    'deregistrationInterval()': FunctionFragment;
    'epoch()': FunctionFragment;
    'getDarknodeBond(address)': FunctionFragment;
    'getDarknodeOperator(address)': FunctionFragment;
    'getDarknodePublicKey(address)': FunctionFragment;
    'getDarknodes(address,uint256)': FunctionFragment;
    'getPreviousDarknodes(address,uint256)': FunctionFragment;
    'initialize(string,address,address,uint256,uint256,uint256,uint256)': FunctionFragment;
    'initialize(address)': FunctionFragment;
    'isDeregisterable(address)': FunctionFragment;
    'isDeregistered(address)': FunctionFragment;
    'isOwner()': FunctionFragment;
    'isPendingDeregistration(address)': FunctionFragment;
    'isPendingRegistration(address)': FunctionFragment;
    'isRefundable(address)': FunctionFragment;
    'isRefunded(address)': FunctionFragment;
    'isRegistered(address)': FunctionFragment;
    'isRegisteredInPreviousEpoch(address)': FunctionFragment;
    'minimumBond()': FunctionFragment;
    'minimumEpochInterval()': FunctionFragment;
    'minimumPodSize()': FunctionFragment;
    'nextMinimumBond()': FunctionFragment;
    'nextMinimumEpochInterval()': FunctionFragment;
    'nextMinimumPodSize()': FunctionFragment;
    'nextSlasher()': FunctionFragment;
    'numDarknodes()': FunctionFragment;
    'numDarknodesNextEpoch()': FunctionFragment;
    'numDarknodesPreviousEpoch()': FunctionFragment;
    'owner()': FunctionFragment;
    'pendingOwner()': FunctionFragment;
    'previousEpoch()': FunctionFragment;
    'recoverTokens(address)': FunctionFragment;
    'refund(address)': FunctionFragment;
    'register(address,bytes)': FunctionFragment;
    'ren()': FunctionFragment;
    'renounceOwnership()': FunctionFragment;
    'slash(address,address,uint256)': FunctionFragment;
    'slasher()': FunctionFragment;
    'store()': FunctionFragment;
    'transferOwnership(address)': FunctionFragment;
    'transferStoreOwnership(address)': FunctionFragment;
    'updateDarknodePayment(address)': FunctionFragment;
    'updateMinimumBond(uint256)': FunctionFragment;
    'updateMinimumEpochInterval(uint256)': FunctionFragment;
    'updateMinimumPodSize(uint256)': FunctionFragment;
    'updateSlasher(address)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'VERSION'
      | 'blacklistRecoverableToken'
      | 'claimOwnership'
      | 'claimStoreOwnership'
      | 'currentEpoch'
      | 'darknodePayment'
      | 'deregister'
      | 'deregistrationInterval'
      | 'epoch'
      | 'getDarknodeBond'
      | 'getDarknodeOperator'
      | 'getDarknodePublicKey'
      | 'getDarknodes'
      | 'getPreviousDarknodes'
      | 'initialize(string,address,address,uint256,uint256,uint256,uint256)'
      | 'initialize(address)'
      | 'isDeregisterable'
      | 'isDeregistered'
      | 'isOwner'
      | 'isPendingDeregistration'
      | 'isPendingRegistration'
      | 'isRefundable'
      | 'isRefunded'
      | 'isRegistered'
      | 'isRegisteredInPreviousEpoch'
      | 'minimumBond'
      | 'minimumEpochInterval'
      | 'minimumPodSize'
      | 'nextMinimumBond'
      | 'nextMinimumEpochInterval'
      | 'nextMinimumPodSize'
      | 'nextSlasher'
      | 'numDarknodes'
      | 'numDarknodesNextEpoch'
      | 'numDarknodesPreviousEpoch'
      | 'owner'
      | 'pendingOwner'
      | 'previousEpoch'
      | 'recoverTokens'
      | 'refund'
      | 'register'
      | 'ren'
      | 'renounceOwnership'
      | 'slash'
      | 'slasher'
      | 'store'
      | 'transferOwnership'
      | 'transferStoreOwnership'
      | 'updateDarknodePayment'
      | 'updateMinimumBond'
      | 'updateMinimumEpochInterval'
      | 'updateMinimumPodSize'
      | 'updateSlasher',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'VERSION', values?: undefined): string;
  encodeFunctionData(functionFragment: 'blacklistRecoverableToken', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'claimOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'claimStoreOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'currentEpoch', values?: undefined): string;
  encodeFunctionData(functionFragment: 'darknodePayment', values?: undefined): string;
  encodeFunctionData(functionFragment: 'deregister', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'deregistrationInterval', values?: undefined): string;
  encodeFunctionData(functionFragment: 'epoch', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getDarknodeBond', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getDarknodeOperator', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getDarknodePublicKey', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'getDarknodes',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getPreviousDarknodes',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'initialize(string,address,address,uint256,uint256,uint256,uint256)',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'initialize(address)', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'isDeregisterable', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'isDeregistered', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'isOwner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'isPendingDeregistration', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'isPendingRegistration', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'isRefundable', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'isRefunded', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'isRegistered', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'isRegisteredInPreviousEpoch', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'minimumBond', values?: undefined): string;
  encodeFunctionData(functionFragment: 'minimumEpochInterval', values?: undefined): string;
  encodeFunctionData(functionFragment: 'minimumPodSize', values?: undefined): string;
  encodeFunctionData(functionFragment: 'nextMinimumBond', values?: undefined): string;
  encodeFunctionData(functionFragment: 'nextMinimumEpochInterval', values?: undefined): string;
  encodeFunctionData(functionFragment: 'nextMinimumPodSize', values?: undefined): string;
  encodeFunctionData(functionFragment: 'nextSlasher', values?: undefined): string;
  encodeFunctionData(functionFragment: 'numDarknodes', values?: undefined): string;
  encodeFunctionData(functionFragment: 'numDarknodesNextEpoch', values?: undefined): string;
  encodeFunctionData(functionFragment: 'numDarknodesPreviousEpoch', values?: undefined): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pendingOwner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'previousEpoch', values?: undefined): string;
  encodeFunctionData(functionFragment: 'recoverTokens', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'refund', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'register', values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(functionFragment: 'ren', values?: undefined): string;
  encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'slash',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'slasher', values?: undefined): string;
  encodeFunctionData(functionFragment: 'store', values?: undefined): string;
  encodeFunctionData(functionFragment: 'transferOwnership', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'transferStoreOwnership', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'updateDarknodePayment', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'updateMinimumBond', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'updateMinimumEpochInterval', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'updateMinimumPodSize', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'updateSlasher', values: [PromiseOrValue<string>]): string;

  decodeFunctionResult(functionFragment: 'VERSION', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'blacklistRecoverableToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimStoreOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'currentEpoch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'darknodePayment', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deregister', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deregistrationInterval', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'epoch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getDarknodeBond', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getDarknodeOperator', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getDarknodePublicKey', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getDarknodes', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPreviousDarknodes', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'initialize(string,address,address,uint256,uint256,uint256,uint256)',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'initialize(address)', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isDeregisterable', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isDeregistered', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isPendingDeregistration', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isPendingRegistration', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isRefundable', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isRefunded', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isRegistered', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isRegisteredInPreviousEpoch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'minimumBond', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'minimumEpochInterval', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'minimumPodSize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nextMinimumBond', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nextMinimumEpochInterval', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nextMinimumPodSize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nextSlasher', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'numDarknodes', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'numDarknodesNextEpoch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'numDarknodesPreviousEpoch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pendingOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'previousEpoch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'recoverTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'refund', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'register', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'ren', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'slash', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'slasher', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'store', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferStoreOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateDarknodePayment', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateMinimumBond', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateMinimumEpochInterval', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateMinimumPodSize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateSlasher', data: BytesLike): Result;

  events: {
    'LogDarknodeDeregistered(address,address)': EventFragment;
    'LogDarknodePaymentUpdated(address,address)': EventFragment;
    'LogDarknodeRefunded(address,address,uint256)': EventFragment;
    'LogDarknodeRegistered(address,address,uint256)': EventFragment;
    'LogDarknodeSlashed(address,address,address,uint256)': EventFragment;
    'LogMinimumBondUpdated(uint256,uint256)': EventFragment;
    'LogMinimumEpochIntervalUpdated(uint256,uint256)': EventFragment;
    'LogMinimumPodSizeUpdated(uint256,uint256)': EventFragment;
    'LogNewEpoch(uint256)': EventFragment;
    'LogSlasherUpdated(address,address)': EventFragment;
    'OwnershipTransferred(address,address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'LogDarknodeDeregistered'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogDarknodePaymentUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogDarknodeRefunded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogDarknodeRegistered'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogDarknodeSlashed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogMinimumBondUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogMinimumEpochIntervalUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogMinimumPodSizeUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogNewEpoch'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogSlasherUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
}

export interface LogDarknodeDeregisteredEventObject {
  _darknodeOperator: string;
  _darknodeID: string;
}
export type LogDarknodeDeregisteredEvent = TypedEvent<[string, string], LogDarknodeDeregisteredEventObject>;

export type LogDarknodeDeregisteredEventFilter = TypedEventFilter<LogDarknodeDeregisteredEvent>;

export interface LogDarknodePaymentUpdatedEventObject {
  _previousDarknodePayment: string;
  _nextDarknodePayment: string;
}
export type LogDarknodePaymentUpdatedEvent = TypedEvent<[string, string], LogDarknodePaymentUpdatedEventObject>;

export type LogDarknodePaymentUpdatedEventFilter = TypedEventFilter<LogDarknodePaymentUpdatedEvent>;

export interface LogDarknodeRefundedEventObject {
  _darknodeOperator: string;
  _darknodeID: string;
  _amount: BigNumber;
}
export type LogDarknodeRefundedEvent = TypedEvent<[string, string, BigNumber], LogDarknodeRefundedEventObject>;

export type LogDarknodeRefundedEventFilter = TypedEventFilter<LogDarknodeRefundedEvent>;

export interface LogDarknodeRegisteredEventObject {
  _darknodeOperator: string;
  _darknodeID: string;
  _bond: BigNumber;
}
export type LogDarknodeRegisteredEvent = TypedEvent<[string, string, BigNumber], LogDarknodeRegisteredEventObject>;

export type LogDarknodeRegisteredEventFilter = TypedEventFilter<LogDarknodeRegisteredEvent>;

export interface LogDarknodeSlashedEventObject {
  _darknodeOperator: string;
  _darknodeID: string;
  _challenger: string;
  _percentage: BigNumber;
}
export type LogDarknodeSlashedEvent = TypedEvent<[string, string, string, BigNumber], LogDarknodeSlashedEventObject>;

export type LogDarknodeSlashedEventFilter = TypedEventFilter<LogDarknodeSlashedEvent>;

export interface LogMinimumBondUpdatedEventObject {
  _previousMinimumBond: BigNumber;
  _nextMinimumBond: BigNumber;
}
export type LogMinimumBondUpdatedEvent = TypedEvent<[BigNumber, BigNumber], LogMinimumBondUpdatedEventObject>;

export type LogMinimumBondUpdatedEventFilter = TypedEventFilter<LogMinimumBondUpdatedEvent>;

export interface LogMinimumEpochIntervalUpdatedEventObject {
  _previousMinimumEpochInterval: BigNumber;
  _nextMinimumEpochInterval: BigNumber;
}
export type LogMinimumEpochIntervalUpdatedEvent = TypedEvent<
  [BigNumber, BigNumber],
  LogMinimumEpochIntervalUpdatedEventObject
>;

export type LogMinimumEpochIntervalUpdatedEventFilter = TypedEventFilter<LogMinimumEpochIntervalUpdatedEvent>;

export interface LogMinimumPodSizeUpdatedEventObject {
  _previousMinimumPodSize: BigNumber;
  _nextMinimumPodSize: BigNumber;
}
export type LogMinimumPodSizeUpdatedEvent = TypedEvent<[BigNumber, BigNumber], LogMinimumPodSizeUpdatedEventObject>;

export type LogMinimumPodSizeUpdatedEventFilter = TypedEventFilter<LogMinimumPodSizeUpdatedEvent>;

export interface LogNewEpochEventObject {
  epochhash: BigNumber;
}
export type LogNewEpochEvent = TypedEvent<[BigNumber], LogNewEpochEventObject>;

export type LogNewEpochEventFilter = TypedEventFilter<LogNewEpochEvent>;

export interface LogSlasherUpdatedEventObject {
  _previousSlasher: string;
  _nextSlasher: string;
}
export type LogSlasherUpdatedEvent = TypedEvent<[string, string], LogSlasherUpdatedEventObject>;

export type LogSlasherUpdatedEventFilter = TypedEventFilter<LogSlasherUpdatedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<[string, string], OwnershipTransferredEventObject>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export interface RenDarknodeRegistry extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: RenDarknodeRegistryInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    VERSION(overrides?: CallOverrides): Promise<[string]>;

    blacklistRecoverableToken(
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    claimOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    claimStoreOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    currentEpoch(
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { epochhash: BigNumber; blocktime: BigNumber }>;

    darknodePayment(overrides?: CallOverrides): Promise<[string]>;

    deregister(
      _darknodeID: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    deregistrationInterval(overrides?: CallOverrides): Promise<[BigNumber]>;

    epoch(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    getDarknodeBond(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    getDarknodeOperator(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;

    getDarknodePublicKey(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;

    getDarknodes(
      _start: PromiseOrValue<string>,
      _count: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string[]]>;

    getPreviousDarknodes(
      _start: PromiseOrValue<string>,
      _count: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string[]]>;

    'initialize(string,address,address,uint256,uint256,uint256,uint256)'(
      _VERSION: PromiseOrValue<string>,
      _renAddress: PromiseOrValue<string>,
      _storeAddress: PromiseOrValue<string>,
      _minimumBond: PromiseOrValue<BigNumberish>,
      _minimumPodSize: PromiseOrValue<BigNumberish>,
      _minimumEpochIntervalSeconds: PromiseOrValue<BigNumberish>,
      _deregistrationIntervalSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    'initialize(address)'(
      _nextOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    isDeregisterable(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    isDeregistered(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    isOwner(overrides?: CallOverrides): Promise<[boolean]>;

    isPendingDeregistration(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    isPendingRegistration(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    isRefundable(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    isRefunded(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    isRegistered(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    isRegisteredInPreviousEpoch(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    minimumBond(overrides?: CallOverrides): Promise<[BigNumber]>;

    minimumEpochInterval(overrides?: CallOverrides): Promise<[BigNumber]>;

    minimumPodSize(overrides?: CallOverrides): Promise<[BigNumber]>;

    nextMinimumBond(overrides?: CallOverrides): Promise<[BigNumber]>;

    nextMinimumEpochInterval(overrides?: CallOverrides): Promise<[BigNumber]>;

    nextMinimumPodSize(overrides?: CallOverrides): Promise<[BigNumber]>;

    nextSlasher(overrides?: CallOverrides): Promise<[string]>;

    numDarknodes(overrides?: CallOverrides): Promise<[BigNumber]>;

    numDarknodesNextEpoch(overrides?: CallOverrides): Promise<[BigNumber]>;

    numDarknodesPreviousEpoch(overrides?: CallOverrides): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pendingOwner(overrides?: CallOverrides): Promise<[string]>;

    previousEpoch(
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { epochhash: BigNumber; blocktime: BigNumber }>;

    recoverTokens(
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    refund(
      _darknodeID: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    register(
      _darknodeID: PromiseOrValue<string>,
      _publicKey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    ren(overrides?: CallOverrides): Promise<[string]>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    slash(
      _guilty: PromiseOrValue<string>,
      _challenger: PromiseOrValue<string>,
      _percentage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    slasher(overrides?: CallOverrides): Promise<[string]>;

    store(overrides?: CallOverrides): Promise<[string]>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    transferStoreOwnership(
      _newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateDarknodePayment(
      _darknodePayment: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateMinimumBond(
      _nextMinimumBond: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateMinimumEpochInterval(
      _nextMinimumEpochInterval: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateMinimumPodSize(
      _nextMinimumPodSize: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateSlasher(
      _slasher: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;
  };

  VERSION(overrides?: CallOverrides): Promise<string>;

  blacklistRecoverableToken(
    _token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  claimOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  claimStoreOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  currentEpoch(
    overrides?: CallOverrides,
  ): Promise<[BigNumber, BigNumber] & { epochhash: BigNumber; blocktime: BigNumber }>;

  darknodePayment(overrides?: CallOverrides): Promise<string>;

  deregister(
    _darknodeID: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  deregistrationInterval(overrides?: CallOverrides): Promise<BigNumber>;

  epoch(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  getDarknodeBond(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  getDarknodeOperator(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  getDarknodePublicKey(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  getDarknodes(
    _start: PromiseOrValue<string>,
    _count: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<string[]>;

  getPreviousDarknodes(
    _start: PromiseOrValue<string>,
    _count: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<string[]>;

  'initialize(string,address,address,uint256,uint256,uint256,uint256)'(
    _VERSION: PromiseOrValue<string>,
    _renAddress: PromiseOrValue<string>,
    _storeAddress: PromiseOrValue<string>,
    _minimumBond: PromiseOrValue<BigNumberish>,
    _minimumPodSize: PromiseOrValue<BigNumberish>,
    _minimumEpochIntervalSeconds: PromiseOrValue<BigNumberish>,
    _deregistrationIntervalSeconds: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  'initialize(address)'(
    _nextOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  isDeregisterable(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  isDeregistered(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  isOwner(overrides?: CallOverrides): Promise<boolean>;

  isPendingDeregistration(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  isPendingRegistration(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  isRefundable(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  isRefunded(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  isRegistered(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  isRegisteredInPreviousEpoch(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  minimumBond(overrides?: CallOverrides): Promise<BigNumber>;

  minimumEpochInterval(overrides?: CallOverrides): Promise<BigNumber>;

  minimumPodSize(overrides?: CallOverrides): Promise<BigNumber>;

  nextMinimumBond(overrides?: CallOverrides): Promise<BigNumber>;

  nextMinimumEpochInterval(overrides?: CallOverrides): Promise<BigNumber>;

  nextMinimumPodSize(overrides?: CallOverrides): Promise<BigNumber>;

  nextSlasher(overrides?: CallOverrides): Promise<string>;

  numDarknodes(overrides?: CallOverrides): Promise<BigNumber>;

  numDarknodesNextEpoch(overrides?: CallOverrides): Promise<BigNumber>;

  numDarknodesPreviousEpoch(overrides?: CallOverrides): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  pendingOwner(overrides?: CallOverrides): Promise<string>;

  previousEpoch(
    overrides?: CallOverrides,
  ): Promise<[BigNumber, BigNumber] & { epochhash: BigNumber; blocktime: BigNumber }>;

  recoverTokens(
    _token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  refund(
    _darknodeID: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  register(
    _darknodeID: PromiseOrValue<string>,
    _publicKey: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  ren(overrides?: CallOverrides): Promise<string>;

  renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  slash(
    _guilty: PromiseOrValue<string>,
    _challenger: PromiseOrValue<string>,
    _percentage: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  slasher(overrides?: CallOverrides): Promise<string>;

  store(overrides?: CallOverrides): Promise<string>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  transferStoreOwnership(
    _newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateDarknodePayment(
    _darknodePayment: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateMinimumBond(
    _nextMinimumBond: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateMinimumEpochInterval(
    _nextMinimumEpochInterval: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateMinimumPodSize(
    _nextMinimumPodSize: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateSlasher(
    _slasher: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    VERSION(overrides?: CallOverrides): Promise<string>;

    blacklistRecoverableToken(_token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    claimOwnership(overrides?: CallOverrides): Promise<void>;

    claimStoreOwnership(overrides?: CallOverrides): Promise<void>;

    currentEpoch(
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { epochhash: BigNumber; blocktime: BigNumber }>;

    darknodePayment(overrides?: CallOverrides): Promise<string>;

    deregister(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    deregistrationInterval(overrides?: CallOverrides): Promise<BigNumber>;

    epoch(overrides?: CallOverrides): Promise<void>;

    getDarknodeBond(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getDarknodeOperator(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    getDarknodePublicKey(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    getDarknodes(
      _start: PromiseOrValue<string>,
      _count: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<string[]>;

    getPreviousDarknodes(
      _start: PromiseOrValue<string>,
      _count: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<string[]>;

    'initialize(string,address,address,uint256,uint256,uint256,uint256)'(
      _VERSION: PromiseOrValue<string>,
      _renAddress: PromiseOrValue<string>,
      _storeAddress: PromiseOrValue<string>,
      _minimumBond: PromiseOrValue<BigNumberish>,
      _minimumPodSize: PromiseOrValue<BigNumberish>,
      _minimumEpochIntervalSeconds: PromiseOrValue<BigNumberish>,
      _deregistrationIntervalSeconds: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    'initialize(address)'(_nextOwner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    isDeregisterable(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    isDeregistered(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    isOwner(overrides?: CallOverrides): Promise<boolean>;

    isPendingDeregistration(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    isPendingRegistration(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    isRefundable(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    isRefunded(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    isRegistered(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    isRegisteredInPreviousEpoch(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    minimumBond(overrides?: CallOverrides): Promise<BigNumber>;

    minimumEpochInterval(overrides?: CallOverrides): Promise<BigNumber>;

    minimumPodSize(overrides?: CallOverrides): Promise<BigNumber>;

    nextMinimumBond(overrides?: CallOverrides): Promise<BigNumber>;

    nextMinimumEpochInterval(overrides?: CallOverrides): Promise<BigNumber>;

    nextMinimumPodSize(overrides?: CallOverrides): Promise<BigNumber>;

    nextSlasher(overrides?: CallOverrides): Promise<string>;

    numDarknodes(overrides?: CallOverrides): Promise<BigNumber>;

    numDarknodesNextEpoch(overrides?: CallOverrides): Promise<BigNumber>;

    numDarknodesPreviousEpoch(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    pendingOwner(overrides?: CallOverrides): Promise<string>;

    previousEpoch(
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { epochhash: BigNumber; blocktime: BigNumber }>;

    recoverTokens(_token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    refund(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    register(
      _darknodeID: PromiseOrValue<string>,
      _publicKey: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    ren(overrides?: CallOverrides): Promise<string>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    slash(
      _guilty: PromiseOrValue<string>,
      _challenger: PromiseOrValue<string>,
      _percentage: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    slasher(overrides?: CallOverrides): Promise<string>;

    store(overrides?: CallOverrides): Promise<string>;

    transferOwnership(newOwner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    transferStoreOwnership(_newOwner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    updateDarknodePayment(_darknodePayment: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    updateMinimumBond(_nextMinimumBond: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    updateMinimumEpochInterval(
      _nextMinimumEpochInterval: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    updateMinimumPodSize(_nextMinimumPodSize: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    updateSlasher(_slasher: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
  };

  filters: {
    'LogDarknodeDeregistered(address,address)'(
      _darknodeOperator?: PromiseOrValue<string> | null,
      _darknodeID?: PromiseOrValue<string> | null,
    ): LogDarknodeDeregisteredEventFilter;
    LogDarknodeDeregistered(
      _darknodeOperator?: PromiseOrValue<string> | null,
      _darknodeID?: PromiseOrValue<string> | null,
    ): LogDarknodeDeregisteredEventFilter;

    'LogDarknodePaymentUpdated(address,address)'(
      _previousDarknodePayment?: PromiseOrValue<string> | null,
      _nextDarknodePayment?: PromiseOrValue<string> | null,
    ): LogDarknodePaymentUpdatedEventFilter;
    LogDarknodePaymentUpdated(
      _previousDarknodePayment?: PromiseOrValue<string> | null,
      _nextDarknodePayment?: PromiseOrValue<string> | null,
    ): LogDarknodePaymentUpdatedEventFilter;

    'LogDarknodeRefunded(address,address,uint256)'(
      _darknodeOperator?: PromiseOrValue<string> | null,
      _darknodeID?: PromiseOrValue<string> | null,
      _amount?: null,
    ): LogDarknodeRefundedEventFilter;
    LogDarknodeRefunded(
      _darknodeOperator?: PromiseOrValue<string> | null,
      _darknodeID?: PromiseOrValue<string> | null,
      _amount?: null,
    ): LogDarknodeRefundedEventFilter;

    'LogDarknodeRegistered(address,address,uint256)'(
      _darknodeOperator?: PromiseOrValue<string> | null,
      _darknodeID?: PromiseOrValue<string> | null,
      _bond?: null,
    ): LogDarknodeRegisteredEventFilter;
    LogDarknodeRegistered(
      _darknodeOperator?: PromiseOrValue<string> | null,
      _darknodeID?: PromiseOrValue<string> | null,
      _bond?: null,
    ): LogDarknodeRegisteredEventFilter;

    'LogDarknodeSlashed(address,address,address,uint256)'(
      _darknodeOperator?: PromiseOrValue<string> | null,
      _darknodeID?: PromiseOrValue<string> | null,
      _challenger?: PromiseOrValue<string> | null,
      _percentage?: null,
    ): LogDarknodeSlashedEventFilter;
    LogDarknodeSlashed(
      _darknodeOperator?: PromiseOrValue<string> | null,
      _darknodeID?: PromiseOrValue<string> | null,
      _challenger?: PromiseOrValue<string> | null,
      _percentage?: null,
    ): LogDarknodeSlashedEventFilter;

    'LogMinimumBondUpdated(uint256,uint256)'(
      _previousMinimumBond?: null,
      _nextMinimumBond?: null,
    ): LogMinimumBondUpdatedEventFilter;
    LogMinimumBondUpdated(_previousMinimumBond?: null, _nextMinimumBond?: null): LogMinimumBondUpdatedEventFilter;

    'LogMinimumEpochIntervalUpdated(uint256,uint256)'(
      _previousMinimumEpochInterval?: null,
      _nextMinimumEpochInterval?: null,
    ): LogMinimumEpochIntervalUpdatedEventFilter;
    LogMinimumEpochIntervalUpdated(
      _previousMinimumEpochInterval?: null,
      _nextMinimumEpochInterval?: null,
    ): LogMinimumEpochIntervalUpdatedEventFilter;

    'LogMinimumPodSizeUpdated(uint256,uint256)'(
      _previousMinimumPodSize?: null,
      _nextMinimumPodSize?: null,
    ): LogMinimumPodSizeUpdatedEventFilter;
    LogMinimumPodSizeUpdated(
      _previousMinimumPodSize?: null,
      _nextMinimumPodSize?: null,
    ): LogMinimumPodSizeUpdatedEventFilter;

    'LogNewEpoch(uint256)'(epochhash?: PromiseOrValue<BigNumberish> | null): LogNewEpochEventFilter;
    LogNewEpoch(epochhash?: PromiseOrValue<BigNumberish> | null): LogNewEpochEventFilter;

    'LogSlasherUpdated(address,address)'(
      _previousSlasher?: PromiseOrValue<string> | null,
      _nextSlasher?: PromiseOrValue<string> | null,
    ): LogSlasherUpdatedEventFilter;
    LogSlasherUpdated(
      _previousSlasher?: PromiseOrValue<string> | null,
      _nextSlasher?: PromiseOrValue<string> | null,
    ): LogSlasherUpdatedEventFilter;

    'OwnershipTransferred(address,address)'(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;
  };

  estimateGas: {
    VERSION(overrides?: CallOverrides): Promise<BigNumber>;

    blacklistRecoverableToken(
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    claimOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    claimStoreOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    currentEpoch(overrides?: CallOverrides): Promise<BigNumber>;

    darknodePayment(overrides?: CallOverrides): Promise<BigNumber>;

    deregister(
      _darknodeID: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    deregistrationInterval(overrides?: CallOverrides): Promise<BigNumber>;

    epoch(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    getDarknodeBond(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getDarknodeOperator(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getDarknodePublicKey(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getDarknodes(
      _start: PromiseOrValue<string>,
      _count: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getPreviousDarknodes(
      _start: PromiseOrValue<string>,
      _count: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    'initialize(string,address,address,uint256,uint256,uint256,uint256)'(
      _VERSION: PromiseOrValue<string>,
      _renAddress: PromiseOrValue<string>,
      _storeAddress: PromiseOrValue<string>,
      _minimumBond: PromiseOrValue<BigNumberish>,
      _minimumPodSize: PromiseOrValue<BigNumberish>,
      _minimumEpochIntervalSeconds: PromiseOrValue<BigNumberish>,
      _deregistrationIntervalSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    'initialize(address)'(
      _nextOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    isDeregisterable(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    isDeregistered(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    isOwner(overrides?: CallOverrides): Promise<BigNumber>;

    isPendingDeregistration(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    isPendingRegistration(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    isRefundable(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    isRefunded(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    isRegistered(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    isRegisteredInPreviousEpoch(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    minimumBond(overrides?: CallOverrides): Promise<BigNumber>;

    minimumEpochInterval(overrides?: CallOverrides): Promise<BigNumber>;

    minimumPodSize(overrides?: CallOverrides): Promise<BigNumber>;

    nextMinimumBond(overrides?: CallOverrides): Promise<BigNumber>;

    nextMinimumEpochInterval(overrides?: CallOverrides): Promise<BigNumber>;

    nextMinimumPodSize(overrides?: CallOverrides): Promise<BigNumber>;

    nextSlasher(overrides?: CallOverrides): Promise<BigNumber>;

    numDarknodes(overrides?: CallOverrides): Promise<BigNumber>;

    numDarknodesNextEpoch(overrides?: CallOverrides): Promise<BigNumber>;

    numDarknodesPreviousEpoch(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pendingOwner(overrides?: CallOverrides): Promise<BigNumber>;

    previousEpoch(overrides?: CallOverrides): Promise<BigNumber>;

    recoverTokens(
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    refund(
      _darknodeID: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    register(
      _darknodeID: PromiseOrValue<string>,
      _publicKey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    ren(overrides?: CallOverrides): Promise<BigNumber>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    slash(
      _guilty: PromiseOrValue<string>,
      _challenger: PromiseOrValue<string>,
      _percentage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    slasher(overrides?: CallOverrides): Promise<BigNumber>;

    store(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    transferStoreOwnership(
      _newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateDarknodePayment(
      _darknodePayment: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateMinimumBond(
      _nextMinimumBond: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateMinimumEpochInterval(
      _nextMinimumEpochInterval: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateMinimumPodSize(
      _nextMinimumPodSize: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateSlasher(
      _slasher: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    VERSION(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    blacklistRecoverableToken(
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    claimOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    claimStoreOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    currentEpoch(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    darknodePayment(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    deregister(
      _darknodeID: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    deregistrationInterval(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    epoch(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    getDarknodeBond(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getDarknodeOperator(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getDarknodePublicKey(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getDarknodes(
      _start: PromiseOrValue<string>,
      _count: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getPreviousDarknodes(
      _start: PromiseOrValue<string>,
      _count: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    'initialize(string,address,address,uint256,uint256,uint256,uint256)'(
      _VERSION: PromiseOrValue<string>,
      _renAddress: PromiseOrValue<string>,
      _storeAddress: PromiseOrValue<string>,
      _minimumBond: PromiseOrValue<BigNumberish>,
      _minimumPodSize: PromiseOrValue<BigNumberish>,
      _minimumEpochIntervalSeconds: PromiseOrValue<BigNumberish>,
      _deregistrationIntervalSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    'initialize(address)'(
      _nextOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    isDeregisterable(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isDeregistered(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isPendingDeregistration(
      _darknodeID: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    isPendingRegistration(
      _darknodeID: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    isRefundable(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isRefunded(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isRegistered(_darknodeID: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isRegisteredInPreviousEpoch(
      _darknodeID: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    minimumBond(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minimumEpochInterval(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minimumPodSize(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nextMinimumBond(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nextMinimumEpochInterval(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nextMinimumPodSize(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nextSlasher(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    numDarknodes(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    numDarknodesNextEpoch(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    numDarknodesPreviousEpoch(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    previousEpoch(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    recoverTokens(
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    refund(
      _darknodeID: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    register(
      _darknodeID: PromiseOrValue<string>,
      _publicKey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    ren(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    slash(
      _guilty: PromiseOrValue<string>,
      _challenger: PromiseOrValue<string>,
      _percentage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    slasher(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    store(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    transferStoreOwnership(
      _newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateDarknodePayment(
      _darknodePayment: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateMinimumBond(
      _nextMinimumBond: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateMinimumEpochInterval(
      _nextMinimumEpochInterval: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateMinimumPodSize(
      _nextMinimumPodSize: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateSlasher(
      _slasher: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;
  };
}

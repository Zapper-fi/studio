/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export declare namespace IBaseSilo {
  export type AssetStorageStruct = {
    collateralToken: PromiseOrValue<string>;
    collateralOnlyToken: PromiseOrValue<string>;
    debtToken: PromiseOrValue<string>;
    totalDeposits: PromiseOrValue<BigNumberish>;
    collateralOnlyDeposits: PromiseOrValue<BigNumberish>;
    totalBorrowAmount: PromiseOrValue<BigNumberish>;
  };

  export type AssetStorageStructOutput = [string, string, string, BigNumber, BigNumber, BigNumber] & {
    collateralToken: string;
    collateralOnlyToken: string;
    debtToken: string;
    totalDeposits: BigNumber;
    collateralOnlyDeposits: BigNumber;
    totalBorrowAmount: BigNumber;
  };

  export type AssetInterestDataStruct = {
    harvestedProtocolFees: PromiseOrValue<BigNumberish>;
    protocolFees: PromiseOrValue<BigNumberish>;
    interestRateTimestamp: PromiseOrValue<BigNumberish>;
    status: PromiseOrValue<BigNumberish>;
  };

  export type AssetInterestDataStructOutput = [BigNumber, BigNumber, BigNumber, number] & {
    harvestedProtocolFees: BigNumber;
    protocolFees: BigNumber;
    interestRateTimestamp: BigNumber;
    status: number;
  };

  export type UtilizationDataStruct = {
    totalDeposits: PromiseOrValue<BigNumberish>;
    totalBorrowAmount: PromiseOrValue<BigNumberish>;
    interestRateTimestamp: PromiseOrValue<BigNumberish>;
  };

  export type UtilizationDataStructOutput = [BigNumber, BigNumber, BigNumber] & {
    totalDeposits: BigNumber;
    totalBorrowAmount: BigNumber;
    interestRateTimestamp: BigNumber;
  };
}

export interface SiloInterface extends utils.Interface {
  functions: {
    'VERSION()': FunctionFragment;
    'accrueInterest(address)': FunctionFragment;
    'assetStorage(address)': FunctionFragment;
    'borrow(address,uint256)': FunctionFragment;
    'borrowFor(address,address,address,uint256)': FunctionFragment;
    'borrowPossible(address,address)': FunctionFragment;
    'deposit(address,uint256,bool)': FunctionFragment;
    'depositFor(address,address,uint256,bool)': FunctionFragment;
    'depositPossible(address,address)': FunctionFragment;
    'flashLiquidate(address[],bytes)': FunctionFragment;
    'getAssets()': FunctionFragment;
    'getAssetsWithState()': FunctionFragment;
    'harvestProtocolFees()': FunctionFragment;
    'initAssetsTokens()': FunctionFragment;
    'interestData(address)': FunctionFragment;
    'isSolvent(address)': FunctionFragment;
    'liquidity(address)': FunctionFragment;
    'repay(address,uint256)': FunctionFragment;
    'repayFor(address,address,uint256)': FunctionFragment;
    'siloAsset()': FunctionFragment;
    'siloRepository()': FunctionFragment;
    'syncBridgeAssets()': FunctionFragment;
    'utilizationData(address)': FunctionFragment;
    'withdraw(address,uint256,bool)': FunctionFragment;
    'withdrawFor(address,address,address,uint256,bool)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'VERSION'
      | 'accrueInterest'
      | 'assetStorage'
      | 'borrow'
      | 'borrowFor'
      | 'borrowPossible'
      | 'deposit'
      | 'depositFor'
      | 'depositPossible'
      | 'flashLiquidate'
      | 'getAssets'
      | 'getAssetsWithState'
      | 'harvestProtocolFees'
      | 'initAssetsTokens'
      | 'interestData'
      | 'isSolvent'
      | 'liquidity'
      | 'repay'
      | 'repayFor'
      | 'siloAsset'
      | 'siloRepository'
      | 'syncBridgeAssets'
      | 'utilizationData'
      | 'withdraw'
      | 'withdrawFor',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'VERSION', values?: undefined): string;
  encodeFunctionData(functionFragment: 'accrueInterest', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'assetStorage', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'borrow',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'borrowFor',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'borrowPossible',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'deposit',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'depositFor',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'depositPossible',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'flashLiquidate',
    values: [PromiseOrValue<string>[], PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(functionFragment: 'getAssets', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getAssetsWithState', values?: undefined): string;
  encodeFunctionData(functionFragment: 'harvestProtocolFees', values?: undefined): string;
  encodeFunctionData(functionFragment: 'initAssetsTokens', values?: undefined): string;
  encodeFunctionData(functionFragment: 'interestData', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'isSolvent', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'liquidity', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'repay', values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'repayFor',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'siloAsset', values?: undefined): string;
  encodeFunctionData(functionFragment: 'siloRepository', values?: undefined): string;
  encodeFunctionData(functionFragment: 'syncBridgeAssets', values?: undefined): string;
  encodeFunctionData(functionFragment: 'utilizationData', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'withdraw',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'withdrawFor',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
    ],
  ): string;

  decodeFunctionResult(functionFragment: 'VERSION', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'accrueInterest', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'assetStorage', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'borrow', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'borrowFor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'borrowPossible', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'depositFor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'depositPossible', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'flashLiquidate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getAssets', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getAssetsWithState', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'harvestProtocolFees', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initAssetsTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'interestData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isSolvent', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidity', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'repay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'repayFor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'siloAsset', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'siloRepository', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'syncBridgeAssets', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'utilizationData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawFor', data: BytesLike): Result;

  events: {
    'AssetStatusUpdate(address,uint8)': EventFragment;
    'Borrow(address,address,uint256)': EventFragment;
    'Deposit(address,address,uint256,bool)': EventFragment;
    'Liquidate(address,address,uint256,uint256)': EventFragment;
    'Repay(address,address,uint256)': EventFragment;
    'Withdraw(address,address,address,uint256,bool)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'AssetStatusUpdate'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Borrow'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Deposit'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Liquidate'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Repay'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Withdraw'): EventFragment;
}

export interface AssetStatusUpdateEventObject {
  asset: string;
  status: number;
}
export type AssetStatusUpdateEvent = TypedEvent<[string, number], AssetStatusUpdateEventObject>;

export type AssetStatusUpdateEventFilter = TypedEventFilter<AssetStatusUpdateEvent>;

export interface BorrowEventObject {
  asset: string;
  user: string;
  amount: BigNumber;
}
export type BorrowEvent = TypedEvent<[string, string, BigNumber], BorrowEventObject>;

export type BorrowEventFilter = TypedEventFilter<BorrowEvent>;

export interface DepositEventObject {
  asset: string;
  depositor: string;
  amount: BigNumber;
  collateralOnly: boolean;
}
export type DepositEvent = TypedEvent<[string, string, BigNumber, boolean], DepositEventObject>;

export type DepositEventFilter = TypedEventFilter<DepositEvent>;

export interface LiquidateEventObject {
  asset: string;
  user: string;
  shareAmountRepaid: BigNumber;
  seizedCollateral: BigNumber;
}
export type LiquidateEvent = TypedEvent<[string, string, BigNumber, BigNumber], LiquidateEventObject>;

export type LiquidateEventFilter = TypedEventFilter<LiquidateEvent>;

export interface RepayEventObject {
  asset: string;
  user: string;
  amount: BigNumber;
}
export type RepayEvent = TypedEvent<[string, string, BigNumber], RepayEventObject>;

export type RepayEventFilter = TypedEventFilter<RepayEvent>;

export interface WithdrawEventObject {
  asset: string;
  depositor: string;
  receiver: string;
  amount: BigNumber;
  collateralOnly: boolean;
}
export type WithdrawEvent = TypedEvent<[string, string, string, BigNumber, boolean], WithdrawEventObject>;

export type WithdrawEventFilter = TypedEventFilter<WithdrawEvent>;

export interface Silo extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: SiloInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    VERSION(overrides?: CallOverrides): Promise<[BigNumber]>;

    accrueInterest(
      _asset: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    assetStorage(
      _asset: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[IBaseSilo.AssetStorageStructOutput]>;

    borrow(
      _asset: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    borrowFor(
      _asset: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _receiver: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    borrowPossible(
      _asset: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    deposit(
      _asset: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _collateralOnly: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    depositFor(
      _asset: PromiseOrValue<string>,
      _depositor: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _collateralOnly: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    depositPossible(
      _asset: PromiseOrValue<string>,
      _depositor: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    flashLiquidate(
      _users: PromiseOrValue<string>[],
      _flashReceiverData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    getAssets(overrides?: CallOverrides): Promise<[string[]] & { assets: string[] }>;

    getAssetsWithState(overrides?: CallOverrides): Promise<
      [string[], IBaseSilo.AssetStorageStructOutput[]] & {
        assets: string[];
        assetsStorage: IBaseSilo.AssetStorageStructOutput[];
      }
    >;

    harvestProtocolFees(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    initAssetsTokens(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    interestData(
      _asset: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[IBaseSilo.AssetInterestDataStructOutput]>;

    isSolvent(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    liquidity(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    repay(
      _asset: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    repayFor(
      _asset: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    siloAsset(overrides?: CallOverrides): Promise<[string]>;

    siloRepository(overrides?: CallOverrides): Promise<[string]>;

    syncBridgeAssets(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    utilizationData(
      _asset: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [IBaseSilo.UtilizationDataStructOutput] & {
        data: IBaseSilo.UtilizationDataStructOutput;
      }
    >;

    withdraw(
      _asset: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _collateralOnly: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    withdrawFor(
      _asset: PromiseOrValue<string>,
      _depositor: PromiseOrValue<string>,
      _receiver: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _collateralOnly: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;
  };

  VERSION(overrides?: CallOverrides): Promise<BigNumber>;

  accrueInterest(
    _asset: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  assetStorage(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<IBaseSilo.AssetStorageStructOutput>;

  borrow(
    _asset: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  borrowFor(
    _asset: PromiseOrValue<string>,
    _borrower: PromiseOrValue<string>,
    _receiver: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  borrowPossible(
    _asset: PromiseOrValue<string>,
    _borrower: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  deposit(
    _asset: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    _collateralOnly: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  depositFor(
    _asset: PromiseOrValue<string>,
    _depositor: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    _collateralOnly: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  depositPossible(
    _asset: PromiseOrValue<string>,
    _depositor: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  flashLiquidate(
    _users: PromiseOrValue<string>[],
    _flashReceiverData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  getAssets(overrides?: CallOverrides): Promise<string[]>;

  getAssetsWithState(overrides?: CallOverrides): Promise<
    [string[], IBaseSilo.AssetStorageStructOutput[]] & {
      assets: string[];
      assetsStorage: IBaseSilo.AssetStorageStructOutput[];
    }
  >;

  harvestProtocolFees(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  initAssetsTokens(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  interestData(
    _asset: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<IBaseSilo.AssetInterestDataStructOutput>;

  isSolvent(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  liquidity(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  repay(
    _asset: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  repayFor(
    _asset: PromiseOrValue<string>,
    _borrower: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  siloAsset(overrides?: CallOverrides): Promise<string>;

  siloRepository(overrides?: CallOverrides): Promise<string>;

  syncBridgeAssets(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  utilizationData(
    _asset: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<IBaseSilo.UtilizationDataStructOutput>;

  withdraw(
    _asset: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    _collateralOnly: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  withdrawFor(
    _asset: PromiseOrValue<string>,
    _depositor: PromiseOrValue<string>,
    _receiver: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    _collateralOnly: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    VERSION(overrides?: CallOverrides): Promise<BigNumber>;

    accrueInterest(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    assetStorage(
      _asset: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<IBaseSilo.AssetStorageStructOutput>;

    borrow(
      _asset: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { debtAmount: BigNumber; debtShare: BigNumber }>;

    borrowFor(
      _asset: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _receiver: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { debtAmount: BigNumber; debtShare: BigNumber }>;

    borrowPossible(
      _asset: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    deposit(
      _asset: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _collateralOnly: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        collateralAmount: BigNumber;
        collateralShare: BigNumber;
      }
    >;

    depositFor(
      _asset: PromiseOrValue<string>,
      _depositor: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _collateralOnly: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        collateralAmount: BigNumber;
        collateralShare: BigNumber;
      }
    >;

    depositPossible(
      _asset: PromiseOrValue<string>,
      _depositor: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    flashLiquidate(
      _users: PromiseOrValue<string>[],
      _flashReceiverData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<
      [string[], BigNumber[][], BigNumber[][]] & {
        assets: string[];
        receivedCollaterals: BigNumber[][];
        shareAmountsToRepay: BigNumber[][];
      }
    >;

    getAssets(overrides?: CallOverrides): Promise<string[]>;

    getAssetsWithState(overrides?: CallOverrides): Promise<
      [string[], IBaseSilo.AssetStorageStructOutput[]] & {
        assets: string[];
        assetsStorage: IBaseSilo.AssetStorageStructOutput[];
      }
    >;

    harvestProtocolFees(overrides?: CallOverrides): Promise<BigNumber[]>;

    initAssetsTokens(overrides?: CallOverrides): Promise<void>;

    interestData(
      _asset: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<IBaseSilo.AssetInterestDataStructOutput>;

    isSolvent(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    liquidity(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    repay(
      _asset: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        repaidAmount: BigNumber;
        repaidShare: BigNumber;
      }
    >;

    repayFor(
      _asset: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        repaidAmount: BigNumber;
        repaidShare: BigNumber;
      }
    >;

    siloAsset(overrides?: CallOverrides): Promise<string>;

    siloRepository(overrides?: CallOverrides): Promise<string>;

    syncBridgeAssets(overrides?: CallOverrides): Promise<void>;

    utilizationData(
      _asset: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<IBaseSilo.UtilizationDataStructOutput>;

    withdraw(
      _asset: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _collateralOnly: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        withdrawnAmount: BigNumber;
        withdrawnShare: BigNumber;
      }
    >;

    withdrawFor(
      _asset: PromiseOrValue<string>,
      _depositor: PromiseOrValue<string>,
      _receiver: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _collateralOnly: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        withdrawnAmount: BigNumber;
        withdrawnShare: BigNumber;
      }
    >;
  };

  filters: {
    'AssetStatusUpdate(address,uint8)'(
      asset?: PromiseOrValue<string> | null,
      status?: PromiseOrValue<BigNumberish> | null,
    ): AssetStatusUpdateEventFilter;
    AssetStatusUpdate(
      asset?: PromiseOrValue<string> | null,
      status?: PromiseOrValue<BigNumberish> | null,
    ): AssetStatusUpdateEventFilter;

    'Borrow(address,address,uint256)'(
      asset?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      amount?: null,
    ): BorrowEventFilter;
    Borrow(
      asset?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      amount?: null,
    ): BorrowEventFilter;

    'Deposit(address,address,uint256,bool)'(
      asset?: PromiseOrValue<string> | null,
      depositor?: PromiseOrValue<string> | null,
      amount?: null,
      collateralOnly?: null,
    ): DepositEventFilter;
    Deposit(
      asset?: PromiseOrValue<string> | null,
      depositor?: PromiseOrValue<string> | null,
      amount?: null,
      collateralOnly?: null,
    ): DepositEventFilter;

    'Liquidate(address,address,uint256,uint256)'(
      asset?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      shareAmountRepaid?: null,
      seizedCollateral?: null,
    ): LiquidateEventFilter;
    Liquidate(
      asset?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      shareAmountRepaid?: null,
      seizedCollateral?: null,
    ): LiquidateEventFilter;

    'Repay(address,address,uint256)'(
      asset?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      amount?: null,
    ): RepayEventFilter;
    Repay(asset?: PromiseOrValue<string> | null, user?: PromiseOrValue<string> | null, amount?: null): RepayEventFilter;

    'Withdraw(address,address,address,uint256,bool)'(
      asset?: PromiseOrValue<string> | null,
      depositor?: PromiseOrValue<string> | null,
      receiver?: PromiseOrValue<string> | null,
      amount?: null,
      collateralOnly?: null,
    ): WithdrawEventFilter;
    Withdraw(
      asset?: PromiseOrValue<string> | null,
      depositor?: PromiseOrValue<string> | null,
      receiver?: PromiseOrValue<string> | null,
      amount?: null,
      collateralOnly?: null,
    ): WithdrawEventFilter;
  };

  estimateGas: {
    VERSION(overrides?: CallOverrides): Promise<BigNumber>;

    accrueInterest(
      _asset: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    assetStorage(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    borrow(
      _asset: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    borrowFor(
      _asset: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _receiver: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    borrowPossible(
      _asset: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    deposit(
      _asset: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _collateralOnly: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    depositFor(
      _asset: PromiseOrValue<string>,
      _depositor: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _collateralOnly: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    depositPossible(
      _asset: PromiseOrValue<string>,
      _depositor: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    flashLiquidate(
      _users: PromiseOrValue<string>[],
      _flashReceiverData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    getAssets(overrides?: CallOverrides): Promise<BigNumber>;

    getAssetsWithState(overrides?: CallOverrides): Promise<BigNumber>;

    harvestProtocolFees(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    initAssetsTokens(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    interestData(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    isSolvent(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    liquidity(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    repay(
      _asset: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    repayFor(
      _asset: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    siloAsset(overrides?: CallOverrides): Promise<BigNumber>;

    siloRepository(overrides?: CallOverrides): Promise<BigNumber>;

    syncBridgeAssets(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    utilizationData(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    withdraw(
      _asset: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _collateralOnly: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    withdrawFor(
      _asset: PromiseOrValue<string>,
      _depositor: PromiseOrValue<string>,
      _receiver: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _collateralOnly: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    VERSION(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    accrueInterest(
      _asset: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    assetStorage(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    borrow(
      _asset: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    borrowFor(
      _asset: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _receiver: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    borrowPossible(
      _asset: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    deposit(
      _asset: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _collateralOnly: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    depositFor(
      _asset: PromiseOrValue<string>,
      _depositor: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _collateralOnly: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    depositPossible(
      _asset: PromiseOrValue<string>,
      _depositor: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    flashLiquidate(
      _users: PromiseOrValue<string>[],
      _flashReceiverData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    getAssets(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getAssetsWithState(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    harvestProtocolFees(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    initAssetsTokens(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    interestData(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isSolvent(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    liquidity(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    repay(
      _asset: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    repayFor(
      _asset: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    siloAsset(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    siloRepository(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    syncBridgeAssets(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    utilizationData(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdraw(
      _asset: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _collateralOnly: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    withdrawFor(
      _asset: PromiseOrValue<string>,
      _depositor: PromiseOrValue<string>,
      _receiver: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _collateralOnly: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;
  };
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export declare namespace DataTypes {
  export type NftConfigurationMapStruct = {
    data: PromiseOrValue<BigNumberish>;
  };

  export type NftConfigurationMapStructOutput = [BigNumber] & {
    data: BigNumber;
  };

  export type NftDataStruct = {
    configuration: DataTypes.NftConfigurationMapStruct;
    uNftAddress: PromiseOrValue<string>;
    id: PromiseOrValue<BigNumberish>;
    maxSupply: PromiseOrValue<BigNumberish>;
    maxTokenId: PromiseOrValue<BigNumberish>;
  };

  export type NftDataStructOutput = [
    DataTypes.NftConfigurationMapStructOutput,
    string,
    number,
    BigNumber,
    BigNumber,
  ] & {
    configuration: DataTypes.NftConfigurationMapStructOutput;
    uNftAddress: string;
    id: number;
    maxSupply: BigNumber;
    maxTokenId: BigNumber;
  };

  export type ReserveConfigurationMapStruct = {
    data: PromiseOrValue<BigNumberish>;
  };

  export type ReserveConfigurationMapStructOutput = [BigNumber] & {
    data: BigNumber;
  };

  export type ReserveDataStruct = {
    configuration: DataTypes.ReserveConfigurationMapStruct;
    liquidityIndex: PromiseOrValue<BigNumberish>;
    variableBorrowIndex: PromiseOrValue<BigNumberish>;
    currentLiquidityRate: PromiseOrValue<BigNumberish>;
    currentVariableBorrowRate: PromiseOrValue<BigNumberish>;
    lastUpdateTimestamp: PromiseOrValue<BigNumberish>;
    uTokenAddress: PromiseOrValue<string>;
    debtTokenAddress: PromiseOrValue<string>;
    interestRateAddress: PromiseOrValue<string>;
    id: PromiseOrValue<BigNumberish>;
  };

  export type ReserveDataStructOutput = [
    DataTypes.ReserveConfigurationMapStructOutput,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    string,
    string,
    string,
    number,
  ] & {
    configuration: DataTypes.ReserveConfigurationMapStructOutput;
    liquidityIndex: BigNumber;
    variableBorrowIndex: BigNumber;
    currentLiquidityRate: BigNumber;
    currentVariableBorrowRate: BigNumber;
    lastUpdateTimestamp: number;
    uTokenAddress: string;
    debtTokenAddress: string;
    interestRateAddress: string;
    id: number;
  };
}

export interface UnlockdFinanceLendPoolInterface extends utils.Interface {
  functions: {
    'ADDRESS_ID_PUNK_GATEWAY()': FunctionFragment;
    'ADDRESS_ID_WETH_GATEWAY()': FunctionFragment;
    '_isMarketSupported(address,uint8)': FunctionFragment;
    'approveValuation(address,uint256)': FunctionFragment;
    'auction(address,uint256,uint256,address)': FunctionFragment;
    'borrow(address,uint256,address,uint256,address,uint16)': FunctionFragment;
    'deposit(address,uint256,address,uint16)': FunctionFragment;
    'finalizeTransfer(address,address,address,uint256,uint256,uint256)': FunctionFragment;
    'getAddressesProvider()': FunctionFragment;
    'getAuctionDurationConfigFee()': FunctionFragment;
    'getConfigFee()': FunctionFragment;
    'getIsMarketSupported(address,uint8)': FunctionFragment;
    'getLiquidateFeePercentage()': FunctionFragment;
    'getMaxNumberOfNfts()': FunctionFragment;
    'getMaxNumberOfReserves()': FunctionFragment;
    'getNftAssetConfig(address,uint256)': FunctionFragment;
    'getNftAuctionData(address,uint256)': FunctionFragment;
    'getNftCollateralData(address,uint256,address)': FunctionFragment;
    'getNftConfigByTokenId(address,uint256)': FunctionFragment;
    'getNftConfiguration(address)': FunctionFragment;
    'getNftData(address)': FunctionFragment;
    'getNftDebtData(address,uint256)': FunctionFragment;
    'getNftLiquidatePrice(address,uint256)': FunctionFragment;
    'getNftsList()': FunctionFragment;
    'getPausedTime()': FunctionFragment;
    'getReserveConfiguration(address)': FunctionFragment;
    'getReserveData(address)': FunctionFragment;
    'getReserveNormalizedIncome(address)': FunctionFragment;
    'getReserveNormalizedVariableDebt(address)': FunctionFragment;
    'getReservesList()': FunctionFragment;
    'getSafeHealthFactor()': FunctionFragment;
    'getTimeframe()': FunctionFragment;
    'initNft(address,address)': FunctionFragment;
    'initReserve(address,address,address,address)': FunctionFragment;
    'initialize(address)': FunctionFragment;
    'liquidate(address,uint256,uint256)': FunctionFragment;
    'liquidateNFTX(address,uint256,uint256)': FunctionFragment;
    'liquidateSudoSwap(address,uint256,uint256,address,uint256)': FunctionFragment;
    'onERC721Received(address,address,uint256,bytes)': FunctionFragment;
    'paused()': FunctionFragment;
    'redeem(address,uint256,uint256,uint256)': FunctionFragment;
    'repay(address,uint256,uint256)': FunctionFragment;
    'rescue(address,address,uint256,bool)': FunctionFragment;
    'rescueNFT(address,uint256,address)': FunctionFragment;
    'rescuer()': FunctionFragment;
    'setAuctionDurationConfigFee(uint256)': FunctionFragment;
    'setConfigFee(uint256)': FunctionFragment;
    'setIsMarketSupported(address,uint8,bool)': FunctionFragment;
    'setLiquidateFeePercentage(uint256)': FunctionFragment;
    'setMaxNumberOfNfts(uint256)': FunctionFragment;
    'setMaxNumberOfReserves(uint256)': FunctionFragment;
    'setNftConfigByTokenId(address,uint256,uint256)': FunctionFragment;
    'setNftConfiguration(address,uint256)': FunctionFragment;
    'setNftMaxSupplyAndTokenId(address,uint256,uint256)': FunctionFragment;
    'setPause(bool)': FunctionFragment;
    'setPausedTime(uint256,uint256)': FunctionFragment;
    'setReserveConfiguration(address,uint256)': FunctionFragment;
    'setReserveInterestRateAddress(address,address)': FunctionFragment;
    'setTimeframe(uint256)': FunctionFragment;
    'setTreasuryAddress(address,address)': FunctionFragment;
    'updateRescuer(address)': FunctionFragment;
    'updateSafeHealthFactor(uint256)': FunctionFragment;
    'withdraw(address,uint256,address)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'ADDRESS_ID_PUNK_GATEWAY'
      | 'ADDRESS_ID_WETH_GATEWAY'
      | '_isMarketSupported'
      | 'approveValuation'
      | 'auction'
      | 'borrow'
      | 'deposit'
      | 'finalizeTransfer'
      | 'getAddressesProvider'
      | 'getAuctionDurationConfigFee'
      | 'getConfigFee'
      | 'getIsMarketSupported'
      | 'getLiquidateFeePercentage'
      | 'getMaxNumberOfNfts'
      | 'getMaxNumberOfReserves'
      | 'getNftAssetConfig'
      | 'getNftAuctionData'
      | 'getNftCollateralData'
      | 'getNftConfigByTokenId'
      | 'getNftConfiguration'
      | 'getNftData'
      | 'getNftDebtData'
      | 'getNftLiquidatePrice'
      | 'getNftsList'
      | 'getPausedTime'
      | 'getReserveConfiguration'
      | 'getReserveData'
      | 'getReserveNormalizedIncome'
      | 'getReserveNormalizedVariableDebt'
      | 'getReservesList'
      | 'getSafeHealthFactor'
      | 'getTimeframe'
      | 'initNft'
      | 'initReserve'
      | 'initialize'
      | 'liquidate'
      | 'liquidateNFTX'
      | 'liquidateSudoSwap'
      | 'onERC721Received'
      | 'paused'
      | 'redeem'
      | 'repay'
      | 'rescue'
      | 'rescueNFT'
      | 'rescuer'
      | 'setAuctionDurationConfigFee'
      | 'setConfigFee'
      | 'setIsMarketSupported'
      | 'setLiquidateFeePercentage'
      | 'setMaxNumberOfNfts'
      | 'setMaxNumberOfReserves'
      | 'setNftConfigByTokenId'
      | 'setNftConfiguration'
      | 'setNftMaxSupplyAndTokenId'
      | 'setPause'
      | 'setPausedTime'
      | 'setReserveConfiguration'
      | 'setReserveInterestRateAddress'
      | 'setTimeframe'
      | 'setTreasuryAddress'
      | 'updateRescuer'
      | 'updateSafeHealthFactor'
      | 'withdraw',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'ADDRESS_ID_PUNK_GATEWAY', values?: undefined): string;
  encodeFunctionData(functionFragment: 'ADDRESS_ID_WETH_GATEWAY', values?: undefined): string;
  encodeFunctionData(
    functionFragment: '_isMarketSupported',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'approveValuation',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'auction',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'borrow',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'deposit',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'finalizeTransfer',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'getAddressesProvider', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getAuctionDurationConfigFee', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getConfigFee', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'getIsMarketSupported',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'getLiquidateFeePercentage', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getMaxNumberOfNfts', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getMaxNumberOfReserves', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'getNftAssetConfig',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getNftAuctionData',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getNftCollateralData',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getNftConfigByTokenId',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'getNftConfiguration', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getNftData', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'getNftDebtData',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getNftLiquidatePrice',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'getNftsList', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getPausedTime', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getReserveConfiguration', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getReserveData', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getReserveNormalizedIncome', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getReserveNormalizedVariableDebt', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'getReservesList', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getSafeHealthFactor', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getTimeframe', values?: undefined): string;
  encodeFunctionData(functionFragment: 'initNft', values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'initReserve',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'initialize', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'liquidate',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'liquidateNFTX',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'liquidateSudoSwap',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'onERC721Received',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(functionFragment: 'paused', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'redeem',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'repay',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'rescue',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'rescueNFT',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'rescuer', values?: undefined): string;
  encodeFunctionData(functionFragment: 'setAuctionDurationConfigFee', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setConfigFee', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'setIsMarketSupported',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'setLiquidateFeePercentage', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setMaxNumberOfNfts', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'setMaxNumberOfReserves', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'setNftConfigByTokenId',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setNftConfiguration',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setNftMaxSupplyAndTokenId',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'setPause', values: [PromiseOrValue<boolean>]): string;
  encodeFunctionData(
    functionFragment: 'setPausedTime',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setReserveConfiguration',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setReserveInterestRateAddress',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'setTimeframe', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'setTreasuryAddress',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'updateRescuer', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'updateSafeHealthFactor', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'withdraw',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;

  decodeFunctionResult(functionFragment: 'ADDRESS_ID_PUNK_GATEWAY', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'ADDRESS_ID_WETH_GATEWAY', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: '_isMarketSupported', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'approveValuation', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'auction', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'borrow', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'finalizeTransfer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getAddressesProvider', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getAuctionDurationConfigFee', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getConfigFee', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getIsMarketSupported', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getLiquidateFeePercentage', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getMaxNumberOfNfts', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getMaxNumberOfReserves', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getNftAssetConfig', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getNftAuctionData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getNftCollateralData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getNftConfigByTokenId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getNftConfiguration', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getNftData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getNftDebtData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getNftLiquidatePrice', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getNftsList', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPausedTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReserveConfiguration', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReserveData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReserveNormalizedIncome', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReserveNormalizedVariableDebt', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReservesList', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getSafeHealthFactor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getTimeframe', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initNft', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initReserve', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidateNFTX', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidateSudoSwap', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'onERC721Received', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'paused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'redeem', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'repay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rescue', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rescueNFT', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rescuer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setAuctionDurationConfigFee', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setConfigFee', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setIsMarketSupported', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setLiquidateFeePercentage', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMaxNumberOfNfts', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMaxNumberOfReserves', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setNftConfigByTokenId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setNftConfiguration', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setNftMaxSupplyAndTokenId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setPause', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setPausedTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setReserveConfiguration', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setReserveInterestRateAddress', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setTimeframe', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setTreasuryAddress', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateRescuer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateSafeHealthFactor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result;

  events: {
    'Auction(address,address,uint256,address,uint256,address,address,uint256)': EventFragment;
    'Borrow(address,address,uint256,address,uint256,address,uint256,uint256,uint16,uint256)': EventFragment;
    'Deposit(address,address,uint256,address,uint16)': EventFragment;
    'Liquidate(address,address,uint256,uint256,address,uint256,address,uint256)': EventFragment;
    'LiquidateNFTX(address,uint256,uint256,address,uint256,address,uint256)': EventFragment;
    'NftConfigurationByIdChanged(address,uint256,uint256)': EventFragment;
    'NftConfigurationChanged(address,uint256)': EventFragment;
    'Paused()': EventFragment;
    'PausedTimeUpdated(uint256,uint256)': EventFragment;
    'Redeem(address,address,uint256,uint256,address,uint256,address,uint256)': EventFragment;
    'Repay(address,address,uint256,address,uint256,address,uint256)': EventFragment;
    'RescuerChanged(address)': EventFragment;
    'ReserveConfigurationChanged(address,uint256)': EventFragment;
    'ReserveDataUpdated(address,uint256,uint256,uint256,uint256)': EventFragment;
    'ReserveInterestRateAddressChanged(address,address)': EventFragment;
    'SafeHealthFactorUpdated(uint256)': EventFragment;
    'TreasuryAddressUpdated(address,address)': EventFragment;
    'Unpaused()': EventFragment;
    'ValuationApproved(address,address,uint256)': EventFragment;
    'Withdraw(address,address,uint256,address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'Auction'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Borrow'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Deposit'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Liquidate'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LiquidateNFTX'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NftConfigurationByIdChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NftConfigurationChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Paused'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'PausedTimeUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Redeem'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Repay'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RescuerChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ReserveConfigurationChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ReserveDataUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ReserveInterestRateAddressChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SafeHealthFactorUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TreasuryAddressUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Unpaused'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ValuationApproved'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Withdraw'): EventFragment;
}

export interface AuctionEventObject {
  user: string;
  reserve: string;
  bidPrice: BigNumber;
  nftAsset: string;
  nftTokenId: BigNumber;
  onBehalfOf: string;
  borrower: string;
  loanId: BigNumber;
}
export type AuctionEvent = TypedEvent<
  [string, string, BigNumber, string, BigNumber, string, string, BigNumber],
  AuctionEventObject
>;

export type AuctionEventFilter = TypedEventFilter<AuctionEvent>;

export interface BorrowEventObject {
  user: string;
  reserve: string;
  amount: BigNumber;
  nftAsset: string;
  nftTokenId: BigNumber;
  onBehalfOf: string;
  borrowRate: BigNumber;
  loanId: BigNumber;
  referral: number;
  nftConfigFee: BigNumber;
}
export type BorrowEvent = TypedEvent<
  [string, string, BigNumber, string, BigNumber, string, BigNumber, BigNumber, number, BigNumber],
  BorrowEventObject
>;

export type BorrowEventFilter = TypedEventFilter<BorrowEvent>;

export interface DepositEventObject {
  user: string;
  reserve: string;
  amount: BigNumber;
  onBehalfOf: string;
  referral: number;
}
export type DepositEvent = TypedEvent<[string, string, BigNumber, string, number], DepositEventObject>;

export type DepositEventFilter = TypedEventFilter<DepositEvent>;

export interface LiquidateEventObject {
  user: string;
  reserve: string;
  repayAmount: BigNumber;
  remainAmount: BigNumber;
  nftAsset: string;
  nftTokenId: BigNumber;
  borrower: string;
  loanId: BigNumber;
}
export type LiquidateEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, string, BigNumber, string, BigNumber],
  LiquidateEventObject
>;

export type LiquidateEventFilter = TypedEventFilter<LiquidateEvent>;

export interface LiquidateNFTXEventObject {
  reserve: string;
  repayAmount: BigNumber;
  remainAmount: BigNumber;
  nftAsset: string;
  nftTokenId: BigNumber;
  borrower: string;
  loanId: BigNumber;
}
export type LiquidateNFTXEvent = TypedEvent<
  [string, BigNumber, BigNumber, string, BigNumber, string, BigNumber],
  LiquidateNFTXEventObject
>;

export type LiquidateNFTXEventFilter = TypedEventFilter<LiquidateNFTXEvent>;

export interface NftConfigurationByIdChangedEventObject {
  asset: string;
  nftTokenId: BigNumber;
  configuration: BigNumber;
}
export type NftConfigurationByIdChangedEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  NftConfigurationByIdChangedEventObject
>;

export type NftConfigurationByIdChangedEventFilter = TypedEventFilter<NftConfigurationByIdChangedEvent>;

export interface NftConfigurationChangedEventObject {
  asset: string;
  configuration: BigNumber;
}
export type NftConfigurationChangedEvent = TypedEvent<[string, BigNumber], NftConfigurationChangedEventObject>;

export type NftConfigurationChangedEventFilter = TypedEventFilter<NftConfigurationChangedEvent>;

export interface PausedEventObject {}
export type PausedEvent = TypedEvent<[], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface PausedTimeUpdatedEventObject {
  startTime: BigNumber;
  durationTime: BigNumber;
}
export type PausedTimeUpdatedEvent = TypedEvent<[BigNumber, BigNumber], PausedTimeUpdatedEventObject>;

export type PausedTimeUpdatedEventFilter = TypedEventFilter<PausedTimeUpdatedEvent>;

export interface RedeemEventObject {
  user: string;
  reserve: string;
  borrowAmount: BigNumber;
  fineAmount: BigNumber;
  nftAsset: string;
  nftTokenId: BigNumber;
  borrower: string;
  loanId: BigNumber;
}
export type RedeemEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, string, BigNumber, string, BigNumber],
  RedeemEventObject
>;

export type RedeemEventFilter = TypedEventFilter<RedeemEvent>;

export interface RepayEventObject {
  user: string;
  reserve: string;
  amount: BigNumber;
  nftAsset: string;
  nftTokenId: BigNumber;
  borrower: string;
  loanId: BigNumber;
}
export type RepayEvent = TypedEvent<
  [string, string, BigNumber, string, BigNumber, string, BigNumber],
  RepayEventObject
>;

export type RepayEventFilter = TypedEventFilter<RepayEvent>;

export interface RescuerChangedEventObject {
  newRescuer: string;
}
export type RescuerChangedEvent = TypedEvent<[string], RescuerChangedEventObject>;

export type RescuerChangedEventFilter = TypedEventFilter<RescuerChangedEvent>;

export interface ReserveConfigurationChangedEventObject {
  asset: string;
  configuration: BigNumber;
}
export type ReserveConfigurationChangedEvent = TypedEvent<[string, BigNumber], ReserveConfigurationChangedEventObject>;

export type ReserveConfigurationChangedEventFilter = TypedEventFilter<ReserveConfigurationChangedEvent>;

export interface ReserveDataUpdatedEventObject {
  reserve: string;
  liquidityRate: BigNumber;
  variableBorrowRate: BigNumber;
  liquidityIndex: BigNumber;
  variableBorrowIndex: BigNumber;
}
export type ReserveDataUpdatedEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, BigNumber],
  ReserveDataUpdatedEventObject
>;

export type ReserveDataUpdatedEventFilter = TypedEventFilter<ReserveDataUpdatedEvent>;

export interface ReserveInterestRateAddressChangedEventObject {
  asset: string;
  rateAddress: string;
}
export type ReserveInterestRateAddressChangedEvent = TypedEvent<
  [string, string],
  ReserveInterestRateAddressChangedEventObject
>;

export type ReserveInterestRateAddressChangedEventFilter = TypedEventFilter<ReserveInterestRateAddressChangedEvent>;

export interface SafeHealthFactorUpdatedEventObject {
  newSafeHealthFactor: BigNumber;
}
export type SafeHealthFactorUpdatedEvent = TypedEvent<[BigNumber], SafeHealthFactorUpdatedEventObject>;

export type SafeHealthFactorUpdatedEventFilter = TypedEventFilter<SafeHealthFactorUpdatedEvent>;

export interface TreasuryAddressUpdatedEventObject {
  uToken: string;
  treasury: string;
}
export type TreasuryAddressUpdatedEvent = TypedEvent<[string, string], TreasuryAddressUpdatedEventObject>;

export type TreasuryAddressUpdatedEventFilter = TypedEventFilter<TreasuryAddressUpdatedEvent>;

export interface UnpausedEventObject {}
export type UnpausedEvent = TypedEvent<[], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface ValuationApprovedEventObject {
  user: string;
  nftAsset: string;
  nftTokenId: BigNumber;
}
export type ValuationApprovedEvent = TypedEvent<[string, string, BigNumber], ValuationApprovedEventObject>;

export type ValuationApprovedEventFilter = TypedEventFilter<ValuationApprovedEvent>;

export interface WithdrawEventObject {
  user: string;
  reserve: string;
  amount: BigNumber;
  to: string;
}
export type WithdrawEvent = TypedEvent<[string, string, BigNumber, string], WithdrawEventObject>;

export type WithdrawEventFilter = TypedEventFilter<WithdrawEvent>;

export interface UnlockdFinanceLendPool extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: UnlockdFinanceLendPoolInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    ADDRESS_ID_PUNK_GATEWAY(overrides?: CallOverrides): Promise<[string]>;

    ADDRESS_ID_WETH_GATEWAY(overrides?: CallOverrides): Promise<[string]>;

    _isMarketSupported(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    approveValuation(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    auction(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      bidPrice: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    borrow(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      referralCode: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    deposit(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      referralCode: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    finalizeTransfer(
      asset: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      arg2: PromiseOrValue<string>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BigNumberish>,
      arg5: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[void]>;

    getAddressesProvider(overrides?: CallOverrides): Promise<[string]>;

    getAuctionDurationConfigFee(overrides?: CallOverrides): Promise<[BigNumber]>;

    getConfigFee(overrides?: CallOverrides): Promise<[BigNumber]>;

    getIsMarketSupported(
      nftAsset: PromiseOrValue<string>,
      market: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    getLiquidateFeePercentage(overrides?: CallOverrides): Promise<[BigNumber]>;

    getMaxNumberOfNfts(overrides?: CallOverrides): Promise<[BigNumber]>;

    getMaxNumberOfReserves(overrides?: CallOverrides): Promise<[BigNumber]>;

    getNftAssetConfig(
      asset: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[DataTypes.NftConfigurationMapStructOutput]>;

    getNftAuctionData(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, string, BigNumber, BigNumber, BigNumber] & {
        loanId: BigNumber;
        bidderAddress: string;
        bidPrice: BigNumber;
        bidBorrowAmount: BigNumber;
        bidFine: BigNumber;
      }
    >;

    getNftCollateralData(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      reserveAsset: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        totalCollateralInETH: BigNumber;
        totalCollateralInReserve: BigNumber;
        availableBorrowsInETH: BigNumber;
        availableBorrowsInReserve: BigNumber;
        ltv: BigNumber;
        liquidationThreshold: BigNumber;
        liquidationBonus: BigNumber;
      }
    >;

    getNftConfigByTokenId(
      asset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[DataTypes.NftConfigurationMapStructOutput]>;

    getNftConfiguration(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[DataTypes.NftConfigurationMapStructOutput]>;

    getNftData(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[DataTypes.NftDataStructOutput]>;

    getNftDebtData(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, string, BigNumber, BigNumber, BigNumber, BigNumber] & {
        loanId: BigNumber;
        reserveAsset: string;
        totalCollateral: BigNumber;
        totalDebt: BigNumber;
        availableBorrows: BigNumber;
        healthFactor: BigNumber;
      }
    >;

    getNftLiquidatePrice(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        liquidatePrice: BigNumber;
        paybackAmount: BigNumber;
      }
    >;

    getNftsList(overrides?: CallOverrides): Promise<[string[]]>;

    getPausedTime(overrides?: CallOverrides): Promise<[BigNumber, BigNumber]>;

    getReserveConfiguration(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[DataTypes.ReserveConfigurationMapStructOutput]>;

    getReserveData(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[DataTypes.ReserveDataStructOutput]>;

    getReserveNormalizedIncome(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    getReserveNormalizedVariableDebt(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    getReservesList(overrides?: CallOverrides): Promise<[string[]]>;

    getSafeHealthFactor(overrides?: CallOverrides): Promise<[BigNumber]>;

    getTimeframe(overrides?: CallOverrides): Promise<[BigNumber]>;

    initNft(
      asset: PromiseOrValue<string>,
      uNftAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    initReserve(
      asset: PromiseOrValue<string>,
      uTokenAddress: PromiseOrValue<string>,
      debtTokenAddress: PromiseOrValue<string>,
      interestRateAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    initialize(
      provider: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    liquidate(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    liquidateNFTX(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amountOutMin: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    liquidateSudoSwap(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amountOutMin: PromiseOrValue<BigNumberish>,
      LSSVMPair: PromiseOrValue<string>,
      amountOutMinSudoswap: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<[string]>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    redeem(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      bidFine: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    repay(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    rescue(
      tokenContract: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      rescueETH: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    rescueNFT(
      nftAsset: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    rescuer(overrides?: CallOverrides): Promise<[string]>;

    setAuctionDurationConfigFee(
      auctionDurationConfigFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setConfigFee(
      configFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setIsMarketSupported(
      nftAsset: PromiseOrValue<string>,
      market: PromiseOrValue<BigNumberish>,
      val: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setLiquidateFeePercentage(
      percentage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setMaxNumberOfNfts(
      val: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setMaxNumberOfReserves(
      val: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setNftConfigByTokenId(
      asset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      configuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setNftConfiguration(
      asset: PromiseOrValue<string>,
      configuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setNftMaxSupplyAndTokenId(
      asset: PromiseOrValue<string>,
      maxSupply: PromiseOrValue<BigNumberish>,
      maxTokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setPause(
      val: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setPausedTime(
      startTime: PromiseOrValue<BigNumberish>,
      durationTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setReserveConfiguration(
      asset: PromiseOrValue<string>,
      configuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setReserveInterestRateAddress(
      asset: PromiseOrValue<string>,
      rateAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setTimeframe(
      timeframe: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setTreasuryAddress(
      uToken: PromiseOrValue<string>,
      treasury: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateRescuer(
      newRescuer: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateSafeHealthFactor(
      newSafeHealthFactor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    withdraw(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;
  };

  ADDRESS_ID_PUNK_GATEWAY(overrides?: CallOverrides): Promise<string>;

  ADDRESS_ID_WETH_GATEWAY(overrides?: CallOverrides): Promise<string>;

  _isMarketSupported(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  approveValuation(
    nftAsset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  auction(
    nftAsset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    bidPrice: PromiseOrValue<BigNumberish>,
    onBehalfOf: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  borrow(
    asset: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    nftAsset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    onBehalfOf: PromiseOrValue<string>,
    referralCode: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  deposit(
    asset: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    onBehalfOf: PromiseOrValue<string>,
    referralCode: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  finalizeTransfer(
    asset: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    arg2: PromiseOrValue<string>,
    arg3: PromiseOrValue<BigNumberish>,
    arg4: PromiseOrValue<BigNumberish>,
    arg5: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<void>;

  getAddressesProvider(overrides?: CallOverrides): Promise<string>;

  getAuctionDurationConfigFee(overrides?: CallOverrides): Promise<BigNumber>;

  getConfigFee(overrides?: CallOverrides): Promise<BigNumber>;

  getIsMarketSupported(
    nftAsset: PromiseOrValue<string>,
    market: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  getLiquidateFeePercentage(overrides?: CallOverrides): Promise<BigNumber>;

  getMaxNumberOfNfts(overrides?: CallOverrides): Promise<BigNumber>;

  getMaxNumberOfReserves(overrides?: CallOverrides): Promise<BigNumber>;

  getNftAssetConfig(
    asset: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<DataTypes.NftConfigurationMapStructOutput>;

  getNftAuctionData(
    nftAsset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, string, BigNumber, BigNumber, BigNumber] & {
      loanId: BigNumber;
      bidderAddress: string;
      bidPrice: BigNumber;
      bidBorrowAmount: BigNumber;
      bidFine: BigNumber;
    }
  >;

  getNftCollateralData(
    nftAsset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    reserveAsset: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
      totalCollateralInETH: BigNumber;
      totalCollateralInReserve: BigNumber;
      availableBorrowsInETH: BigNumber;
      availableBorrowsInReserve: BigNumber;
      ltv: BigNumber;
      liquidationThreshold: BigNumber;
      liquidationBonus: BigNumber;
    }
  >;

  getNftConfigByTokenId(
    asset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<DataTypes.NftConfigurationMapStructOutput>;

  getNftConfiguration(
    asset: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<DataTypes.NftConfigurationMapStructOutput>;

  getNftData(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<DataTypes.NftDataStructOutput>;

  getNftDebtData(
    nftAsset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, string, BigNumber, BigNumber, BigNumber, BigNumber] & {
      loanId: BigNumber;
      reserveAsset: string;
      totalCollateral: BigNumber;
      totalDebt: BigNumber;
      availableBorrows: BigNumber;
      healthFactor: BigNumber;
    }
  >;

  getNftLiquidatePrice(
    nftAsset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber] & {
      liquidatePrice: BigNumber;
      paybackAmount: BigNumber;
    }
  >;

  getNftsList(overrides?: CallOverrides): Promise<string[]>;

  getPausedTime(overrides?: CallOverrides): Promise<[BigNumber, BigNumber]>;

  getReserveConfiguration(
    asset: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<DataTypes.ReserveConfigurationMapStructOutput>;

  getReserveData(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<DataTypes.ReserveDataStructOutput>;

  getReserveNormalizedIncome(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  getReserveNormalizedVariableDebt(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  getReservesList(overrides?: CallOverrides): Promise<string[]>;

  getSafeHealthFactor(overrides?: CallOverrides): Promise<BigNumber>;

  getTimeframe(overrides?: CallOverrides): Promise<BigNumber>;

  initNft(
    asset: PromiseOrValue<string>,
    uNftAddress: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  initReserve(
    asset: PromiseOrValue<string>,
    uTokenAddress: PromiseOrValue<string>,
    debtTokenAddress: PromiseOrValue<string>,
    interestRateAddress: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  initialize(
    provider: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  liquidate(
    nftAsset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  liquidateNFTX(
    nftAsset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    amountOutMin: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  liquidateSudoSwap(
    nftAsset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    amountOutMin: PromiseOrValue<BigNumberish>,
    LSSVMPair: PromiseOrValue<string>,
    amountOutMinSudoswap: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  onERC721Received(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    arg2: PromiseOrValue<BigNumberish>,
    arg3: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides,
  ): Promise<string>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  redeem(
    nftAsset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    bidFine: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  repay(
    nftAsset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  rescue(
    tokenContract: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    rescueETH: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  rescueNFT(
    nftAsset: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    to: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  rescuer(overrides?: CallOverrides): Promise<string>;

  setAuctionDurationConfigFee(
    auctionDurationConfigFee: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setConfigFee(
    configFee: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setIsMarketSupported(
    nftAsset: PromiseOrValue<string>,
    market: PromiseOrValue<BigNumberish>,
    val: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setLiquidateFeePercentage(
    percentage: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setMaxNumberOfNfts(
    val: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setMaxNumberOfReserves(
    val: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setNftConfigByTokenId(
    asset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    configuration: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setNftConfiguration(
    asset: PromiseOrValue<string>,
    configuration: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setNftMaxSupplyAndTokenId(
    asset: PromiseOrValue<string>,
    maxSupply: PromiseOrValue<BigNumberish>,
    maxTokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setPause(
    val: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setPausedTime(
    startTime: PromiseOrValue<BigNumberish>,
    durationTime: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setReserveConfiguration(
    asset: PromiseOrValue<string>,
    configuration: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setReserveInterestRateAddress(
    asset: PromiseOrValue<string>,
    rateAddress: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setTimeframe(
    timeframe: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setTreasuryAddress(
    uToken: PromiseOrValue<string>,
    treasury: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateRescuer(
    newRescuer: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateSafeHealthFactor(
    newSafeHealthFactor: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  withdraw(
    asset: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    to: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    ADDRESS_ID_PUNK_GATEWAY(overrides?: CallOverrides): Promise<string>;

    ADDRESS_ID_WETH_GATEWAY(overrides?: CallOverrides): Promise<string>;

    _isMarketSupported(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    approveValuation(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    auction(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      bidPrice: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    borrow(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      referralCode: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    deposit(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      referralCode: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    finalizeTransfer(
      asset: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      arg2: PromiseOrValue<string>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BigNumberish>,
      arg5: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    getAddressesProvider(overrides?: CallOverrides): Promise<string>;

    getAuctionDurationConfigFee(overrides?: CallOverrides): Promise<BigNumber>;

    getConfigFee(overrides?: CallOverrides): Promise<BigNumber>;

    getIsMarketSupported(
      nftAsset: PromiseOrValue<string>,
      market: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    getLiquidateFeePercentage(overrides?: CallOverrides): Promise<BigNumber>;

    getMaxNumberOfNfts(overrides?: CallOverrides): Promise<BigNumber>;

    getMaxNumberOfReserves(overrides?: CallOverrides): Promise<BigNumber>;

    getNftAssetConfig(
      asset: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<DataTypes.NftConfigurationMapStructOutput>;

    getNftAuctionData(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, string, BigNumber, BigNumber, BigNumber] & {
        loanId: BigNumber;
        bidderAddress: string;
        bidPrice: BigNumber;
        bidBorrowAmount: BigNumber;
        bidFine: BigNumber;
      }
    >;

    getNftCollateralData(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      reserveAsset: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        totalCollateralInETH: BigNumber;
        totalCollateralInReserve: BigNumber;
        availableBorrowsInETH: BigNumber;
        availableBorrowsInReserve: BigNumber;
        ltv: BigNumber;
        liquidationThreshold: BigNumber;
        liquidationBonus: BigNumber;
      }
    >;

    getNftConfigByTokenId(
      asset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<DataTypes.NftConfigurationMapStructOutput>;

    getNftConfiguration(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<DataTypes.NftConfigurationMapStructOutput>;

    getNftData(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<DataTypes.NftDataStructOutput>;

    getNftDebtData(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, string, BigNumber, BigNumber, BigNumber, BigNumber] & {
        loanId: BigNumber;
        reserveAsset: string;
        totalCollateral: BigNumber;
        totalDebt: BigNumber;
        availableBorrows: BigNumber;
        healthFactor: BigNumber;
      }
    >;

    getNftLiquidatePrice(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        liquidatePrice: BigNumber;
        paybackAmount: BigNumber;
      }
    >;

    getNftsList(overrides?: CallOverrides): Promise<string[]>;

    getPausedTime(overrides?: CallOverrides): Promise<[BigNumber, BigNumber]>;

    getReserveConfiguration(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<DataTypes.ReserveConfigurationMapStructOutput>;

    getReserveData(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<DataTypes.ReserveDataStructOutput>;

    getReserveNormalizedIncome(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getReserveNormalizedVariableDebt(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getReservesList(overrides?: CallOverrides): Promise<string[]>;

    getSafeHealthFactor(overrides?: CallOverrides): Promise<BigNumber>;

    getTimeframe(overrides?: CallOverrides): Promise<BigNumber>;

    initNft(
      asset: PromiseOrValue<string>,
      uNftAddress: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    initReserve(
      asset: PromiseOrValue<string>,
      uTokenAddress: PromiseOrValue<string>,
      debtTokenAddress: PromiseOrValue<string>,
      interestRateAddress: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    initialize(provider: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    liquidate(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    liquidateNFTX(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amountOutMin: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    liquidateSudoSwap(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amountOutMin: PromiseOrValue<BigNumberish>,
      LSSVMPair: PromiseOrValue<string>,
      amountOutMinSudoswap: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<string>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    redeem(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      bidFine: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    repay(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, boolean]>;

    rescue(
      tokenContract: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      rescueETH: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    rescueNFT(
      nftAsset: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    rescuer(overrides?: CallOverrides): Promise<string>;

    setAuctionDurationConfigFee(
      auctionDurationConfigFee: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setConfigFee(configFee: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setIsMarketSupported(
      nftAsset: PromiseOrValue<string>,
      market: PromiseOrValue<BigNumberish>,
      val: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setLiquidateFeePercentage(percentage: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setMaxNumberOfNfts(val: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setMaxNumberOfReserves(val: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setNftConfigByTokenId(
      asset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      configuration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setNftConfiguration(
      asset: PromiseOrValue<string>,
      configuration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setNftMaxSupplyAndTokenId(
      asset: PromiseOrValue<string>,
      maxSupply: PromiseOrValue<BigNumberish>,
      maxTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setPause(val: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;

    setPausedTime(
      startTime: PromiseOrValue<BigNumberish>,
      durationTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setReserveConfiguration(
      asset: PromiseOrValue<string>,
      configuration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setReserveInterestRateAddress(
      asset: PromiseOrValue<string>,
      rateAddress: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setTimeframe(timeframe: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setTreasuryAddress(
      uToken: PromiseOrValue<string>,
      treasury: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    updateRescuer(newRescuer: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    updateSafeHealthFactor(newSafeHealthFactor: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    withdraw(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;
  };

  filters: {
    'Auction(address,address,uint256,address,uint256,address,address,uint256)'(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      bidPrice?: null,
      nftAsset?: PromiseOrValue<string> | null,
      nftTokenId?: null,
      onBehalfOf?: null,
      borrower?: PromiseOrValue<string> | null,
      loanId?: null,
    ): AuctionEventFilter;
    Auction(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      bidPrice?: null,
      nftAsset?: PromiseOrValue<string> | null,
      nftTokenId?: null,
      onBehalfOf?: null,
      borrower?: PromiseOrValue<string> | null,
      loanId?: null,
    ): AuctionEventFilter;

    'Borrow(address,address,uint256,address,uint256,address,uint256,uint256,uint16,uint256)'(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      amount?: null,
      nftAsset?: null,
      nftTokenId?: null,
      onBehalfOf?: PromiseOrValue<string> | null,
      borrowRate?: null,
      loanId?: null,
      referral?: PromiseOrValue<BigNumberish> | null,
      nftConfigFee?: null,
    ): BorrowEventFilter;
    Borrow(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      amount?: null,
      nftAsset?: null,
      nftTokenId?: null,
      onBehalfOf?: PromiseOrValue<string> | null,
      borrowRate?: null,
      loanId?: null,
      referral?: PromiseOrValue<BigNumberish> | null,
      nftConfigFee?: null,
    ): BorrowEventFilter;

    'Deposit(address,address,uint256,address,uint16)'(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      amount?: null,
      onBehalfOf?: PromiseOrValue<string> | null,
      referral?: PromiseOrValue<BigNumberish> | null,
    ): DepositEventFilter;
    Deposit(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      amount?: null,
      onBehalfOf?: PromiseOrValue<string> | null,
      referral?: PromiseOrValue<BigNumberish> | null,
    ): DepositEventFilter;

    'Liquidate(address,address,uint256,uint256,address,uint256,address,uint256)'(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      repayAmount?: null,
      remainAmount?: null,
      nftAsset?: PromiseOrValue<string> | null,
      nftTokenId?: null,
      borrower?: PromiseOrValue<string> | null,
      loanId?: null,
    ): LiquidateEventFilter;
    Liquidate(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      repayAmount?: null,
      remainAmount?: null,
      nftAsset?: PromiseOrValue<string> | null,
      nftTokenId?: null,
      borrower?: PromiseOrValue<string> | null,
      loanId?: null,
    ): LiquidateEventFilter;

    'LiquidateNFTX(address,uint256,uint256,address,uint256,address,uint256)'(
      reserve?: PromiseOrValue<string> | null,
      repayAmount?: null,
      remainAmount?: null,
      nftAsset?: PromiseOrValue<string> | null,
      nftTokenId?: null,
      borrower?: PromiseOrValue<string> | null,
      loanId?: null,
    ): LiquidateNFTXEventFilter;
    LiquidateNFTX(
      reserve?: PromiseOrValue<string> | null,
      repayAmount?: null,
      remainAmount?: null,
      nftAsset?: PromiseOrValue<string> | null,
      nftTokenId?: null,
      borrower?: PromiseOrValue<string> | null,
      loanId?: null,
    ): LiquidateNFTXEventFilter;

    'NftConfigurationByIdChanged(address,uint256,uint256)'(
      asset?: PromiseOrValue<string> | null,
      nftTokenId?: PromiseOrValue<BigNumberish> | null,
      configuration?: null,
    ): NftConfigurationByIdChangedEventFilter;
    NftConfigurationByIdChanged(
      asset?: PromiseOrValue<string> | null,
      nftTokenId?: PromiseOrValue<BigNumberish> | null,
      configuration?: null,
    ): NftConfigurationByIdChangedEventFilter;

    'NftConfigurationChanged(address,uint256)'(
      asset?: PromiseOrValue<string> | null,
      configuration?: null,
    ): NftConfigurationChangedEventFilter;
    NftConfigurationChanged(
      asset?: PromiseOrValue<string> | null,
      configuration?: null,
    ): NftConfigurationChangedEventFilter;

    'Paused()'(): PausedEventFilter;
    Paused(): PausedEventFilter;

    'PausedTimeUpdated(uint256,uint256)'(startTime?: null, durationTime?: null): PausedTimeUpdatedEventFilter;
    PausedTimeUpdated(startTime?: null, durationTime?: null): PausedTimeUpdatedEventFilter;

    'Redeem(address,address,uint256,uint256,address,uint256,address,uint256)'(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      borrowAmount?: null,
      fineAmount?: null,
      nftAsset?: PromiseOrValue<string> | null,
      nftTokenId?: null,
      borrower?: PromiseOrValue<string> | null,
      loanId?: null,
    ): RedeemEventFilter;
    Redeem(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      borrowAmount?: null,
      fineAmount?: null,
      nftAsset?: PromiseOrValue<string> | null,
      nftTokenId?: null,
      borrower?: PromiseOrValue<string> | null,
      loanId?: null,
    ): RedeemEventFilter;

    'Repay(address,address,uint256,address,uint256,address,uint256)'(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      amount?: null,
      nftAsset?: PromiseOrValue<string> | null,
      nftTokenId?: null,
      borrower?: PromiseOrValue<string> | null,
      loanId?: null,
    ): RepayEventFilter;
    Repay(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      amount?: null,
      nftAsset?: PromiseOrValue<string> | null,
      nftTokenId?: null,
      borrower?: PromiseOrValue<string> | null,
      loanId?: null,
    ): RepayEventFilter;

    'RescuerChanged(address)'(newRescuer?: PromiseOrValue<string> | null): RescuerChangedEventFilter;
    RescuerChanged(newRescuer?: PromiseOrValue<string> | null): RescuerChangedEventFilter;

    'ReserveConfigurationChanged(address,uint256)'(
      asset?: PromiseOrValue<string> | null,
      configuration?: null,
    ): ReserveConfigurationChangedEventFilter;
    ReserveConfigurationChanged(
      asset?: PromiseOrValue<string> | null,
      configuration?: null,
    ): ReserveConfigurationChangedEventFilter;

    'ReserveDataUpdated(address,uint256,uint256,uint256,uint256)'(
      reserve?: PromiseOrValue<string> | null,
      liquidityRate?: null,
      variableBorrowRate?: null,
      liquidityIndex?: null,
      variableBorrowIndex?: null,
    ): ReserveDataUpdatedEventFilter;
    ReserveDataUpdated(
      reserve?: PromiseOrValue<string> | null,
      liquidityRate?: null,
      variableBorrowRate?: null,
      liquidityIndex?: null,
      variableBorrowIndex?: null,
    ): ReserveDataUpdatedEventFilter;

    'ReserveInterestRateAddressChanged(address,address)'(
      asset?: PromiseOrValue<string> | null,
      rateAddress?: PromiseOrValue<string> | null,
    ): ReserveInterestRateAddressChangedEventFilter;
    ReserveInterestRateAddressChanged(
      asset?: PromiseOrValue<string> | null,
      rateAddress?: PromiseOrValue<string> | null,
    ): ReserveInterestRateAddressChangedEventFilter;

    'SafeHealthFactorUpdated(uint256)'(
      newSafeHealthFactor?: PromiseOrValue<BigNumberish> | null,
    ): SafeHealthFactorUpdatedEventFilter;
    SafeHealthFactorUpdated(
      newSafeHealthFactor?: PromiseOrValue<BigNumberish> | null,
    ): SafeHealthFactorUpdatedEventFilter;

    'TreasuryAddressUpdated(address,address)'(
      uToken?: PromiseOrValue<string> | null,
      treasury?: PromiseOrValue<string> | null,
    ): TreasuryAddressUpdatedEventFilter;
    TreasuryAddressUpdated(
      uToken?: PromiseOrValue<string> | null,
      treasury?: PromiseOrValue<string> | null,
    ): TreasuryAddressUpdatedEventFilter;

    'Unpaused()'(): UnpausedEventFilter;
    Unpaused(): UnpausedEventFilter;

    'ValuationApproved(address,address,uint256)'(
      user?: PromiseOrValue<string> | null,
      nftAsset?: PromiseOrValue<string> | null,
      nftTokenId?: PromiseOrValue<BigNumberish> | null,
    ): ValuationApprovedEventFilter;
    ValuationApproved(
      user?: PromiseOrValue<string> | null,
      nftAsset?: PromiseOrValue<string> | null,
      nftTokenId?: PromiseOrValue<BigNumberish> | null,
    ): ValuationApprovedEventFilter;

    'Withdraw(address,address,uint256,address)'(
      user?: PromiseOrValue<string> | null,
      reserve?: PromiseOrValue<string> | null,
      amount?: null,
      to?: PromiseOrValue<string> | null,
    ): WithdrawEventFilter;
    Withdraw(
      user?: PromiseOrValue<string> | null,
      reserve?: PromiseOrValue<string> | null,
      amount?: null,
      to?: PromiseOrValue<string> | null,
    ): WithdrawEventFilter;
  };

  estimateGas: {
    ADDRESS_ID_PUNK_GATEWAY(overrides?: CallOverrides): Promise<BigNumber>;

    ADDRESS_ID_WETH_GATEWAY(overrides?: CallOverrides): Promise<BigNumber>;

    _isMarketSupported(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    approveValuation(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    auction(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      bidPrice: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    borrow(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      referralCode: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    deposit(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      referralCode: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    finalizeTransfer(
      asset: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      arg2: PromiseOrValue<string>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BigNumberish>,
      arg5: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getAddressesProvider(overrides?: CallOverrides): Promise<BigNumber>;

    getAuctionDurationConfigFee(overrides?: CallOverrides): Promise<BigNumber>;

    getConfigFee(overrides?: CallOverrides): Promise<BigNumber>;

    getIsMarketSupported(
      nftAsset: PromiseOrValue<string>,
      market: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getLiquidateFeePercentage(overrides?: CallOverrides): Promise<BigNumber>;

    getMaxNumberOfNfts(overrides?: CallOverrides): Promise<BigNumber>;

    getMaxNumberOfReserves(overrides?: CallOverrides): Promise<BigNumber>;

    getNftAssetConfig(
      asset: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getNftAuctionData(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getNftCollateralData(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      reserveAsset: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getNftConfigByTokenId(
      asset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getNftConfiguration(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getNftData(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getNftDebtData(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getNftLiquidatePrice(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getNftsList(overrides?: CallOverrides): Promise<BigNumber>;

    getPausedTime(overrides?: CallOverrides): Promise<BigNumber>;

    getReserveConfiguration(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getReserveData(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getReserveNormalizedIncome(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getReserveNormalizedVariableDebt(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getReservesList(overrides?: CallOverrides): Promise<BigNumber>;

    getSafeHealthFactor(overrides?: CallOverrides): Promise<BigNumber>;

    getTimeframe(overrides?: CallOverrides): Promise<BigNumber>;

    initNft(
      asset: PromiseOrValue<string>,
      uNftAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    initReserve(
      asset: PromiseOrValue<string>,
      uTokenAddress: PromiseOrValue<string>,
      debtTokenAddress: PromiseOrValue<string>,
      interestRateAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    initialize(
      provider: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    liquidate(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    liquidateNFTX(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amountOutMin: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    liquidateSudoSwap(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amountOutMin: PromiseOrValue<BigNumberish>,
      LSSVMPair: PromiseOrValue<string>,
      amountOutMinSudoswap: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    redeem(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      bidFine: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    repay(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    rescue(
      tokenContract: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      rescueETH: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    rescueNFT(
      nftAsset: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    rescuer(overrides?: CallOverrides): Promise<BigNumber>;

    setAuctionDurationConfigFee(
      auctionDurationConfigFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setConfigFee(
      configFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setIsMarketSupported(
      nftAsset: PromiseOrValue<string>,
      market: PromiseOrValue<BigNumberish>,
      val: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setLiquidateFeePercentage(
      percentage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setMaxNumberOfNfts(
      val: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setMaxNumberOfReserves(
      val: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setNftConfigByTokenId(
      asset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      configuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setNftConfiguration(
      asset: PromiseOrValue<string>,
      configuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setNftMaxSupplyAndTokenId(
      asset: PromiseOrValue<string>,
      maxSupply: PromiseOrValue<BigNumberish>,
      maxTokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setPause(
      val: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setPausedTime(
      startTime: PromiseOrValue<BigNumberish>,
      durationTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setReserveConfiguration(
      asset: PromiseOrValue<string>,
      configuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setReserveInterestRateAddress(
      asset: PromiseOrValue<string>,
      rateAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setTimeframe(
      timeframe: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setTreasuryAddress(
      uToken: PromiseOrValue<string>,
      treasury: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateRescuer(
      newRescuer: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateSafeHealthFactor(
      newSafeHealthFactor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    withdraw(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    ADDRESS_ID_PUNK_GATEWAY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ADDRESS_ID_WETH_GATEWAY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    _isMarketSupported(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    approveValuation(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    auction(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      bidPrice: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    borrow(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      referralCode: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    deposit(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      referralCode: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    finalizeTransfer(
      asset: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      arg2: PromiseOrValue<string>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BigNumberish>,
      arg5: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getAddressesProvider(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getAuctionDurationConfigFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getConfigFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getIsMarketSupported(
      nftAsset: PromiseOrValue<string>,
      market: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getLiquidateFeePercentage(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getMaxNumberOfNfts(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getMaxNumberOfReserves(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getNftAssetConfig(
      asset: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getNftAuctionData(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getNftCollateralData(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      reserveAsset: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getNftConfigByTokenId(
      asset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getNftConfiguration(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getNftData(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getNftDebtData(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getNftLiquidatePrice(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getNftsList(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getPausedTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getReserveConfiguration(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getReserveData(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getReserveNormalizedIncome(asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getReserveNormalizedVariableDebt(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getReservesList(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getSafeHealthFactor(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getTimeframe(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initNft(
      asset: PromiseOrValue<string>,
      uNftAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    initReserve(
      asset: PromiseOrValue<string>,
      uTokenAddress: PromiseOrValue<string>,
      debtTokenAddress: PromiseOrValue<string>,
      interestRateAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    initialize(
      provider: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    liquidate(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    liquidateNFTX(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amountOutMin: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    liquidateSudoSwap(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amountOutMin: PromiseOrValue<BigNumberish>,
      LSSVMPair: PromiseOrValue<string>,
      amountOutMinSudoswap: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    redeem(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      bidFine: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    repay(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    rescue(
      tokenContract: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      rescueETH: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    rescueNFT(
      nftAsset: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    rescuer(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setAuctionDurationConfigFee(
      auctionDurationConfigFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setConfigFee(
      configFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setIsMarketSupported(
      nftAsset: PromiseOrValue<string>,
      market: PromiseOrValue<BigNumberish>,
      val: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setLiquidateFeePercentage(
      percentage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setMaxNumberOfNfts(
      val: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setMaxNumberOfReserves(
      val: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setNftConfigByTokenId(
      asset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      configuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setNftConfiguration(
      asset: PromiseOrValue<string>,
      configuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setNftMaxSupplyAndTokenId(
      asset: PromiseOrValue<string>,
      maxSupply: PromiseOrValue<BigNumberish>,
      maxTokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setPause(
      val: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setPausedTime(
      startTime: PromiseOrValue<BigNumberish>,
      durationTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setReserveConfiguration(
      asset: PromiseOrValue<string>,
      configuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setReserveInterestRateAddress(
      asset: PromiseOrValue<string>,
      rateAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setTimeframe(
      timeframe: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setTreasuryAddress(
      uToken: PromiseOrValue<string>,
      treasury: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateRescuer(
      newRescuer: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateSafeHealthFactor(
      newSafeHealthFactor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    withdraw(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;
  };
}

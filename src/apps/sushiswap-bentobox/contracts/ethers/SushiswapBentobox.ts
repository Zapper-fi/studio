/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from './common';

export interface SushiswapBentoboxInterface extends utils.Interface {
  functions: {
    'DOMAIN_SEPARATOR()': FunctionFragment;
    'balanceOf(address,address)': FunctionFragment;
    'batch(bytes[],bool)': FunctionFragment;
    'batchFlashLoan(address,address[],address[],uint256[],bytes)': FunctionFragment;
    'claimOwnership()': FunctionFragment;
    'deploy(address,bytes,bool)': FunctionFragment;
    'deposit(address,address,address,uint256,uint256)': FunctionFragment;
    'flashLoan(address,address,address,uint256,bytes)': FunctionFragment;
    'harvest(address,bool,uint256)': FunctionFragment;
    'masterContractApproved(address,address)': FunctionFragment;
    'masterContractOf(address)': FunctionFragment;
    'nonces(address)': FunctionFragment;
    'owner()': FunctionFragment;
    'pendingOwner()': FunctionFragment;
    'pendingStrategy(address)': FunctionFragment;
    'permitToken(address,address,address,uint256,uint256,uint8,bytes32,bytes32)': FunctionFragment;
    'registerProtocol()': FunctionFragment;
    'setMasterContractApproval(address,address,bool,uint8,bytes32,bytes32)': FunctionFragment;
    'setStrategy(address,address)': FunctionFragment;
    'setStrategyTargetPercentage(address,uint64)': FunctionFragment;
    'strategy(address)': FunctionFragment;
    'strategyData(address)': FunctionFragment;
    'toAmount(address,uint256,bool)': FunctionFragment;
    'toShare(address,uint256,bool)': FunctionFragment;
    'totals(address)': FunctionFragment;
    'transfer(address,address,address,uint256)': FunctionFragment;
    'transferMultiple(address,address,address[],uint256[])': FunctionFragment;
    'transferOwnership(address,bool,bool)': FunctionFragment;
    'whitelistMasterContract(address,bool)': FunctionFragment;
    'whitelistedMasterContracts(address)': FunctionFragment;
    'withdraw(address,address,address,uint256,uint256)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'DOMAIN_SEPARATOR'
      | 'balanceOf'
      | 'batch'
      | 'batchFlashLoan'
      | 'claimOwnership'
      | 'deploy'
      | 'deposit'
      | 'flashLoan'
      | 'harvest'
      | 'masterContractApproved'
      | 'masterContractOf'
      | 'nonces'
      | 'owner'
      | 'pendingOwner'
      | 'pendingStrategy'
      | 'permitToken'
      | 'registerProtocol'
      | 'setMasterContractApproval'
      | 'setStrategy'
      | 'setStrategyTargetPercentage'
      | 'strategy'
      | 'strategyData'
      | 'toAmount'
      | 'toShare'
      | 'totals'
      | 'transfer'
      | 'transferMultiple'
      | 'transferOwnership'
      | 'whitelistMasterContract'
      | 'whitelistedMasterContracts'
      | 'withdraw',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'DOMAIN_SEPARATOR', values?: undefined): string;
  encodeFunctionData(functionFragment: 'balanceOf', values: [string, string]): string;
  encodeFunctionData(functionFragment: 'batch', values: [BytesLike[], boolean]): string;
  encodeFunctionData(
    functionFragment: 'batchFlashLoan',
    values: [string, string[], string[], BigNumberish[], BytesLike],
  ): string;
  encodeFunctionData(functionFragment: 'claimOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'deploy', values: [string, BytesLike, boolean]): string;
  encodeFunctionData(functionFragment: 'deposit', values: [string, string, string, BigNumberish, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'flashLoan', values: [string, string, string, BigNumberish, BytesLike]): string;
  encodeFunctionData(functionFragment: 'harvest', values: [string, boolean, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'masterContractApproved', values: [string, string]): string;
  encodeFunctionData(functionFragment: 'masterContractOf', values: [string]): string;
  encodeFunctionData(functionFragment: 'nonces', values: [string]): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pendingOwner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pendingStrategy', values: [string]): string;
  encodeFunctionData(
    functionFragment: 'permitToken',
    values: [string, string, string, BigNumberish, BigNumberish, BigNumberish, BytesLike, BytesLike],
  ): string;
  encodeFunctionData(functionFragment: 'registerProtocol', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'setMasterContractApproval',
    values: [string, string, boolean, BigNumberish, BytesLike, BytesLike],
  ): string;
  encodeFunctionData(functionFragment: 'setStrategy', values: [string, string]): string;
  encodeFunctionData(functionFragment: 'setStrategyTargetPercentage', values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'strategy', values: [string]): string;
  encodeFunctionData(functionFragment: 'strategyData', values: [string]): string;
  encodeFunctionData(functionFragment: 'toAmount', values: [string, BigNumberish, boolean]): string;
  encodeFunctionData(functionFragment: 'toShare', values: [string, BigNumberish, boolean]): string;
  encodeFunctionData(functionFragment: 'totals', values: [string]): string;
  encodeFunctionData(functionFragment: 'transfer', values: [string, string, string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'transferMultiple', values: [string, string, string[], BigNumberish[]]): string;
  encodeFunctionData(functionFragment: 'transferOwnership', values: [string, boolean, boolean]): string;
  encodeFunctionData(functionFragment: 'whitelistMasterContract', values: [string, boolean]): string;
  encodeFunctionData(functionFragment: 'whitelistedMasterContracts', values: [string]): string;
  encodeFunctionData(
    functionFragment: 'withdraw',
    values: [string, string, string, BigNumberish, BigNumberish],
  ): string;

  decodeFunctionResult(functionFragment: 'DOMAIN_SEPARATOR', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'batch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'batchFlashLoan', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deploy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'flashLoan', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'harvest', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'masterContractApproved', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'masterContractOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nonces', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pendingOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pendingStrategy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'permitToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'registerProtocol', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMasterContractApproval', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setStrategy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setStrategyTargetPercentage', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'strategy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'strategyData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'toAmount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'toShare', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totals', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transfer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferMultiple', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'whitelistMasterContract', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'whitelistedMasterContracts', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result;

  events: {
    'LogDeploy(address,bytes,address)': EventFragment;
    'LogDeposit(address,address,address,uint256,uint256)': EventFragment;
    'LogFlashLoan(address,address,uint256,uint256,address)': EventFragment;
    'LogRegisterProtocol(address)': EventFragment;
    'LogSetMasterContractApproval(address,address,bool)': EventFragment;
    'LogStrategyDivest(address,uint256)': EventFragment;
    'LogStrategyInvest(address,uint256)': EventFragment;
    'LogStrategyLoss(address,uint256)': EventFragment;
    'LogStrategyProfit(address,uint256)': EventFragment;
    'LogStrategyQueued(address,address)': EventFragment;
    'LogStrategySet(address,address)': EventFragment;
    'LogStrategyTargetPercentage(address,uint256)': EventFragment;
    'LogTransfer(address,address,address,uint256)': EventFragment;
    'LogWhiteListMasterContract(address,bool)': EventFragment;
    'LogWithdraw(address,address,address,uint256,uint256)': EventFragment;
    'OwnershipTransferred(address,address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'LogDeploy'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogDeposit'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogFlashLoan'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogRegisterProtocol'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogSetMasterContractApproval'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogStrategyDivest'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogStrategyInvest'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogStrategyLoss'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogStrategyProfit'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogStrategyQueued'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogStrategySet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogStrategyTargetPercentage'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogTransfer'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogWhiteListMasterContract'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogWithdraw'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
}

export interface LogDeployEventObject {
  masterContract: string;
  data: string;
  cloneAddress: string;
}
export type LogDeployEvent = TypedEvent<[string, string, string], LogDeployEventObject>;

export type LogDeployEventFilter = TypedEventFilter<LogDeployEvent>;

export interface LogDepositEventObject {
  token: string;
  from: string;
  to: string;
  amount: BigNumber;
  share: BigNumber;
}
export type LogDepositEvent = TypedEvent<[string, string, string, BigNumber, BigNumber], LogDepositEventObject>;

export type LogDepositEventFilter = TypedEventFilter<LogDepositEvent>;

export interface LogFlashLoanEventObject {
  borrower: string;
  token: string;
  amount: BigNumber;
  feeAmount: BigNumber;
  receiver: string;
}
export type LogFlashLoanEvent = TypedEvent<[string, string, BigNumber, BigNumber, string], LogFlashLoanEventObject>;

export type LogFlashLoanEventFilter = TypedEventFilter<LogFlashLoanEvent>;

export interface LogRegisterProtocolEventObject {
  protocol: string;
}
export type LogRegisterProtocolEvent = TypedEvent<[string], LogRegisterProtocolEventObject>;

export type LogRegisterProtocolEventFilter = TypedEventFilter<LogRegisterProtocolEvent>;

export interface LogSetMasterContractApprovalEventObject {
  masterContract: string;
  user: string;
  approved: boolean;
}
export type LogSetMasterContractApprovalEvent = TypedEvent<
  [string, string, boolean],
  LogSetMasterContractApprovalEventObject
>;

export type LogSetMasterContractApprovalEventFilter = TypedEventFilter<LogSetMasterContractApprovalEvent>;

export interface LogStrategyDivestEventObject {
  token: string;
  amount: BigNumber;
}
export type LogStrategyDivestEvent = TypedEvent<[string, BigNumber], LogStrategyDivestEventObject>;

export type LogStrategyDivestEventFilter = TypedEventFilter<LogStrategyDivestEvent>;

export interface LogStrategyInvestEventObject {
  token: string;
  amount: BigNumber;
}
export type LogStrategyInvestEvent = TypedEvent<[string, BigNumber], LogStrategyInvestEventObject>;

export type LogStrategyInvestEventFilter = TypedEventFilter<LogStrategyInvestEvent>;

export interface LogStrategyLossEventObject {
  token: string;
  amount: BigNumber;
}
export type LogStrategyLossEvent = TypedEvent<[string, BigNumber], LogStrategyLossEventObject>;

export type LogStrategyLossEventFilter = TypedEventFilter<LogStrategyLossEvent>;

export interface LogStrategyProfitEventObject {
  token: string;
  amount: BigNumber;
}
export type LogStrategyProfitEvent = TypedEvent<[string, BigNumber], LogStrategyProfitEventObject>;

export type LogStrategyProfitEventFilter = TypedEventFilter<LogStrategyProfitEvent>;

export interface LogStrategyQueuedEventObject {
  token: string;
  strategy: string;
}
export type LogStrategyQueuedEvent = TypedEvent<[string, string], LogStrategyQueuedEventObject>;

export type LogStrategyQueuedEventFilter = TypedEventFilter<LogStrategyQueuedEvent>;

export interface LogStrategySetEventObject {
  token: string;
  strategy: string;
}
export type LogStrategySetEvent = TypedEvent<[string, string], LogStrategySetEventObject>;

export type LogStrategySetEventFilter = TypedEventFilter<LogStrategySetEvent>;

export interface LogStrategyTargetPercentageEventObject {
  token: string;
  targetPercentage: BigNumber;
}
export type LogStrategyTargetPercentageEvent = TypedEvent<[string, BigNumber], LogStrategyTargetPercentageEventObject>;

export type LogStrategyTargetPercentageEventFilter = TypedEventFilter<LogStrategyTargetPercentageEvent>;

export interface LogTransferEventObject {
  token: string;
  from: string;
  to: string;
  share: BigNumber;
}
export type LogTransferEvent = TypedEvent<[string, string, string, BigNumber], LogTransferEventObject>;

export type LogTransferEventFilter = TypedEventFilter<LogTransferEvent>;

export interface LogWhiteListMasterContractEventObject {
  masterContract: string;
  approved: boolean;
}
export type LogWhiteListMasterContractEvent = TypedEvent<[string, boolean], LogWhiteListMasterContractEventObject>;

export type LogWhiteListMasterContractEventFilter = TypedEventFilter<LogWhiteListMasterContractEvent>;

export interface LogWithdrawEventObject {
  token: string;
  from: string;
  to: string;
  amount: BigNumber;
  share: BigNumber;
}
export type LogWithdrawEvent = TypedEvent<[string, string, string, BigNumber, BigNumber], LogWithdrawEventObject>;

export type LogWithdrawEventFilter = TypedEventFilter<LogWithdrawEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<[string, string], OwnershipTransferredEventObject>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export interface SushiswapBentobox extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: SushiswapBentoboxInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;

    balanceOf(arg0: string, arg1: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    batch(
      calls: BytesLike[],
      revertOnFail: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    batchFlashLoan(
      borrower: string,
      receivers: string[],
      tokens: string[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    claimOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    deploy(
      masterContract: string,
      data: BytesLike,
      useCreate2: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    deposit(
      token_: string,
      from: string,
      to: string,
      amount: BigNumberish,
      share: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    flashLoan(
      borrower: string,
      receiver: string,
      token: string,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    harvest(
      token: string,
      balance: boolean,
      maxChangeAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    masterContractApproved(arg0: string, arg1: string, overrides?: CallOverrides): Promise<[boolean]>;

    masterContractOf(arg0: string, overrides?: CallOverrides): Promise<[string]>;

    nonces(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pendingOwner(overrides?: CallOverrides): Promise<[string]>;

    pendingStrategy(arg0: string, overrides?: CallOverrides): Promise<[string]>;

    permitToken(
      token: string,
      from: string,
      to: string,
      amount: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    registerProtocol(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    setMasterContractApproval(
      user: string,
      masterContract: string,
      approved: boolean,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    setStrategy(
      token: string,
      newStrategy: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    setStrategyTargetPercentage(
      token: string,
      targetPercentage_: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    strategy(arg0: string, overrides?: CallOverrides): Promise<[string]>;

    strategyData(
      arg0: string,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        strategyStartDate: BigNumber;
        targetPercentage: BigNumber;
        balance: BigNumber;
      }
    >;

    toAmount(
      token: string,
      share: BigNumberish,
      roundUp: boolean,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { amount: BigNumber }>;

    toShare(
      token: string,
      amount: BigNumberish,
      roundUp: boolean,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { share: BigNumber }>;

    totals(
      arg0: string,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { elastic: BigNumber; base: BigNumber }>;

    transfer(
      token: string,
      from: string,
      to: string,
      share: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    transferMultiple(
      token: string,
      from: string,
      tos: string[],
      shares: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: string,
      direct: boolean,
      renounce: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    whitelistMasterContract(
      masterContract: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    whitelistedMasterContracts(arg0: string, overrides?: CallOverrides): Promise<[boolean]>;

    withdraw(
      token_: string,
      from: string,
      to: string,
      amount: BigNumberish,
      share: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;
  };

  DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

  balanceOf(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;

  batch(
    calls: BytesLike[],
    revertOnFail: boolean,
    overrides?: PayableOverrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  batchFlashLoan(
    borrower: string,
    receivers: string[],
    tokens: string[],
    amounts: BigNumberish[],
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  claimOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  deploy(
    masterContract: string,
    data: BytesLike,
    useCreate2: boolean,
    overrides?: PayableOverrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  deposit(
    token_: string,
    from: string,
    to: string,
    amount: BigNumberish,
    share: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  flashLoan(
    borrower: string,
    receiver: string,
    token: string,
    amount: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  harvest(
    token: string,
    balance: boolean,
    maxChangeAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  masterContractApproved(arg0: string, arg1: string, overrides?: CallOverrides): Promise<boolean>;

  masterContractOf(arg0: string, overrides?: CallOverrides): Promise<string>;

  nonces(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  pendingOwner(overrides?: CallOverrides): Promise<string>;

  pendingStrategy(arg0: string, overrides?: CallOverrides): Promise<string>;

  permitToken(
    token: string,
    from: string,
    to: string,
    amount: BigNumberish,
    deadline: BigNumberish,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  registerProtocol(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  setMasterContractApproval(
    user: string,
    masterContract: string,
    approved: boolean,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  setStrategy(
    token: string,
    newStrategy: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  setStrategyTargetPercentage(
    token: string,
    targetPercentage_: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  strategy(arg0: string, overrides?: CallOverrides): Promise<string>;

  strategyData(
    arg0: string,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      strategyStartDate: BigNumber;
      targetPercentage: BigNumber;
      balance: BigNumber;
    }
  >;

  toAmount(token: string, share: BigNumberish, roundUp: boolean, overrides?: CallOverrides): Promise<BigNumber>;

  toShare(token: string, amount: BigNumberish, roundUp: boolean, overrides?: CallOverrides): Promise<BigNumber>;

  totals(
    arg0: string,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, BigNumber] & { elastic: BigNumber; base: BigNumber }>;

  transfer(
    token: string,
    from: string,
    to: string,
    share: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  transferMultiple(
    token: string,
    from: string,
    tos: string[],
    shares: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: string,
    direct: boolean,
    renounce: boolean,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  whitelistMasterContract(
    masterContract: string,
    approved: boolean,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  whitelistedMasterContracts(arg0: string, overrides?: CallOverrides): Promise<boolean>;

  withdraw(
    token_: string,
    from: string,
    to: string,
    amount: BigNumberish,
    share: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

    balanceOf(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;

    batch(
      calls: BytesLike[],
      revertOnFail: boolean,
      overrides?: CallOverrides,
    ): Promise<[boolean[], string[]] & { successes: boolean[]; results: string[] }>;

    batchFlashLoan(
      borrower: string,
      receivers: string[],
      tokens: string[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: CallOverrides,
    ): Promise<void>;

    claimOwnership(overrides?: CallOverrides): Promise<void>;

    deploy(masterContract: string, data: BytesLike, useCreate2: boolean, overrides?: CallOverrides): Promise<string>;

    deposit(
      token_: string,
      from: string,
      to: string,
      amount: BigNumberish,
      share: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { amountOut: BigNumber; shareOut: BigNumber }>;

    flashLoan(
      borrower: string,
      receiver: string,
      token: string,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides,
    ): Promise<void>;

    harvest(token: string, balance: boolean, maxChangeAmount: BigNumberish, overrides?: CallOverrides): Promise<void>;

    masterContractApproved(arg0: string, arg1: string, overrides?: CallOverrides): Promise<boolean>;

    masterContractOf(arg0: string, overrides?: CallOverrides): Promise<string>;

    nonces(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    pendingOwner(overrides?: CallOverrides): Promise<string>;

    pendingStrategy(arg0: string, overrides?: CallOverrides): Promise<string>;

    permitToken(
      token: string,
      from: string,
      to: string,
      amount: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides,
    ): Promise<void>;

    registerProtocol(overrides?: CallOverrides): Promise<void>;

    setMasterContractApproval(
      user: string,
      masterContract: string,
      approved: boolean,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides,
    ): Promise<void>;

    setStrategy(token: string, newStrategy: string, overrides?: CallOverrides): Promise<void>;

    setStrategyTargetPercentage(
      token: string,
      targetPercentage_: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<void>;

    strategy(arg0: string, overrides?: CallOverrides): Promise<string>;

    strategyData(
      arg0: string,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        strategyStartDate: BigNumber;
        targetPercentage: BigNumber;
        balance: BigNumber;
      }
    >;

    toAmount(token: string, share: BigNumberish, roundUp: boolean, overrides?: CallOverrides): Promise<BigNumber>;

    toShare(token: string, amount: BigNumberish, roundUp: boolean, overrides?: CallOverrides): Promise<BigNumber>;

    totals(
      arg0: string,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { elastic: BigNumber; base: BigNumber }>;

    transfer(token: string, from: string, to: string, share: BigNumberish, overrides?: CallOverrides): Promise<void>;

    transferMultiple(
      token: string,
      from: string,
      tos: string[],
      shares: BigNumberish[],
      overrides?: CallOverrides,
    ): Promise<void>;

    transferOwnership(newOwner: string, direct: boolean, renounce: boolean, overrides?: CallOverrides): Promise<void>;

    whitelistMasterContract(masterContract: string, approved: boolean, overrides?: CallOverrides): Promise<void>;

    whitelistedMasterContracts(arg0: string, overrides?: CallOverrides): Promise<boolean>;

    withdraw(
      token_: string,
      from: string,
      to: string,
      amount: BigNumberish,
      share: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { amountOut: BigNumber; shareOut: BigNumber }>;
  };

  filters: {
    'LogDeploy(address,bytes,address)'(
      masterContract?: string | null,
      data?: null,
      cloneAddress?: string | null,
    ): LogDeployEventFilter;
    LogDeploy(masterContract?: string | null, data?: null, cloneAddress?: string | null): LogDeployEventFilter;

    'LogDeposit(address,address,address,uint256,uint256)'(
      token?: string | null,
      from?: string | null,
      to?: string | null,
      amount?: null,
      share?: null,
    ): LogDepositEventFilter;
    LogDeposit(
      token?: string | null,
      from?: string | null,
      to?: string | null,
      amount?: null,
      share?: null,
    ): LogDepositEventFilter;

    'LogFlashLoan(address,address,uint256,uint256,address)'(
      borrower?: string | null,
      token?: string | null,
      amount?: null,
      feeAmount?: null,
      receiver?: string | null,
    ): LogFlashLoanEventFilter;
    LogFlashLoan(
      borrower?: string | null,
      token?: string | null,
      amount?: null,
      feeAmount?: null,
      receiver?: string | null,
    ): LogFlashLoanEventFilter;

    'LogRegisterProtocol(address)'(protocol?: string | null): LogRegisterProtocolEventFilter;
    LogRegisterProtocol(protocol?: string | null): LogRegisterProtocolEventFilter;

    'LogSetMasterContractApproval(address,address,bool)'(
      masterContract?: string | null,
      user?: string | null,
      approved?: null,
    ): LogSetMasterContractApprovalEventFilter;
    LogSetMasterContractApproval(
      masterContract?: string | null,
      user?: string | null,
      approved?: null,
    ): LogSetMasterContractApprovalEventFilter;

    'LogStrategyDivest(address,uint256)'(token?: string | null, amount?: null): LogStrategyDivestEventFilter;
    LogStrategyDivest(token?: string | null, amount?: null): LogStrategyDivestEventFilter;

    'LogStrategyInvest(address,uint256)'(token?: string | null, amount?: null): LogStrategyInvestEventFilter;
    LogStrategyInvest(token?: string | null, amount?: null): LogStrategyInvestEventFilter;

    'LogStrategyLoss(address,uint256)'(token?: string | null, amount?: null): LogStrategyLossEventFilter;
    LogStrategyLoss(token?: string | null, amount?: null): LogStrategyLossEventFilter;

    'LogStrategyProfit(address,uint256)'(token?: string | null, amount?: null): LogStrategyProfitEventFilter;
    LogStrategyProfit(token?: string | null, amount?: null): LogStrategyProfitEventFilter;

    'LogStrategyQueued(address,address)'(token?: string | null, strategy?: string | null): LogStrategyQueuedEventFilter;
    LogStrategyQueued(token?: string | null, strategy?: string | null): LogStrategyQueuedEventFilter;

    'LogStrategySet(address,address)'(token?: string | null, strategy?: string | null): LogStrategySetEventFilter;
    LogStrategySet(token?: string | null, strategy?: string | null): LogStrategySetEventFilter;

    'LogStrategyTargetPercentage(address,uint256)'(
      token?: string | null,
      targetPercentage?: null,
    ): LogStrategyTargetPercentageEventFilter;
    LogStrategyTargetPercentage(token?: string | null, targetPercentage?: null): LogStrategyTargetPercentageEventFilter;

    'LogTransfer(address,address,address,uint256)'(
      token?: string | null,
      from?: string | null,
      to?: string | null,
      share?: null,
    ): LogTransferEventFilter;
    LogTransfer(token?: string | null, from?: string | null, to?: string | null, share?: null): LogTransferEventFilter;

    'LogWhiteListMasterContract(address,bool)'(
      masterContract?: string | null,
      approved?: null,
    ): LogWhiteListMasterContractEventFilter;
    LogWhiteListMasterContract(masterContract?: string | null, approved?: null): LogWhiteListMasterContractEventFilter;

    'LogWithdraw(address,address,address,uint256,uint256)'(
      token?: string | null,
      from?: string | null,
      to?: string | null,
      amount?: null,
      share?: null,
    ): LogWithdrawEventFilter;
    LogWithdraw(
      token?: string | null,
      from?: string | null,
      to?: string | null,
      amount?: null,
      share?: null,
    ): LogWithdrawEventFilter;

    'OwnershipTransferred(address,address)'(
      previousOwner?: string | null,
      newOwner?: string | null,
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter;
  };

  estimateGas: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber>;

    balanceOf(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;

    batch(
      calls: BytesLike[],
      revertOnFail: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    batchFlashLoan(
      borrower: string,
      receivers: string[],
      tokens: string[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    claimOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    deploy(
      masterContract: string,
      data: BytesLike,
      useCreate2: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    deposit(
      token_: string,
      from: string,
      to: string,
      amount: BigNumberish,
      share: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    flashLoan(
      borrower: string,
      receiver: string,
      token: string,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    harvest(
      token: string,
      balance: boolean,
      maxChangeAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    masterContractApproved(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;

    masterContractOf(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    nonces(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pendingOwner(overrides?: CallOverrides): Promise<BigNumber>;

    pendingStrategy(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    permitToken(
      token: string,
      from: string,
      to: string,
      amount: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    registerProtocol(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    setMasterContractApproval(
      user: string,
      masterContract: string,
      approved: boolean,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    setStrategy(
      token: string,
      newStrategy: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    setStrategyTargetPercentage(
      token: string,
      targetPercentage_: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    strategy(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    strategyData(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    toAmount(token: string, share: BigNumberish, roundUp: boolean, overrides?: CallOverrides): Promise<BigNumber>;

    toShare(token: string, amount: BigNumberish, roundUp: boolean, overrides?: CallOverrides): Promise<BigNumber>;

    totals(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    transfer(
      token: string,
      from: string,
      to: string,
      share: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    transferMultiple(
      token: string,
      from: string,
      tos: string[],
      shares: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      direct: boolean,
      renounce: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    whitelistMasterContract(
      masterContract: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    whitelistedMasterContracts(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    withdraw(
      token_: string,
      from: string,
      to: string,
      amount: BigNumberish,
      share: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    balanceOf(arg0: string, arg1: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    batch(
      calls: BytesLike[],
      revertOnFail: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    batchFlashLoan(
      borrower: string,
      receivers: string[],
      tokens: string[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    claimOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    deploy(
      masterContract: string,
      data: BytesLike,
      useCreate2: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    deposit(
      token_: string,
      from: string,
      to: string,
      amount: BigNumberish,
      share: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    flashLoan(
      borrower: string,
      receiver: string,
      token: string,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    harvest(
      token: string,
      balance: boolean,
      maxChangeAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    masterContractApproved(arg0: string, arg1: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    masterContractOf(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nonces(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingStrategy(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    permitToken(
      token: string,
      from: string,
      to: string,
      amount: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    registerProtocol(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    setMasterContractApproval(
      user: string,
      masterContract: string,
      approved: boolean,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    setStrategy(
      token: string,
      newStrategy: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    setStrategyTargetPercentage(
      token: string,
      targetPercentage_: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    strategy(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    strategyData(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    toAmount(
      token: string,
      share: BigNumberish,
      roundUp: boolean,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    toShare(
      token: string,
      amount: BigNumberish,
      roundUp: boolean,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    totals(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transfer(
      token: string,
      from: string,
      to: string,
      share: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    transferMultiple(
      token: string,
      from: string,
      tos: string[],
      shares: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      direct: boolean,
      renounce: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    whitelistMasterContract(
      masterContract: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    whitelistedMasterContracts(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdraw(
      token_: string,
      from: string,
      to: string,
      amount: BigNumberish,
      share: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;
  };
}

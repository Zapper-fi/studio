/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export interface SushiswapBentoboxInterface extends utils.Interface {
  functions: {
    'DOMAIN_SEPARATOR()': FunctionFragment;
    'balanceOf(address,address)': FunctionFragment;
    'batch(bytes[],bool)': FunctionFragment;
    'batchFlashLoan(address,address[],address[],uint256[],bytes)': FunctionFragment;
    'claimOwnership()': FunctionFragment;
    'deploy(address,bytes,bool)': FunctionFragment;
    'deposit(address,address,address,uint256,uint256)': FunctionFragment;
    'flashLoan(address,address,address,uint256,bytes)': FunctionFragment;
    'harvest(address,bool,uint256)': FunctionFragment;
    'masterContractApproved(address,address)': FunctionFragment;
    'masterContractOf(address)': FunctionFragment;
    'nonces(address)': FunctionFragment;
    'owner()': FunctionFragment;
    'pendingOwner()': FunctionFragment;
    'pendingStrategy(address)': FunctionFragment;
    'permitToken(address,address,address,uint256,uint256,uint8,bytes32,bytes32)': FunctionFragment;
    'registerProtocol()': FunctionFragment;
    'setMasterContractApproval(address,address,bool,uint8,bytes32,bytes32)': FunctionFragment;
    'setStrategy(address,address)': FunctionFragment;
    'setStrategyTargetPercentage(address,uint64)': FunctionFragment;
    'strategy(address)': FunctionFragment;
    'strategyData(address)': FunctionFragment;
    'toAmount(address,uint256,bool)': FunctionFragment;
    'toShare(address,uint256,bool)': FunctionFragment;
    'totals(address)': FunctionFragment;
    'transfer(address,address,address,uint256)': FunctionFragment;
    'transferMultiple(address,address,address[],uint256[])': FunctionFragment;
    'transferOwnership(address,bool,bool)': FunctionFragment;
    'whitelistMasterContract(address,bool)': FunctionFragment;
    'whitelistedMasterContracts(address)': FunctionFragment;
    'withdraw(address,address,address,uint256,uint256)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'DOMAIN_SEPARATOR'
      | 'balanceOf'
      | 'batch'
      | 'batchFlashLoan'
      | 'claimOwnership'
      | 'deploy'
      | 'deposit'
      | 'flashLoan'
      | 'harvest'
      | 'masterContractApproved'
      | 'masterContractOf'
      | 'nonces'
      | 'owner'
      | 'pendingOwner'
      | 'pendingStrategy'
      | 'permitToken'
      | 'registerProtocol'
      | 'setMasterContractApproval'
      | 'setStrategy'
      | 'setStrategyTargetPercentage'
      | 'strategy'
      | 'strategyData'
      | 'toAmount'
      | 'toShare'
      | 'totals'
      | 'transfer'
      | 'transferMultiple'
      | 'transferOwnership'
      | 'whitelistMasterContract'
      | 'whitelistedMasterContracts'
      | 'withdraw',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'DOMAIN_SEPARATOR', values?: undefined): string;
  encodeFunctionData(functionFragment: 'balanceOf', values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'batch', values: [PromiseOrValue<BytesLike>[], PromiseOrValue<boolean>]): string;
  encodeFunctionData(
    functionFragment: 'batchFlashLoan',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>[],
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'claimOwnership', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'deploy',
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'deposit',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'flashLoan',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'harvest',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'masterContractApproved',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'masterContractOf', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'nonces', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pendingOwner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pendingStrategy', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'permitToken',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'registerProtocol', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'setMasterContractApproval',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'setStrategy', values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'setStrategyTargetPercentage',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'strategy', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'strategyData', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'toAmount',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'toShare',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'totals', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'transfer',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'transferMultiple',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'transferOwnership',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'whitelistMasterContract',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'whitelistedMasterContracts', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'withdraw',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;

  decodeFunctionResult(functionFragment: 'DOMAIN_SEPARATOR', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'batch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'batchFlashLoan', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deploy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'flashLoan', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'harvest', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'masterContractApproved', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'masterContractOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nonces', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pendingOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pendingStrategy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'permitToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'registerProtocol', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMasterContractApproval', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setStrategy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setStrategyTargetPercentage', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'strategy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'strategyData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'toAmount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'toShare', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totals', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transfer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferMultiple', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'whitelistMasterContract', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'whitelistedMasterContracts', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result;

  events: {
    'LogDeploy(address,bytes,address)': EventFragment;
    'LogDeposit(address,address,address,uint256,uint256)': EventFragment;
    'LogFlashLoan(address,address,uint256,uint256,address)': EventFragment;
    'LogRegisterProtocol(address)': EventFragment;
    'LogSetMasterContractApproval(address,address,bool)': EventFragment;
    'LogStrategyDivest(address,uint256)': EventFragment;
    'LogStrategyInvest(address,uint256)': EventFragment;
    'LogStrategyLoss(address,uint256)': EventFragment;
    'LogStrategyProfit(address,uint256)': EventFragment;
    'LogStrategyQueued(address,address)': EventFragment;
    'LogStrategySet(address,address)': EventFragment;
    'LogStrategyTargetPercentage(address,uint256)': EventFragment;
    'LogTransfer(address,address,address,uint256)': EventFragment;
    'LogWhiteListMasterContract(address,bool)': EventFragment;
    'LogWithdraw(address,address,address,uint256,uint256)': EventFragment;
    'OwnershipTransferred(address,address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'LogDeploy'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogDeposit'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogFlashLoan'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogRegisterProtocol'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogSetMasterContractApproval'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogStrategyDivest'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogStrategyInvest'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogStrategyLoss'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogStrategyProfit'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogStrategyQueued'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogStrategySet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogStrategyTargetPercentage'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogTransfer'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogWhiteListMasterContract'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LogWithdraw'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
}

export interface LogDeployEventObject {
  masterContract: string;
  data: string;
  cloneAddress: string;
}
export type LogDeployEvent = TypedEvent<[string, string, string], LogDeployEventObject>;

export type LogDeployEventFilter = TypedEventFilter<LogDeployEvent>;

export interface LogDepositEventObject {
  token: string;
  from: string;
  to: string;
  amount: BigNumber;
  share: BigNumber;
}
export type LogDepositEvent = TypedEvent<[string, string, string, BigNumber, BigNumber], LogDepositEventObject>;

export type LogDepositEventFilter = TypedEventFilter<LogDepositEvent>;

export interface LogFlashLoanEventObject {
  borrower: string;
  token: string;
  amount: BigNumber;
  feeAmount: BigNumber;
  receiver: string;
}
export type LogFlashLoanEvent = TypedEvent<[string, string, BigNumber, BigNumber, string], LogFlashLoanEventObject>;

export type LogFlashLoanEventFilter = TypedEventFilter<LogFlashLoanEvent>;

export interface LogRegisterProtocolEventObject {
  protocol: string;
}
export type LogRegisterProtocolEvent = TypedEvent<[string], LogRegisterProtocolEventObject>;

export type LogRegisterProtocolEventFilter = TypedEventFilter<LogRegisterProtocolEvent>;

export interface LogSetMasterContractApprovalEventObject {
  masterContract: string;
  user: string;
  approved: boolean;
}
export type LogSetMasterContractApprovalEvent = TypedEvent<
  [string, string, boolean],
  LogSetMasterContractApprovalEventObject
>;

export type LogSetMasterContractApprovalEventFilter = TypedEventFilter<LogSetMasterContractApprovalEvent>;

export interface LogStrategyDivestEventObject {
  token: string;
  amount: BigNumber;
}
export type LogStrategyDivestEvent = TypedEvent<[string, BigNumber], LogStrategyDivestEventObject>;

export type LogStrategyDivestEventFilter = TypedEventFilter<LogStrategyDivestEvent>;

export interface LogStrategyInvestEventObject {
  token: string;
  amount: BigNumber;
}
export type LogStrategyInvestEvent = TypedEvent<[string, BigNumber], LogStrategyInvestEventObject>;

export type LogStrategyInvestEventFilter = TypedEventFilter<LogStrategyInvestEvent>;

export interface LogStrategyLossEventObject {
  token: string;
  amount: BigNumber;
}
export type LogStrategyLossEvent = TypedEvent<[string, BigNumber], LogStrategyLossEventObject>;

export type LogStrategyLossEventFilter = TypedEventFilter<LogStrategyLossEvent>;

export interface LogStrategyProfitEventObject {
  token: string;
  amount: BigNumber;
}
export type LogStrategyProfitEvent = TypedEvent<[string, BigNumber], LogStrategyProfitEventObject>;

export type LogStrategyProfitEventFilter = TypedEventFilter<LogStrategyProfitEvent>;

export interface LogStrategyQueuedEventObject {
  token: string;
  strategy: string;
}
export type LogStrategyQueuedEvent = TypedEvent<[string, string], LogStrategyQueuedEventObject>;

export type LogStrategyQueuedEventFilter = TypedEventFilter<LogStrategyQueuedEvent>;

export interface LogStrategySetEventObject {
  token: string;
  strategy: string;
}
export type LogStrategySetEvent = TypedEvent<[string, string], LogStrategySetEventObject>;

export type LogStrategySetEventFilter = TypedEventFilter<LogStrategySetEvent>;

export interface LogStrategyTargetPercentageEventObject {
  token: string;
  targetPercentage: BigNumber;
}
export type LogStrategyTargetPercentageEvent = TypedEvent<[string, BigNumber], LogStrategyTargetPercentageEventObject>;

export type LogStrategyTargetPercentageEventFilter = TypedEventFilter<LogStrategyTargetPercentageEvent>;

export interface LogTransferEventObject {
  token: string;
  from: string;
  to: string;
  share: BigNumber;
}
export type LogTransferEvent = TypedEvent<[string, string, string, BigNumber], LogTransferEventObject>;

export type LogTransferEventFilter = TypedEventFilter<LogTransferEvent>;

export interface LogWhiteListMasterContractEventObject {
  masterContract: string;
  approved: boolean;
}
export type LogWhiteListMasterContractEvent = TypedEvent<[string, boolean], LogWhiteListMasterContractEventObject>;

export type LogWhiteListMasterContractEventFilter = TypedEventFilter<LogWhiteListMasterContractEvent>;

export interface LogWithdrawEventObject {
  token: string;
  from: string;
  to: string;
  amount: BigNumber;
  share: BigNumber;
}
export type LogWithdrawEvent = TypedEvent<[string, string, string, BigNumber, BigNumber], LogWithdrawEventObject>;

export type LogWithdrawEventFilter = TypedEventFilter<LogWithdrawEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<[string, string], OwnershipTransferredEventObject>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export interface SushiswapBentobox extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: SushiswapBentoboxInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;

    balanceOf(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    batch(
      calls: PromiseOrValue<BytesLike>[],
      revertOnFail: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    batchFlashLoan(
      borrower: PromiseOrValue<string>,
      receivers: PromiseOrValue<string>[],
      tokens: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    claimOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    deploy(
      masterContract: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      useCreate2: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    deposit(
      token_: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      share: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    flashLoan(
      borrower: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    harvest(
      token: PromiseOrValue<string>,
      balance: PromiseOrValue<boolean>,
      maxChangeAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    masterContractApproved(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    masterContractOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;

    nonces(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pendingOwner(overrides?: CallOverrides): Promise<[string]>;

    pendingStrategy(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;

    permitToken(
      token: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    registerProtocol(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    setMasterContractApproval(
      user: PromiseOrValue<string>,
      masterContract: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setStrategy(
      token: PromiseOrValue<string>,
      newStrategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setStrategyTargetPercentage(
      token: PromiseOrValue<string>,
      targetPercentage_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    strategy(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;

    strategyData(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        strategyStartDate: BigNumber;
        targetPercentage: BigNumber;
        balance: BigNumber;
      }
    >;

    toAmount(
      token: PromiseOrValue<string>,
      share: PromiseOrValue<BigNumberish>,
      roundUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { amount: BigNumber }>;

    toShare(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      roundUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { share: BigNumber }>;

    totals(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { elastic: BigNumber; base: BigNumber }>;

    transfer(
      token: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      share: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    transferMultiple(
      token: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      tos: PromiseOrValue<string>[],
      shares: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      direct: PromiseOrValue<boolean>,
      renounce: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    whitelistMasterContract(
      masterContract: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    whitelistedMasterContracts(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    withdraw(
      token_: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      share: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;
  };

  DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

  balanceOf(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  batch(
    calls: PromiseOrValue<BytesLike>[],
    revertOnFail: PromiseOrValue<boolean>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  batchFlashLoan(
    borrower: PromiseOrValue<string>,
    receivers: PromiseOrValue<string>[],
    tokens: PromiseOrValue<string>[],
    amounts: PromiseOrValue<BigNumberish>[],
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  claimOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  deploy(
    masterContract: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    useCreate2: PromiseOrValue<boolean>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  deposit(
    token_: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    share: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  flashLoan(
    borrower: PromiseOrValue<string>,
    receiver: PromiseOrValue<string>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  harvest(
    token: PromiseOrValue<string>,
    balance: PromiseOrValue<boolean>,
    maxChangeAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  masterContractApproved(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  masterContractOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  nonces(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  pendingOwner(overrides?: CallOverrides): Promise<string>;

  pendingStrategy(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  permitToken(
    token: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    deadline: PromiseOrValue<BigNumberish>,
    v: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    s: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  registerProtocol(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  setMasterContractApproval(
    user: PromiseOrValue<string>,
    masterContract: PromiseOrValue<string>,
    approved: PromiseOrValue<boolean>,
    v: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    s: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setStrategy(
    token: PromiseOrValue<string>,
    newStrategy: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setStrategyTargetPercentage(
    token: PromiseOrValue<string>,
    targetPercentage_: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  strategy(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  strategyData(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      strategyStartDate: BigNumber;
      targetPercentage: BigNumber;
      balance: BigNumber;
    }
  >;

  toAmount(
    token: PromiseOrValue<string>,
    share: PromiseOrValue<BigNumberish>,
    roundUp: PromiseOrValue<boolean>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  toShare(
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    roundUp: PromiseOrValue<boolean>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  totals(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, BigNumber] & { elastic: BigNumber; base: BigNumber }>;

  transfer(
    token: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    share: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  transferMultiple(
    token: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    tos: PromiseOrValue<string>[],
    shares: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    direct: PromiseOrValue<boolean>,
    renounce: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  whitelistMasterContract(
    masterContract: PromiseOrValue<string>,
    approved: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  whitelistedMasterContracts(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  withdraw(
    token_: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    share: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

    balanceOf(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    batch(
      calls: PromiseOrValue<BytesLike>[],
      revertOnFail: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<[boolean[], string[]] & { successes: boolean[]; results: string[] }>;

    batchFlashLoan(
      borrower: PromiseOrValue<string>,
      receivers: PromiseOrValue<string>[],
      tokens: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    claimOwnership(overrides?: CallOverrides): Promise<void>;

    deploy(
      masterContract: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      useCreate2: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<string>;

    deposit(
      token_: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      share: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { amountOut: BigNumber; shareOut: BigNumber }>;

    flashLoan(
      borrower: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    harvest(
      token: PromiseOrValue<string>,
      balance: PromiseOrValue<boolean>,
      maxChangeAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    masterContractApproved(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    masterContractOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    nonces(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    pendingOwner(overrides?: CallOverrides): Promise<string>;

    pendingStrategy(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    permitToken(
      token: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    registerProtocol(overrides?: CallOverrides): Promise<void>;

    setMasterContractApproval(
      user: PromiseOrValue<string>,
      masterContract: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setStrategy(
      token: PromiseOrValue<string>,
      newStrategy: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setStrategyTargetPercentage(
      token: PromiseOrValue<string>,
      targetPercentage_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    strategy(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    strategyData(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        strategyStartDate: BigNumber;
        targetPercentage: BigNumber;
        balance: BigNumber;
      }
    >;

    toAmount(
      token: PromiseOrValue<string>,
      share: PromiseOrValue<BigNumberish>,
      roundUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    toShare(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      roundUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    totals(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { elastic: BigNumber; base: BigNumber }>;

    transfer(
      token: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      share: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    transferMultiple(
      token: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      tos: PromiseOrValue<string>[],
      shares: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<void>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      direct: PromiseOrValue<boolean>,
      renounce: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    whitelistMasterContract(
      masterContract: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    whitelistedMasterContracts(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    withdraw(
      token_: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      share: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { amountOut: BigNumber; shareOut: BigNumber }>;
  };

  filters: {
    'LogDeploy(address,bytes,address)'(
      masterContract?: PromiseOrValue<string> | null,
      data?: null,
      cloneAddress?: PromiseOrValue<string> | null,
    ): LogDeployEventFilter;
    LogDeploy(
      masterContract?: PromiseOrValue<string> | null,
      data?: null,
      cloneAddress?: PromiseOrValue<string> | null,
    ): LogDeployEventFilter;

    'LogDeposit(address,address,address,uint256,uint256)'(
      token?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      amount?: null,
      share?: null,
    ): LogDepositEventFilter;
    LogDeposit(
      token?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      amount?: null,
      share?: null,
    ): LogDepositEventFilter;

    'LogFlashLoan(address,address,uint256,uint256,address)'(
      borrower?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null,
      feeAmount?: null,
      receiver?: PromiseOrValue<string> | null,
    ): LogFlashLoanEventFilter;
    LogFlashLoan(
      borrower?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null,
      feeAmount?: null,
      receiver?: PromiseOrValue<string> | null,
    ): LogFlashLoanEventFilter;

    'LogRegisterProtocol(address)'(protocol?: PromiseOrValue<string> | null): LogRegisterProtocolEventFilter;
    LogRegisterProtocol(protocol?: PromiseOrValue<string> | null): LogRegisterProtocolEventFilter;

    'LogSetMasterContractApproval(address,address,bool)'(
      masterContract?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      approved?: null,
    ): LogSetMasterContractApprovalEventFilter;
    LogSetMasterContractApproval(
      masterContract?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      approved?: null,
    ): LogSetMasterContractApprovalEventFilter;

    'LogStrategyDivest(address,uint256)'(
      token?: PromiseOrValue<string> | null,
      amount?: null,
    ): LogStrategyDivestEventFilter;
    LogStrategyDivest(token?: PromiseOrValue<string> | null, amount?: null): LogStrategyDivestEventFilter;

    'LogStrategyInvest(address,uint256)'(
      token?: PromiseOrValue<string> | null,
      amount?: null,
    ): LogStrategyInvestEventFilter;
    LogStrategyInvest(token?: PromiseOrValue<string> | null, amount?: null): LogStrategyInvestEventFilter;

    'LogStrategyLoss(address,uint256)'(
      token?: PromiseOrValue<string> | null,
      amount?: null,
    ): LogStrategyLossEventFilter;
    LogStrategyLoss(token?: PromiseOrValue<string> | null, amount?: null): LogStrategyLossEventFilter;

    'LogStrategyProfit(address,uint256)'(
      token?: PromiseOrValue<string> | null,
      amount?: null,
    ): LogStrategyProfitEventFilter;
    LogStrategyProfit(token?: PromiseOrValue<string> | null, amount?: null): LogStrategyProfitEventFilter;

    'LogStrategyQueued(address,address)'(
      token?: PromiseOrValue<string> | null,
      strategy?: PromiseOrValue<string> | null,
    ): LogStrategyQueuedEventFilter;
    LogStrategyQueued(
      token?: PromiseOrValue<string> | null,
      strategy?: PromiseOrValue<string> | null,
    ): LogStrategyQueuedEventFilter;

    'LogStrategySet(address,address)'(
      token?: PromiseOrValue<string> | null,
      strategy?: PromiseOrValue<string> | null,
    ): LogStrategySetEventFilter;
    LogStrategySet(
      token?: PromiseOrValue<string> | null,
      strategy?: PromiseOrValue<string> | null,
    ): LogStrategySetEventFilter;

    'LogStrategyTargetPercentage(address,uint256)'(
      token?: PromiseOrValue<string> | null,
      targetPercentage?: null,
    ): LogStrategyTargetPercentageEventFilter;
    LogStrategyTargetPercentage(
      token?: PromiseOrValue<string> | null,
      targetPercentage?: null,
    ): LogStrategyTargetPercentageEventFilter;

    'LogTransfer(address,address,address,uint256)'(
      token?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      share?: null,
    ): LogTransferEventFilter;
    LogTransfer(
      token?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      share?: null,
    ): LogTransferEventFilter;

    'LogWhiteListMasterContract(address,bool)'(
      masterContract?: PromiseOrValue<string> | null,
      approved?: null,
    ): LogWhiteListMasterContractEventFilter;
    LogWhiteListMasterContract(
      masterContract?: PromiseOrValue<string> | null,
      approved?: null,
    ): LogWhiteListMasterContractEventFilter;

    'LogWithdraw(address,address,address,uint256,uint256)'(
      token?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      amount?: null,
      share?: null,
    ): LogWithdrawEventFilter;
    LogWithdraw(
      token?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      amount?: null,
      share?: null,
    ): LogWithdrawEventFilter;

    'OwnershipTransferred(address,address)'(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;
  };

  estimateGas: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber>;

    balanceOf(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    batch(
      calls: PromiseOrValue<BytesLike>[],
      revertOnFail: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    batchFlashLoan(
      borrower: PromiseOrValue<string>,
      receivers: PromiseOrValue<string>[],
      tokens: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    claimOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    deploy(
      masterContract: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      useCreate2: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    deposit(
      token_: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      share: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    flashLoan(
      borrower: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    harvest(
      token: PromiseOrValue<string>,
      balance: PromiseOrValue<boolean>,
      maxChangeAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    masterContractApproved(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    masterContractOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    nonces(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pendingOwner(overrides?: CallOverrides): Promise<BigNumber>;

    pendingStrategy(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    permitToken(
      token: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    registerProtocol(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    setMasterContractApproval(
      user: PromiseOrValue<string>,
      masterContract: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setStrategy(
      token: PromiseOrValue<string>,
      newStrategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setStrategyTargetPercentage(
      token: PromiseOrValue<string>,
      targetPercentage_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    strategy(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    strategyData(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    toAmount(
      token: PromiseOrValue<string>,
      share: PromiseOrValue<BigNumberish>,
      roundUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    toShare(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      roundUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    totals(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    transfer(
      token: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      share: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    transferMultiple(
      token: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      tos: PromiseOrValue<string>[],
      shares: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      direct: PromiseOrValue<boolean>,
      renounce: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    whitelistMasterContract(
      masterContract: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    whitelistedMasterContracts(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    withdraw(
      token_: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      share: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    balanceOf(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    batch(
      calls: PromiseOrValue<BytesLike>[],
      revertOnFail: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    batchFlashLoan(
      borrower: PromiseOrValue<string>,
      receivers: PromiseOrValue<string>[],
      tokens: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    claimOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    deploy(
      masterContract: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      useCreate2: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    deposit(
      token_: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      share: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    flashLoan(
      borrower: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    harvest(
      token: PromiseOrValue<string>,
      balance: PromiseOrValue<boolean>,
      maxChangeAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    masterContractApproved(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    masterContractOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nonces(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingStrategy(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    permitToken(
      token: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    registerProtocol(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    setMasterContractApproval(
      user: PromiseOrValue<string>,
      masterContract: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setStrategy(
      token: PromiseOrValue<string>,
      newStrategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setStrategyTargetPercentage(
      token: PromiseOrValue<string>,
      targetPercentage_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    strategy(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    strategyData(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    toAmount(
      token: PromiseOrValue<string>,
      share: PromiseOrValue<BigNumberish>,
      roundUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    toShare(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      roundUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    totals(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transfer(
      token: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      share: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    transferMultiple(
      token: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      tos: PromiseOrValue<string>[],
      shares: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      direct: PromiseOrValue<boolean>,
      renounce: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    whitelistMasterContract(
      masterContract: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    whitelistedMasterContracts(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdraw(
      token_: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      share: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;
  };
}

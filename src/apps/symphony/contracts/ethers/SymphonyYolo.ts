/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export declare namespace IOrderStructs {
  export type OrderStruct = {
    creator: PromiseOrValue<string>;
    recipient: PromiseOrValue<string>;
    inputToken: PromiseOrValue<string>;
    outputToken: PromiseOrValue<string>;
    inputAmount: PromiseOrValue<BigNumberish>;
    minReturnAmount: PromiseOrValue<BigNumberish>;
    stoplossAmount: PromiseOrValue<BigNumberish>;
    shares: PromiseOrValue<BigNumberish>;
    executor: PromiseOrValue<string>;
    executionFee: PromiseOrValue<BigNumberish>;
  };

  export type OrderStructOutput = [
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    BigNumber,
  ] & {
    creator: string;
    recipient: string;
    inputToken: string;
    outputToken: string;
    inputAmount: BigNumber;
    minReturnAmount: BigNumber;
    stoplossAmount: BigNumber;
    shares: BigNumber;
    executor: string;
    executionFee: BigNumber;
  };
}

export interface SymphonyYoloInterface extends utils.Interface {
  functions: {
    'addHandler(address)': FunctionFragment;
    'addWhitelistToken(address)': FunctionFragment;
    'allowedExecutors(address,address)': FunctionFragment;
    'allowedHandlers(address)': FunctionFragment;
    'approveExecutor(address)': FunctionFragment;
    'cancelOrder(bytes32,bytes)': FunctionFragment;
    'cancellationFeePercent()': FunctionFragment;
    'createNativeOrder(address,address,uint256,uint256,address,uint256)': FunctionFragment;
    'createOrder(address,address,address,uint256,uint256,uint256,address,uint256)': FunctionFragment;
    'decodeOrder(bytes)': FunctionFragment;
    'emergencyAdmin()': FunctionFragment;
    'emergencyWithdrawFromStrategy(address[])': FunctionFragment;
    'executeOrder(bytes32,bytes,address,bytes)': FunctionFragment;
    'fillOrder(bytes32,bytes,uint256)': FunctionFragment;
    'getOrderId(address,address,address,address,uint256,uint256,uint256,address,uint256,uint256)': FunctionFragment;
    'getTotalTokens(address,uint256,address)': FunctionFragment;
    'initialize(address,address,address)': FunctionFragment;
    'migrateStrategy(address,address)': FunctionFragment;
    'oracle()': FunctionFragment;
    'orderHash(bytes32)': FunctionFragment;
    'owner()': FunctionFragment;
    'pause()': FunctionFragment;
    'paused()': FunctionFragment;
    'protocolFeePercent()': FunctionFragment;
    'rebalanceTokens(address[])': FunctionFragment;
    'removeHandler(address)': FunctionFragment;
    'removeWhitelistToken(address)': FunctionFragment;
    'renounceOwnership()': FunctionFragment;
    'revokeExecutor(address)': FunctionFragment;
    'setStrategy(address,address)': FunctionFragment;
    'strategy(address)': FunctionFragment;
    'tokenBuffer(address)': FunctionFragment;
    'totalTokenShares(address)': FunctionFragment;
    'transferOwnership(address)': FunctionFragment;
    'treasury()': FunctionFragment;
    'unpause()': FunctionFragment;
    'updateCancellationFee(uint256)': FunctionFragment;
    'updateEmergencyAdmin(address)': FunctionFragment;
    'updateOracle(address)': FunctionFragment;
    'updateOrder(bytes32,bytes,address,address,uint256,uint256,address,uint256)': FunctionFragment;
    'updateProtocolFee(uint256)': FunctionFragment;
    'updateTokenBuffer(address,uint256)': FunctionFragment;
    'updateTreasury(address)': FunctionFragment;
    'whitelistedTokens(address)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'addHandler'
      | 'addWhitelistToken'
      | 'allowedExecutors'
      | 'allowedHandlers'
      | 'approveExecutor'
      | 'cancelOrder'
      | 'cancellationFeePercent'
      | 'createNativeOrder'
      | 'createOrder'
      | 'decodeOrder'
      | 'emergencyAdmin'
      | 'emergencyWithdrawFromStrategy'
      | 'executeOrder'
      | 'fillOrder'
      | 'getOrderId'
      | 'getTotalTokens'
      | 'initialize'
      | 'migrateStrategy'
      | 'oracle'
      | 'orderHash'
      | 'owner'
      | 'pause'
      | 'paused'
      | 'protocolFeePercent'
      | 'rebalanceTokens'
      | 'removeHandler'
      | 'removeWhitelistToken'
      | 'renounceOwnership'
      | 'revokeExecutor'
      | 'setStrategy'
      | 'strategy'
      | 'tokenBuffer'
      | 'totalTokenShares'
      | 'transferOwnership'
      | 'treasury'
      | 'unpause'
      | 'updateCancellationFee'
      | 'updateEmergencyAdmin'
      | 'updateOracle'
      | 'updateOrder'
      | 'updateProtocolFee'
      | 'updateTokenBuffer'
      | 'updateTreasury'
      | 'whitelistedTokens',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'addHandler', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'addWhitelistToken', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'allowedExecutors',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'allowedHandlers', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'approveExecutor', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'cancelOrder',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(functionFragment: 'cancellationFeePercent', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'createNativeOrder',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'createOrder',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'decodeOrder', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(functionFragment: 'emergencyAdmin', values?: undefined): string;
  encodeFunctionData(functionFragment: 'emergencyWithdrawFromStrategy', values: [PromiseOrValue<string>[]]): string;
  encodeFunctionData(
    functionFragment: 'executeOrder',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>, PromiseOrValue<string>, PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'fillOrder',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getOrderId',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'getTotalTokens',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'initialize',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'migrateStrategy',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'oracle', values?: undefined): string;
  encodeFunctionData(functionFragment: 'orderHash', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pause', values?: undefined): string;
  encodeFunctionData(functionFragment: 'paused', values?: undefined): string;
  encodeFunctionData(functionFragment: 'protocolFeePercent', values?: undefined): string;
  encodeFunctionData(functionFragment: 'rebalanceTokens', values: [PromiseOrValue<string>[]]): string;
  encodeFunctionData(functionFragment: 'removeHandler', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'removeWhitelistToken', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'revokeExecutor', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'setStrategy', values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'strategy', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'tokenBuffer', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'totalTokenShares', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'transferOwnership', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'treasury', values?: undefined): string;
  encodeFunctionData(functionFragment: 'unpause', values?: undefined): string;
  encodeFunctionData(functionFragment: 'updateCancellationFee', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'updateEmergencyAdmin', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'updateOracle', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'updateOrder',
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'updateProtocolFee', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'updateTokenBuffer',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'updateTreasury', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'whitelistedTokens', values: [PromiseOrValue<string>]): string;

  decodeFunctionResult(functionFragment: 'addHandler', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addWhitelistToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allowedExecutors', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allowedHandlers', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'approveExecutor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cancelOrder', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cancellationFeePercent', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'createNativeOrder', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'createOrder', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'decodeOrder', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'emergencyAdmin', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'emergencyWithdrawFromStrategy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'executeOrder', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'fillOrder', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getOrderId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getTotalTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'migrateStrategy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'oracle', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'orderHash', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pause', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'paused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'protocolFeePercent', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rebalanceTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'removeHandler', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'removeWhitelistToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'revokeExecutor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setStrategy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'strategy', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tokenBuffer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalTokenShares', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'treasury', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'unpause', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateCancellationFee', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateEmergencyAdmin', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateOracle', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateOrder', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateProtocolFee', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateTokenBuffer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateTreasury', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'whitelistedTokens', data: BytesLike): Result;

  events: {
    'AddedWhitelistToken(address)': EventFragment;
    'CancellationFeeUpdated(uint256)': EventFragment;
    'EmergencyAdminUpdated(address)': EventFragment;
    'HandlerAdded(address)': EventFragment;
    'HandlerRemoved(address)': EventFragment;
    'OracleAddressUpdated(address)': EventFragment;
    'OrderCancelled(bytes32,uint256)': EventFragment;
    'OrderCreated(bytes32,bytes)': EventFragment;
    'OrderExecuted(bytes32,uint256,uint256)': EventFragment;
    'OrderUpdated(bytes32,bytes32,bytes)': EventFragment;
    'OwnershipTransferred(address,address)': EventFragment;
    'Paused(address)': EventFragment;
    'ProtocolFeeUpdated(uint256)': EventFragment;
    'RemovedWhitelistToken(address)': EventFragment;
    'TokenBufferUpdated(address,uint256)': EventFragment;
    'TokenStrategyUpdated(address,address)': EventFragment;
    'TokensRebalanced(uint256)': EventFragment;
    'Unpaused(address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'AddedWhitelistToken'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CancellationFeeUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'EmergencyAdminUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'HandlerAdded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'HandlerRemoved'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OracleAddressUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OrderCancelled'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OrderCreated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OrderExecuted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OrderUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Paused'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ProtocolFeeUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RemovedWhitelistToken'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TokenBufferUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TokenStrategyUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TokensRebalanced'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Unpaused'): EventFragment;
}

export interface AddedWhitelistTokenEventObject {
  token: string;
}
export type AddedWhitelistTokenEvent = TypedEvent<[string], AddedWhitelistTokenEventObject>;

export type AddedWhitelistTokenEventFilter = TypedEventFilter<AddedWhitelistTokenEvent>;

export interface CancellationFeeUpdatedEventObject {
  feePercent: BigNumber;
}
export type CancellationFeeUpdatedEvent = TypedEvent<[BigNumber], CancellationFeeUpdatedEventObject>;

export type CancellationFeeUpdatedEventFilter = TypedEventFilter<CancellationFeeUpdatedEvent>;

export interface EmergencyAdminUpdatedEventObject {
  admin: string;
}
export type EmergencyAdminUpdatedEvent = TypedEvent<[string], EmergencyAdminUpdatedEventObject>;

export type EmergencyAdminUpdatedEventFilter = TypedEventFilter<EmergencyAdminUpdatedEvent>;

export interface HandlerAddedEventObject {
  handler: string;
}
export type HandlerAddedEvent = TypedEvent<[string], HandlerAddedEventObject>;

export type HandlerAddedEventFilter = TypedEventFilter<HandlerAddedEvent>;

export interface HandlerRemovedEventObject {
  handler: string;
}
export type HandlerRemovedEvent = TypedEvent<[string], HandlerRemovedEventObject>;

export type HandlerRemovedEventFilter = TypedEventFilter<HandlerRemovedEvent>;

export interface OracleAddressUpdatedEventObject {
  oracle: string;
}
export type OracleAddressUpdatedEvent = TypedEvent<[string], OracleAddressUpdatedEventObject>;

export type OracleAddressUpdatedEventFilter = TypedEventFilter<OracleAddressUpdatedEvent>;

export interface OrderCancelledEventObject {
  orderId: string;
  amountReceived: BigNumber;
}
export type OrderCancelledEvent = TypedEvent<[string, BigNumber], OrderCancelledEventObject>;

export type OrderCancelledEventFilter = TypedEventFilter<OrderCancelledEvent>;

export interface OrderCreatedEventObject {
  orderId: string;
  data: string;
}
export type OrderCreatedEvent = TypedEvent<[string, string], OrderCreatedEventObject>;

export type OrderCreatedEventFilter = TypedEventFilter<OrderCreatedEvent>;

export interface OrderExecutedEventObject {
  orderId: string;
  amountReceived: BigNumber;
  depositPlusYield: BigNumber;
}
export type OrderExecutedEvent = TypedEvent<[string, BigNumber, BigNumber], OrderExecutedEventObject>;

export type OrderExecutedEventFilter = TypedEventFilter<OrderExecutedEvent>;

export interface OrderUpdatedEventObject {
  oldOrderId: string;
  newOrderId: string;
  data: string;
}
export type OrderUpdatedEvent = TypedEvent<[string, string, string], OrderUpdatedEventObject>;

export type OrderUpdatedEventFilter = TypedEventFilter<OrderUpdatedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<[string, string], OwnershipTransferredEventObject>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export interface PausedEventObject {
  account: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface ProtocolFeeUpdatedEventObject {
  feePercent: BigNumber;
}
export type ProtocolFeeUpdatedEvent = TypedEvent<[BigNumber], ProtocolFeeUpdatedEventObject>;

export type ProtocolFeeUpdatedEventFilter = TypedEventFilter<ProtocolFeeUpdatedEvent>;

export interface RemovedWhitelistTokenEventObject {
  token: string;
}
export type RemovedWhitelistTokenEvent = TypedEvent<[string], RemovedWhitelistTokenEventObject>;

export type RemovedWhitelistTokenEventFilter = TypedEventFilter<RemovedWhitelistTokenEvent>;

export interface TokenBufferUpdatedEventObject {
  token: string;
  bufferPercent: BigNumber;
}
export type TokenBufferUpdatedEvent = TypedEvent<[string, BigNumber], TokenBufferUpdatedEventObject>;

export type TokenBufferUpdatedEventFilter = TypedEventFilter<TokenBufferUpdatedEvent>;

export interface TokenStrategyUpdatedEventObject {
  token: string;
  strategy: string;
}
export type TokenStrategyUpdatedEvent = TypedEvent<[string, string], TokenStrategyUpdatedEventObject>;

export type TokenStrategyUpdatedEventFilter = TypedEventFilter<TokenStrategyUpdatedEvent>;

export interface TokensRebalancedEventObject {
  txCost: BigNumber;
}
export type TokensRebalancedEvent = TypedEvent<[BigNumber], TokensRebalancedEventObject>;

export type TokensRebalancedEventFilter = TypedEventFilter<TokensRebalancedEvent>;

export interface UnpausedEventObject {
  account: string;
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface SymphonyYolo extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: SymphonyYoloInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    addHandler(
      _handler: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    addWhitelistToken(
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    allowedExecutors(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    allowedHandlers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    approveExecutor(
      executor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    cancelOrder(
      orderId: PromiseOrValue<BytesLike>,
      orderData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    cancellationFeePercent(overrides?: CallOverrides): Promise<[BigNumber]>;

    createNativeOrder(
      recipient: PromiseOrValue<string>,
      outputToken: PromiseOrValue<string>,
      minReturnAmount: PromiseOrValue<BigNumberish>,
      stoplossAmount: PromiseOrValue<BigNumberish>,
      executor: PromiseOrValue<string>,
      executionFee: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    createOrder(
      recipient: PromiseOrValue<string>,
      inputToken: PromiseOrValue<string>,
      outputToken: PromiseOrValue<string>,
      inputAmount: PromiseOrValue<BigNumberish>,
      minReturnAmount: PromiseOrValue<BigNumberish>,
      stoplossAmount: PromiseOrValue<BigNumberish>,
      executor: PromiseOrValue<string>,
      executionFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    decodeOrder(
      orderData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<
      [IOrderStructs.OrderStructOutput] & {
        order: IOrderStructs.OrderStructOutput;
      }
    >;

    emergencyAdmin(overrides?: CallOverrides): Promise<[string]>;

    emergencyWithdrawFromStrategy(
      _tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    executeOrder(
      orderId: PromiseOrValue<BytesLike>,
      orderData: PromiseOrValue<BytesLike>,
      handler: PromiseOrValue<string>,
      handlerData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    fillOrder(
      orderId: PromiseOrValue<BytesLike>,
      orderData: PromiseOrValue<BytesLike>,
      quoteAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    getOrderId(
      creator: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      inputToken: PromiseOrValue<string>,
      outputToken: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      minReturnAmount: PromiseOrValue<BigNumberish>,
      stoplossAmount: PromiseOrValue<BigNumberish>,
      executor: PromiseOrValue<string>,
      executionFee: PromiseOrValue<BigNumberish>,
      blockTimestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string]>;

    getTotalTokens(
      token: PromiseOrValue<string>,
      contractBalance: PromiseOrValue<BigNumberish>,
      tokenStrategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    initialize(
      _owner: PromiseOrValue<string>,
      _emergencyAdmin: PromiseOrValue<string>,
      _oracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    migrateStrategy(
      _token: PromiseOrValue<string>,
      _newStrategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    oracle(overrides?: CallOverrides): Promise<[string]>;

    orderHash(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    protocolFeePercent(overrides?: CallOverrides): Promise<[BigNumber]>;

    rebalanceTokens(
      tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    removeHandler(
      _handler: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    removeWhitelistToken(
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    revokeExecutor(
      executor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setStrategy(
      _token: PromiseOrValue<string>,
      _strategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    strategy(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;

    tokenBuffer(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    totalTokenShares(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    treasury(overrides?: CallOverrides): Promise<[string]>;

    unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    updateCancellationFee(
      _feePercent: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateEmergencyAdmin(
      _emergencyAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateOracle(
      _oracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateOrder(
      orderId: PromiseOrValue<BytesLike>,
      orderData: PromiseOrValue<BytesLike>,
      recipient: PromiseOrValue<string>,
      outputToken: PromiseOrValue<string>,
      minReturnAmount: PromiseOrValue<BigNumberish>,
      stoplossAmount: PromiseOrValue<BigNumberish>,
      executor: PromiseOrValue<string>,
      executionFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateProtocolFee(
      _feePercent: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateTokenBuffer(
      _token: PromiseOrValue<string>,
      _bufferPercent: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateTreasury(
      _treasury: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    whitelistedTokens(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
  };

  addHandler(
    _handler: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  addWhitelistToken(
    _token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  allowedExecutors(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  allowedHandlers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  approveExecutor(
    executor: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  cancelOrder(
    orderId: PromiseOrValue<BytesLike>,
    orderData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  cancellationFeePercent(overrides?: CallOverrides): Promise<BigNumber>;

  createNativeOrder(
    recipient: PromiseOrValue<string>,
    outputToken: PromiseOrValue<string>,
    minReturnAmount: PromiseOrValue<BigNumberish>,
    stoplossAmount: PromiseOrValue<BigNumberish>,
    executor: PromiseOrValue<string>,
    executionFee: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  createOrder(
    recipient: PromiseOrValue<string>,
    inputToken: PromiseOrValue<string>,
    outputToken: PromiseOrValue<string>,
    inputAmount: PromiseOrValue<BigNumberish>,
    minReturnAmount: PromiseOrValue<BigNumberish>,
    stoplossAmount: PromiseOrValue<BigNumberish>,
    executor: PromiseOrValue<string>,
    executionFee: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  decodeOrder(
    orderData: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides,
  ): Promise<IOrderStructs.OrderStructOutput>;

  emergencyAdmin(overrides?: CallOverrides): Promise<string>;

  emergencyWithdrawFromStrategy(
    _tokens: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  executeOrder(
    orderId: PromiseOrValue<BytesLike>,
    orderData: PromiseOrValue<BytesLike>,
    handler: PromiseOrValue<string>,
    handlerData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  fillOrder(
    orderId: PromiseOrValue<BytesLike>,
    orderData: PromiseOrValue<BytesLike>,
    quoteAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  getOrderId(
    creator: PromiseOrValue<string>,
    recipient: PromiseOrValue<string>,
    inputToken: PromiseOrValue<string>,
    outputToken: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    minReturnAmount: PromiseOrValue<BigNumberish>,
    stoplossAmount: PromiseOrValue<BigNumberish>,
    executor: PromiseOrValue<string>,
    executionFee: PromiseOrValue<BigNumberish>,
    blockTimestamp: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<string>;

  getTotalTokens(
    token: PromiseOrValue<string>,
    contractBalance: PromiseOrValue<BigNumberish>,
    tokenStrategy: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  initialize(
    _owner: PromiseOrValue<string>,
    _emergencyAdmin: PromiseOrValue<string>,
    _oracle: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  migrateStrategy(
    _token: PromiseOrValue<string>,
    _newStrategy: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  oracle(overrides?: CallOverrides): Promise<string>;

  orderHash(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

  owner(overrides?: CallOverrides): Promise<string>;

  pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  protocolFeePercent(overrides?: CallOverrides): Promise<BigNumber>;

  rebalanceTokens(
    tokens: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  removeHandler(
    _handler: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  removeWhitelistToken(
    _token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  revokeExecutor(
    executor: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setStrategy(
    _token: PromiseOrValue<string>,
    _strategy: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  strategy(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

  tokenBuffer(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  totalTokenShares(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  treasury(overrides?: CallOverrides): Promise<string>;

  unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  updateCancellationFee(
    _feePercent: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateEmergencyAdmin(
    _emergencyAdmin: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateOracle(
    _oracle: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateOrder(
    orderId: PromiseOrValue<BytesLike>,
    orderData: PromiseOrValue<BytesLike>,
    recipient: PromiseOrValue<string>,
    outputToken: PromiseOrValue<string>,
    minReturnAmount: PromiseOrValue<BigNumberish>,
    stoplossAmount: PromiseOrValue<BigNumberish>,
    executor: PromiseOrValue<string>,
    executionFee: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateProtocolFee(
    _feePercent: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateTokenBuffer(
    _token: PromiseOrValue<string>,
    _bufferPercent: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  updateTreasury(
    _treasury: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  whitelistedTokens(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  callStatic: {
    addHandler(_handler: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    addWhitelistToken(_token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    allowedExecutors(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    allowedHandlers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    approveExecutor(executor: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    cancelOrder(
      orderId: PromiseOrValue<BytesLike>,
      orderData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    cancellationFeePercent(overrides?: CallOverrides): Promise<BigNumber>;

    createNativeOrder(
      recipient: PromiseOrValue<string>,
      outputToken: PromiseOrValue<string>,
      minReturnAmount: PromiseOrValue<BigNumberish>,
      stoplossAmount: PromiseOrValue<BigNumberish>,
      executor: PromiseOrValue<string>,
      executionFee: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string, string] & { orderId: string; orderData: string }>;

    createOrder(
      recipient: PromiseOrValue<string>,
      inputToken: PromiseOrValue<string>,
      outputToken: PromiseOrValue<string>,
      inputAmount: PromiseOrValue<BigNumberish>,
      minReturnAmount: PromiseOrValue<BigNumberish>,
      stoplossAmount: PromiseOrValue<BigNumberish>,
      executor: PromiseOrValue<string>,
      executionFee: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string, string] & { orderId: string; orderData: string }>;

    decodeOrder(
      orderData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<IOrderStructs.OrderStructOutput>;

    emergencyAdmin(overrides?: CallOverrides): Promise<string>;

    emergencyWithdrawFromStrategy(_tokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;

    executeOrder(
      orderId: PromiseOrValue<BytesLike>,
      orderData: PromiseOrValue<BytesLike>,
      handler: PromiseOrValue<string>,
      handlerData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    fillOrder(
      orderId: PromiseOrValue<BytesLike>,
      orderData: PromiseOrValue<BytesLike>,
      quoteAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    getOrderId(
      creator: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      inputToken: PromiseOrValue<string>,
      outputToken: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      minReturnAmount: PromiseOrValue<BigNumberish>,
      stoplossAmount: PromiseOrValue<BigNumberish>,
      executor: PromiseOrValue<string>,
      executionFee: PromiseOrValue<BigNumberish>,
      blockTimestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<string>;

    getTotalTokens(
      token: PromiseOrValue<string>,
      contractBalance: PromiseOrValue<BigNumberish>,
      tokenStrategy: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    initialize(
      _owner: PromiseOrValue<string>,
      _emergencyAdmin: PromiseOrValue<string>,
      _oracle: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    migrateStrategy(
      _token: PromiseOrValue<string>,
      _newStrategy: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    oracle(overrides?: CallOverrides): Promise<string>;

    orderHash(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    pause(overrides?: CallOverrides): Promise<void>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    protocolFeePercent(overrides?: CallOverrides): Promise<BigNumber>;

    rebalanceTokens(tokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;

    removeHandler(_handler: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    removeWhitelistToken(_token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    revokeExecutor(executor: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setStrategy(
      _token: PromiseOrValue<string>,
      _strategy: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    strategy(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    tokenBuffer(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    totalTokenShares(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(newOwner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    treasury(overrides?: CallOverrides): Promise<string>;

    unpause(overrides?: CallOverrides): Promise<void>;

    updateCancellationFee(_feePercent: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    updateEmergencyAdmin(_emergencyAdmin: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    updateOracle(_oracle: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    updateOrder(
      orderId: PromiseOrValue<BytesLike>,
      orderData: PromiseOrValue<BytesLike>,
      recipient: PromiseOrValue<string>,
      outputToken: PromiseOrValue<string>,
      minReturnAmount: PromiseOrValue<BigNumberish>,
      stoplossAmount: PromiseOrValue<BigNumberish>,
      executor: PromiseOrValue<string>,
      executionFee: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string, string] & { newOrderId: string; newOrderData: string }>;

    updateProtocolFee(_feePercent: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    updateTokenBuffer(
      _token: PromiseOrValue<string>,
      _bufferPercent: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    updateTreasury(_treasury: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    whitelistedTokens(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
  };

  filters: {
    'AddedWhitelistToken(address)'(token?: null): AddedWhitelistTokenEventFilter;
    AddedWhitelistToken(token?: null): AddedWhitelistTokenEventFilter;

    'CancellationFeeUpdated(uint256)'(feePercent?: null): CancellationFeeUpdatedEventFilter;
    CancellationFeeUpdated(feePercent?: null): CancellationFeeUpdatedEventFilter;

    'EmergencyAdminUpdated(address)'(admin?: null): EmergencyAdminUpdatedEventFilter;
    EmergencyAdminUpdated(admin?: null): EmergencyAdminUpdatedEventFilter;

    'HandlerAdded(address)'(handler?: null): HandlerAddedEventFilter;
    HandlerAdded(handler?: null): HandlerAddedEventFilter;

    'HandlerRemoved(address)'(handler?: null): HandlerRemovedEventFilter;
    HandlerRemoved(handler?: null): HandlerRemovedEventFilter;

    'OracleAddressUpdated(address)'(oracle?: null): OracleAddressUpdatedEventFilter;
    OracleAddressUpdated(oracle?: null): OracleAddressUpdatedEventFilter;

    'OrderCancelled(bytes32,uint256)'(orderId?: null, amountReceived?: null): OrderCancelledEventFilter;
    OrderCancelled(orderId?: null, amountReceived?: null): OrderCancelledEventFilter;

    'OrderCreated(bytes32,bytes)'(orderId?: null, data?: null): OrderCreatedEventFilter;
    OrderCreated(orderId?: null, data?: null): OrderCreatedEventFilter;

    'OrderExecuted(bytes32,uint256,uint256)'(
      orderId?: null,
      amountReceived?: null,
      depositPlusYield?: null,
    ): OrderExecutedEventFilter;
    OrderExecuted(orderId?: null, amountReceived?: null, depositPlusYield?: null): OrderExecutedEventFilter;

    'OrderUpdated(bytes32,bytes32,bytes)'(oldOrderId?: null, newOrderId?: null, data?: null): OrderUpdatedEventFilter;
    OrderUpdated(oldOrderId?: null, newOrderId?: null, data?: null): OrderUpdatedEventFilter;

    'OwnershipTransferred(address,address)'(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;

    'Paused(address)'(account?: null): PausedEventFilter;
    Paused(account?: null): PausedEventFilter;

    'ProtocolFeeUpdated(uint256)'(feePercent?: null): ProtocolFeeUpdatedEventFilter;
    ProtocolFeeUpdated(feePercent?: null): ProtocolFeeUpdatedEventFilter;

    'RemovedWhitelistToken(address)'(token?: null): RemovedWhitelistTokenEventFilter;
    RemovedWhitelistToken(token?: null): RemovedWhitelistTokenEventFilter;

    'TokenBufferUpdated(address,uint256)'(token?: null, bufferPercent?: null): TokenBufferUpdatedEventFilter;
    TokenBufferUpdated(token?: null, bufferPercent?: null): TokenBufferUpdatedEventFilter;

    'TokenStrategyUpdated(address,address)'(token?: null, strategy?: null): TokenStrategyUpdatedEventFilter;
    TokenStrategyUpdated(token?: null, strategy?: null): TokenStrategyUpdatedEventFilter;

    'TokensRebalanced(uint256)'(txCost?: null): TokensRebalancedEventFilter;
    TokensRebalanced(txCost?: null): TokensRebalancedEventFilter;

    'Unpaused(address)'(account?: null): UnpausedEventFilter;
    Unpaused(account?: null): UnpausedEventFilter;
  };

  estimateGas: {
    addHandler(
      _handler: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    addWhitelistToken(
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    allowedExecutors(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    allowedHandlers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    approveExecutor(
      executor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    cancelOrder(
      orderId: PromiseOrValue<BytesLike>,
      orderData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    cancellationFeePercent(overrides?: CallOverrides): Promise<BigNumber>;

    createNativeOrder(
      recipient: PromiseOrValue<string>,
      outputToken: PromiseOrValue<string>,
      minReturnAmount: PromiseOrValue<BigNumberish>,
      stoplossAmount: PromiseOrValue<BigNumberish>,
      executor: PromiseOrValue<string>,
      executionFee: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    createOrder(
      recipient: PromiseOrValue<string>,
      inputToken: PromiseOrValue<string>,
      outputToken: PromiseOrValue<string>,
      inputAmount: PromiseOrValue<BigNumberish>,
      minReturnAmount: PromiseOrValue<BigNumberish>,
      stoplossAmount: PromiseOrValue<BigNumberish>,
      executor: PromiseOrValue<string>,
      executionFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    decodeOrder(orderData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    emergencyAdmin(overrides?: CallOverrides): Promise<BigNumber>;

    emergencyWithdrawFromStrategy(
      _tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    executeOrder(
      orderId: PromiseOrValue<BytesLike>,
      orderData: PromiseOrValue<BytesLike>,
      handler: PromiseOrValue<string>,
      handlerData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    fillOrder(
      orderId: PromiseOrValue<BytesLike>,
      orderData: PromiseOrValue<BytesLike>,
      quoteAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    getOrderId(
      creator: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      inputToken: PromiseOrValue<string>,
      outputToken: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      minReturnAmount: PromiseOrValue<BigNumberish>,
      stoplossAmount: PromiseOrValue<BigNumberish>,
      executor: PromiseOrValue<string>,
      executionFee: PromiseOrValue<BigNumberish>,
      blockTimestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getTotalTokens(
      token: PromiseOrValue<string>,
      contractBalance: PromiseOrValue<BigNumberish>,
      tokenStrategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    initialize(
      _owner: PromiseOrValue<string>,
      _emergencyAdmin: PromiseOrValue<string>,
      _oracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    migrateStrategy(
      _token: PromiseOrValue<string>,
      _newStrategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    oracle(overrides?: CallOverrides): Promise<BigNumber>;

    orderHash(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    protocolFeePercent(overrides?: CallOverrides): Promise<BigNumber>;

    rebalanceTokens(
      tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    removeHandler(
      _handler: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    removeWhitelistToken(
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    revokeExecutor(
      executor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setStrategy(
      _token: PromiseOrValue<string>,
      _strategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    strategy(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    tokenBuffer(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    totalTokenShares(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    treasury(overrides?: CallOverrides): Promise<BigNumber>;

    unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    updateCancellationFee(
      _feePercent: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateEmergencyAdmin(
      _emergencyAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateOracle(
      _oracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateOrder(
      orderId: PromiseOrValue<BytesLike>,
      orderData: PromiseOrValue<BytesLike>,
      recipient: PromiseOrValue<string>,
      outputToken: PromiseOrValue<string>,
      minReturnAmount: PromiseOrValue<BigNumberish>,
      stoplossAmount: PromiseOrValue<BigNumberish>,
      executor: PromiseOrValue<string>,
      executionFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateProtocolFee(
      _feePercent: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateTokenBuffer(
      _token: PromiseOrValue<string>,
      _bufferPercent: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    updateTreasury(
      _treasury: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    whitelistedTokens(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    addHandler(
      _handler: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    addWhitelistToken(
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    allowedExecutors(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    allowedHandlers(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    approveExecutor(
      executor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    cancelOrder(
      orderId: PromiseOrValue<BytesLike>,
      orderData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    cancellationFeePercent(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    createNativeOrder(
      recipient: PromiseOrValue<string>,
      outputToken: PromiseOrValue<string>,
      minReturnAmount: PromiseOrValue<BigNumberish>,
      stoplossAmount: PromiseOrValue<BigNumberish>,
      executor: PromiseOrValue<string>,
      executionFee: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    createOrder(
      recipient: PromiseOrValue<string>,
      inputToken: PromiseOrValue<string>,
      outputToken: PromiseOrValue<string>,
      inputAmount: PromiseOrValue<BigNumberish>,
      minReturnAmount: PromiseOrValue<BigNumberish>,
      stoplossAmount: PromiseOrValue<BigNumberish>,
      executor: PromiseOrValue<string>,
      executionFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    decodeOrder(orderData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    emergencyAdmin(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    emergencyWithdrawFromStrategy(
      _tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    executeOrder(
      orderId: PromiseOrValue<BytesLike>,
      orderData: PromiseOrValue<BytesLike>,
      handler: PromiseOrValue<string>,
      handlerData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    fillOrder(
      orderId: PromiseOrValue<BytesLike>,
      orderData: PromiseOrValue<BytesLike>,
      quoteAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    getOrderId(
      creator: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      inputToken: PromiseOrValue<string>,
      outputToken: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      minReturnAmount: PromiseOrValue<BigNumberish>,
      stoplossAmount: PromiseOrValue<BigNumberish>,
      executor: PromiseOrValue<string>,
      executionFee: PromiseOrValue<BigNumberish>,
      blockTimestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getTotalTokens(
      token: PromiseOrValue<string>,
      contractBalance: PromiseOrValue<BigNumberish>,
      tokenStrategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    initialize(
      _owner: PromiseOrValue<string>,
      _emergencyAdmin: PromiseOrValue<string>,
      _oracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    migrateStrategy(
      _token: PromiseOrValue<string>,
      _newStrategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    oracle(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    orderHash(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    protocolFeePercent(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rebalanceTokens(
      tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    removeHandler(
      _handler: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    removeWhitelistToken(
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    revokeExecutor(
      executor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setStrategy(
      _token: PromiseOrValue<string>,
      _strategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    strategy(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokenBuffer(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalTokenShares(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    treasury(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    updateCancellationFee(
      _feePercent: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateEmergencyAdmin(
      _emergencyAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateOracle(
      _oracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateOrder(
      orderId: PromiseOrValue<BytesLike>,
      orderData: PromiseOrValue<BytesLike>,
      recipient: PromiseOrValue<string>,
      outputToken: PromiseOrValue<string>,
      minReturnAmount: PromiseOrValue<BigNumberish>,
      stoplossAmount: PromiseOrValue<BigNumberish>,
      executor: PromiseOrValue<string>,
      executionFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateProtocolFee(
      _feePercent: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateTokenBuffer(
      _token: PromiseOrValue<string>,
      _bufferPercent: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    updateTreasury(
      _treasury: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    whitelistedTokens(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
